[1,["7dj5uJT9FMn6OrOOx83tfK@f9941","20g1ukYUVPvKWKBRznAKo+@f9941","89BnjFPsJGF7baQSzRBKJW@6c48a","22nP5VVnhJ3qjInGOVrzd7@f9941","3bcZTTF9RGm7xmb0D9/+af","1eN2LbGE9LWZvBOkA5t6+z","10uxjTio9H6au36g+RSl0h@f9941","85HvHmYCZKLZyK2XNz1+0A@f9941","1dTR54fF9M5pcJ2Pd9bBMp","bfb7FM9B1PQIP81WdYKB2E","05A5K2rgRMI50X4BmoJ82I@6c48a","15N6779j9K7LcAZk0meAC5","27ghjPY2hPF6mK+DQ8czor@f9941","0cMCjnFWNGy7Ty7BiKOM3K@f9941","704RaJUd1CdLiOXsy2cIaO@f9941","c8w8RnA5tFi6vLdUTVDnfI@f9941","54TknWPwVPqJqeCR+Y/Czo@f9941","95EkngnxZFbYuFpsqVTaFr@f9941","97m08jhDxF2ba7HqC3KPJo@f9941","88WWDQHVJDyLoqmVQejc5X@f9941","97u76gf/tJoo5UTOqpAgUH@f9941","1e9r8eBZdC2IHjeSJCBJwG@f9941","77mtANL+xHDZz17mAV8OU/@6c48a","1brw/JvvpFnIvdrxpFCgMZ","3bDW0p8kNJMautHqCHFK5K@f9941","563wfpQHpK2LLQQ/uAyVjt@f9941","f0ET/Wr+ZB/bVoKDBTH96t@f9941","d727kxBGJN9oKdlVphxU4k@f9941","a69sOsDfROrLYPqI4GoJ9S@f9941","68rBUsJ5VLgZ682uFhE8sj@f9941","05A5K2rgRMI50X4BmoJ82I@f9941","8atXTZ0DFG8JilJ1ve8hsp@f9941","d5+Zvlb4dCRYXKnBy0noi9@f9941","8aQIN8f0tFArxSwhXDkAuY@f9941","0fJczTPTVOKJq2qx7+fA6m@f9941","feSoU8GU1OHaglYHoLDaYe@f9941","7f3AJ7MmBIs6Q/SbJeuvey@f9941","aaOMlhlv5A9q6NNMZJ190t@f9941","aaaoZ+gA5M570Es+/z2lbS@f9941","024iX7+RdCE5MegHCmyFeo@f9941","59Z5AVEzpBX4rPidWdcOjT@f9941","c97+2AwNdHT7anIRT9K7ds","67KnesvCNOTbaHDU2wSjq8@f9941","09Xdq873xBXpI30owYdfv3@f9941","cddVrOQJlMIpKhEwahHph4","71+TJq9wVPb5FfBu6W8pvF","5aODC0IBRD1qcn1jmk5Fph@f9941","74DbquNtZMKqdfEpsge2SD@f9941","8f3953Q5xKfpRsvO+180FI","72IJTu5g5PL6H7lQI7Ectp","e92GqeNchBuL1bZ0+LcjLp@f9941","48jYqA401HzryCfmxaH9xv@f9941","d22HrDn+9Mm4pSD6XJtM/R@f9941","09Xdq873xBXpI30owYdfv3@6c48a","09an7Xt2BJFb1zcl0XNa65@6c48a","10uxjTio9H6au36g+RSl0h@6c48a","85p+QqcGlFa4+iE/yX6gOV","1ccloJCQBNQaID1eHao95E@6c48a","1ccloJCQBNQaID1eHao95E@f9941","d1NGQ2rJZCcbhjH0/erZWw","1e9r8eBZdC2IHjeSJCBJwG@6c48a","20g1ukYUVPvKWKBRznAKo+@6c48a","b34DYV8aFN24PzyzgNb3Dl","91uIWV98hAxIf0ZFN52Ubt@f9941","7f91eW0HZF6I8Awveh60c6@f9941","32008ev4FNMbmLTWsPyxcI","3bDW0p8kNJMautHqCHFK5K@6c48a","09an7Xt2BJFb1zcl0XNa65@f9941","54TknWPwVPqJqeCR+Y/Czo@6c48a","563wfpQHpK2LLQQ/uAyVjt@6c48a","445IwtinxFWLaVCOOunxlh","642T96xrlJ75jl27YKirio@6c48a","32Ce53jfZMka9ppsBOUkhP@f9941","e0GhRlZo9OiIEli9pReufa@f9941","63BOOs6NFA0oiy5Hgh4p/1@f9941","1dDcEoIP1E2IujRQDwqTQ4@f9941","6bhVb7eI9B+a3dPyXqu2lV@f9941","37j/LfRJxH9ouqDFRztFtB@f9941","69K/N0aApKvL0N3DLewlLY@f9941","81xyTNPx1ItajjRzLAlIpC@f9941","cbViLn67xKJKSL7vBWfalc@f9941","ebHWsotLdGv6PokajTRuUq@f9941","869K0s9PFAzYb52sChTHFH@f9941","60D/3S8kBIMo0oJPEZg64d@f9941","b7AOS0eSNMd5UT8A8ItHln@f9941","22UUBQB1NDP5orvKcVnIiv","72UnM8/0ZC4o78Fjl+C3Kj@6c48a","94in4Kt6NKTYlQoTZcTtqZ@f9941","e5BRIdU3RFnLdmJEd6vWUX@f9941","e8dSrQxkRNZZzeluKqfcKJ@f9941","72UnM8/0ZC4o78Fjl+C3Kj@f9941","d6opJhppVAQ51IhqBpB+xu@f9941","dcZZW9y6RNeJ7hDZiTA59C@f9941","99YNcXggdO4Kc8zNIkbD2i@f9941","584JP67jNHgYO9GIm1fuWK@f9941","a3gX3w/uxDCrn6I5qEfFoG@f9941","a1OyqGF0JHxZsIlVLIC5l+@f9941","493u/7a5BFwY38m9DxgvVa@f9941","93li5N0sdKM6CCXek3qX+L@f9941","40PZT3IYtInZXU/FdFejGp","90qxaJSoFB46o/SApVVyv6@f9941","72wt5Pn+FFK6WakipdmJ/j@f9941","07mNmGB6tA6ZmXRe3tVXSt","aa0TX/zKpMNLaGNqvcI2NB@f9941","5cXulplIJHwafxXgIH46kK@f9941","09qt1yIGFBWqSo78c70os1","b59Ij32NRBcJWVN/+jODbS@f9941","a15usp0HVP2KJmhcHtEj/r@f9941","4fIOayGJNJo7AJFI4SUs7/@f9941","61qCJZAvVABpjx4Es9lhhK@f9941","e3eZ6X/fNJSJqtSqz1+Apw@f9941","2a5YKyWsZMeqOHOrYvf34+@f9941","92CcboO5ZIXrVzxPIak3VZ@f9941","83yJ3N3lRNkapJdS7IFMgt@f9941","d0pvFBb9tESo1nJ6YZ/jHx@f9941","979hPbysVLe7het89doWI3","abdgosBOdFAIOm7woxmqWX","aabzcNXK9EPY9uYy1avcYE","1aRB8EBxxEXKaZRk6/vXpS","e9L9zOukFGTLmWkJqabFZ7","60cxQV3z9EfYGlIEQyN7Le","9b/RkkCAdBrIpfJdVJbvOq","34vWwG10JDqKubFMq0z353","21U1/kzVRN5oAGJJ/GLiBp","d373mfDsxKnYCw4bnS3w7O@f9941","70fpcsFNhCNLLQWoHJ4cha@f9941","65zLR5MQdGa6Mhnik7iHK3","7dj5uJT9FMn6OrOOx83tfK@6c48a","7f91eW0HZF6I8Awveh60c6@6c48a","88WWDQHVJDyLoqmVQejc5X@6c48a","91uIWV98hAxIf0ZFN52Ubt@6c48a","95EkngnxZFbYuFpsqVTaFr@6c48a","97m08jhDxF2ba7HqC3KPJo@6c48a","97u76gf/tJoo5UTOqpAgUH@6c48a","0ayA53OkRMEag0IZqNwRSL","40v2TYHK5G1rHNpwPqjaQi","5eJFnnOCtMjLgyCsUdYb5g","693kqRSZhLnpoFZ6/RcDa0","b59Ij32NRBcJWVN/+jODbS@6c48a","feSoGSYTxOh4/EwUm/XQhK@f9941","e76/h0hRBIL6WjlxBFWylZ@f9941","9ei14d75VJipAXwnM0af9I@7edd0","bfNF7bozlJgIajg0noIG/k@df2df","65rbH9aohEZZLZST2V7/PN","01hY+mTnBNqIdwWcaFQS4h","de43KGEPJKc7eLg9etaLGN","c5NKB1Gy9KDrlUKGlqT5rU","be+du8tqFAP7Y6Xa6abr7D","2dpXu6bXhB+rHEsP1uU1bM","d7nJvmMlJGjaKHaMEIWvUh","384exmCp5LU6V6ziRQREoK","04S3S48nZKf7Vz5KLbkS6q","d3jqCHAThHJakpXGgxcNyG","d3x4IMKphEKYvHuEU7yaxB","12Y9dMgWdJKJGmTiZyQR9H@801ec","cfS3NkYZ9Bc5KqVfdUFjok@f9941","f06lppJ/1O77/mB46YmGqP@f9941","91WAYYRcVCkJtc6Vl/Mvhh@f9941","d6+w+ZcmdGHbs28VYN54Ca","3ai6Dl18BEKI16PFrVtwVz","eeDGsuerNOj5U031bn85AN","6bYizai9dB46NdQXtJ/sNM","642T96xrlJ75jl27YKirio@f9941","c7Z7IKHA9DLK0CSgzC5aOi@6c48a","56efGXV/JA0ZcxIUgHGGvx@6c48a","28a6MtRjBOtYb4bxJIyKAt@6c48a","d6opJhppVAQ51IhqBpB+xu@6c48a","9fJXFX6e1D0qisG+JIazuX@6c48a","dcZZW9y6RNeJ7hDZiTA59C@6c48a","e5BRIdU3RFnLdmJEd6vWUX@6c48a","e8dSrQxkRNZZzeluKqfcKJ@6c48a","b2loFr0c5B2bnc4JzDUecx","15rxsXZ+dGgafUj4ul1JLG@6c48a"],["node","_spriteFrame","targetInfo","_textureSource","root","data","_font","_normalSprite","asset","spriteFrame","_file","_effectAsset","mainTexture","_particleSystem","_mainTexture","target","source","_parent","_target","_hoverSprite","_pressedSprite","_disabledSprite","_mesh","value","tripleScoreNode","doubleScoreNode","rightJoystick","leftJoystick","ping","playerTankPrefab","_texture","_customMaterial","particle","woodExplodeSpriteFrame","rockExplodeSpriteFrame","playerBaseRockWallExplodeSpriteFrame","obstacle2","obstacle1","greenGrassSpreteFrame","yellowGrassSpreteFrame","riverSpreteFrame","multiple_score_item","MultiScoreRank","IceSmokeNode","reliveTimeDown","map","map_bullet_layer","map_tank_layer","mapContent","emojiBtnContent","soundBtn","Prop_Land","quan","skipBtn","closeBtn","rightFinger","leftFinger","readyGoLayer","score","nickName","indexSprite","warningBg","game_time_down_clock","game_time_down_blue_font","game_time_down_red_font","_userDefinedFont","bulletPrefab","propPrefab","tank_explode_prefab","base_explode_prefab","muzzle_flame_prefab","get_star_particle_prefab","get_other_particle_prefab","obsExplode","readyGoClip","upArrowSpriteFrame","downArrowSpriteFrame","soundOnSpriteFrame","soundOffSpriteFrame","gridPrefab","icon","star_icon","emoji","armo_label","shield_icon","aidLine","_skeletonData","normalTrackMaterial","outlinelTrackMaterial","blueAvatarBg","redAvatarBg","defaultSelfAvatar","defaultOtherAvatar"],[["cc.Node",["_name","_layer","_active","_objFlags","__editorExtras__","_prefab","_components","_parent","_children","_lpos","_lscale","_lrot","_euler"],-2,4,9,1,2,5,5,5,5],"cc.SpriteFrame",["cc.Widget",["_alignFlags","_left","_top","_originalWidth","_originalHeight","_right","_bottom","_horizontalCenter","_isAbsRight","_isAbsLeft","_isAbsTop","_verticalCenter","_alignMode","node","__prefab"],-10,1,4],["cc.Sprite",["_sizeMode","_enabled","_isTrimmedMode","_type","node","__prefab","_spriteFrame","_color","_customMaterial"],-1,1,4,6,5,6],["cc.ParticleSystem2D",["emissionRate","life","angleVar","startSize","startSizeVar","speed","speedVar","tangentialAccel","_custom","_totalParticles","duration","angle","lifeVar","_dstBlendFactor","endSize","startSpin","radialAccel","autoRemoveOnFinish","_srcBlendFactor","endSizeVar","startSpinVar","playOnLoad","endSpin","node","__prefab","_endColor","_file","_spriteFrame","gravity","_startColor","_startColorVar","_endColorVar","posVar"],-20,1,4,5,6,6,5,5,5,5,5],["cc.Label",["_actualFontSize","_string","_fontSize","_isSystemFontUsed","_lineHeight","_enableWrapText","_overflow","_isItalic","_horizontalAlign","_cacheMode","node","__prefab","_font","_color"],-7,1,4,6,5],["cc.Node",["_name","_layer","_objFlags","_active","_parent","_components","_prefab","_lpos","_children","_lscale"],-1,1,12,4,5,2,5],["cc.CurveRange",["mode","constantMin","constantMax","constant","multiplier","spline"],-2,4],["cc.Button",["_transition","_zoomScale","_enabled","node","__prefab","_normalSprite","clickEvents","_normalColor","_target","_hoverSprite","_pressedSprite","_disabledSprite"],0,1,4,6,9,5,1,6,6,6],["cc.ColorKey",["time","color"],2,5],["cc.Layout",["_layoutType","_spacingY","_resizeMode","_spacingX","_paddingTop","_paddingBottom","_affectedByScale","node","__prefab"],-4,1,4],["cc.UITransform",["node","__prefab","_contentSize","_anchorPoint"],3,1,4,5,5],["cc.PrefabInfo",["fileId","root","asset","nestedPrefabInstanceRoots","targetOverrides"],2,1,1,2,9],["cc.GradientRange",["_mode","color","gradient"],2,5,4],["cc.ParticleSystem",["duration","loop","node","__prefab","_materials","startColor","startSizeX","startSizeY","startSizeZ","startSpeed","startRotationX","startRotationY","startRotationZ","startDelay","startLifetime","gravityModifier","rateOverTime","rateOverDistance","bursts","_colorOverLifetimeModule","_shapeModule","_sizeOvertimeModule","_velocityOvertimeModule","_forceOvertimeModule","_limitVelocityOvertimeModule","_rotationOvertimeModule","_textureAnimationModule","_trailModule","renderer"],1,1,4,12,4,4,4,4,4,4,4,4,4,4,4,4,4,9,4,4,4,4,4,4,4,4,4,4],["cc.AlphaKey",["alpha","time"],1],["cc.Material",["_props","_defines","_states"],0],["cc.UIOpacity",["_opacity","node","__prefab"],2,1,4],["cc.BlockInputEvents",["_enabled","node","__prefab"],2,1,4],["cc.Mask",["_type","node","__prefab"],2,1,4],["cc.MeshRenderer",["_name","node","__prefab","_materials","lightmapSettings","_mesh"],2,1,4,3,4,6],["cc.LabelAtlas",["_name","fontSize","fntConfig"],0],["cc.Prefab",["_name"],2],["cc.Node",["_name","_layer","_parent","_components","_prefab","_lpos","_lrot","_lscale","_euler"],1,1,2,4,5,5,5,5],["cc.CompPrefabInfo",["fileId"],2],["cc.PrefabInfo",["fileId","root","instance","asset"],2,1,4,6],["cc.ParticleSystem",["duration","loop","node","__prefab","_materials","startColor","startSizeX","startSizeY","startSizeZ","startSpeed","startRotationX","startRotationY","startRotationZ","startDelay","startLifetime","gravityModifier","rateOverTime","rateOverDistance","bursts","_colorOverLifetimeModule","_shapeModule","_sizeOvertimeModule","_velocityOvertimeModule","_forceOvertimeModule","_limitVelocityOvertimeModule","_rotationOvertimeModule","_textureAnimationModule","_trailModule","renderer"],1,1,4,3,4,4,4,4,4,4,4,4,4,4,4,4,4,9,4,4,4,4,4,4,4,4,4,4],["cc.Burst",["repeatInterval","count"],2,4],["cc.ColorOvertimeModule",["_enable","color"],2,4],["cc.Gradient",["colorKeys","alphaKeys"],3,9,9],["cc.ShapeModule",["_enable","_shapeType","alignToDirection","arcSpeed","boxThickness","_scale"],0,4,5,5],["cc.SizeOvertimeModule",["_enable","size","x","y","z"],2,4,4,4,4],["cc.RealCurve",["_times","_values"],2,9],["cc.RealKeyframeValue",["interpolationMode","value"],1],["cc.VelocityOvertimeModule",["x","y","z","speedModifier"],3,4,4,4,4],["cc.ForceOvertimeModule",["x","y","z"],3,4,4,4],["cc.LimitVelocityOvertimeModule",["limitX","limitY","limitZ","limit"],3,4,4,4,4],["cc.RotationOvertimeModule",["x","y","z"],3,4,4,4],["cc.TextureAnimationModule",["_enable","_numTilesX","_numTilesY","cycleCount","frameOverTime","startFrame"],-1,4,4],["cc.TrailModule",["lifeTime","widthRatio","colorOverTrail","colorOvertime","_particleSystem"],3,4,4,4,4,1],["cc.ParticleSystemRenderer",["_mainTexture"],3,6],["cc.ParticleAsset",["_name","_native"],1],["cc.Mesh",["_native","_hash","_struct"],1,11],["cc.EffectAsset",["_name","shaders","techniques"],0],["cc.BitmapFont",["_name","fontSize","fntConfig"],0],["cc.Material",["_states","_defines","_props"],1,12],["cc.AudioClip",["_name","_native","_duration"],0],["37df7ifl7tAObsaI0f9zD3L",["node","__prefab","particle","woodExplodeSpriteFrame","rockExplodeSpriteFrame","playerBaseRockWallExplodeSpriteFrame"],3,1,4,1,6,6,6],["7dd08nluwJBaI+/KtRTcPlt",["node","wood_wall_spriteFrames","iron_wall_spriteFrames","base_wood_wall_spriteFrames","base_iron_wall_spriteFrames","base_wood_wall_crack_spriteFrames","base_iron_wall_crack_spriteFrames","white_wall_spriteFrames","obstacle1","obstacle2","greenGrassSpreteFrame","yellowGrassSpreteFrame","riverSpreteFrame"],3,1,3,3,3,3,3,3,3,1,1,6,6,6],["cc.TTFFont",["_name","_native"],1],["43ba6mDHJlCbafRKojFL64y",["node","__prefab","mapContent","map_tank_layer","map_bullet_layer","map","leftJoystick","rightJoystick","reliveTimeDown","IceSmokeNode","MultiScoreRank","multiple_score_item","doubleScoreNode","tripleScoreNode","playerTankPrefab","bulletPrefab","propPrefab","tank_explode_prefab","base_explode_prefab","muzzle_flame_prefab","get_star_particle_prefab","get_other_particle_prefab","obsExplode","readyGoClip","upArrowSpriteFrame","downArrowSpriteFrame"],3,1,4,1,1,1,1,1,1,1,1,1,1,1,1,6,6,6,6,6,6,6,6,6,6,6,6],["c673aDLeWxH65MtEgUt6vqS",["node","__prefab","soundBtn","emojiBtnContent","ping","soundOnSpriteFrame","soundOffSpriteFrame"],3,1,4,1,1,1,6,6],["cc.TargetOverrideInfo",["propertyPath","source","sourceInfo","target","targetInfo"],2,1,4,1,4],["cc.TargetInfo",["localID"],2],["cc.PrefabInstance",["fileId","prefabRootNode","propertyOverrides"],2,1,9],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,1],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,8],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,4],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,6],["23364oJA25BaJZeFx0fKnWG",["node","__prefab","readyGoLayer","leftJoystick","rightJoystick","leftFinger","rightFinger","closeBtn","skipBtn","emojiContent","scoreRank","ping","quan","Prop_Land","playerTankPrefab"],3,1,4,1,1,1,1,1,1,1,1,1,1,1,1,6],["cc.ClickEvent",["_componentId","handler","target"],1,1],["16c671pJiZIBa8cyGXHrrqF",["node","__prefab","indexSpArr","indexSprite","nickName","score"],3,1,4,3,1,1,1],["d00dam150pB+otUZqtp3jnE",["node","__prefab","game_time_down_clock","warningBg","game_time_down_blue_font","game_time_down_red_font"],3,1,4,1,1,6,6],["cc.RichText",["_lineHeight","_string","_horizontalAlign","_verticalAlign","_fontSize","_isSystemFontUsed","node","__prefab","_font","_userDefinedFont"],-3,1,4,6,6],["cc.LabelOutline",["_width","node","__prefab"],2,1,4],["cc.Graphics",["_lineWidth","_miterLimit","node","__prefab","_strokeColor","_fillColor"],1,1,4,5,5],["65ad5xbdNpAe7EIHbRFJATl",["joystickType","radius","node","__prefab","dot","ring","tip_ring","arrow"],1,1,4,1,1,1,1],["602634B6nRHAYIUdLGLtAVf",["joystickType","radius","innerSize","node","__prefab","dot","ring","tip_ring"],0,1,4,1,1,1],["e8b8eyvaHpLy6paCGpeZ0D2",["node","__prefab","content","riverLayer","tank_layer","under_tank_layer","upside_tank_layer","groundLayer","bg1Sprite","bg2Sprite","bg3Sprite","beijSprite","stan"],3,1,4,1,1,1,1,1,1,1,1,1,1,1],["c9b8aCrPGNIEKfSF4QQ+Hde",["_actualFontSize","_fontSize","_lineHeight","_isSystemFontUsed","fixedValue","node","__prefab","_color"],-2,1,4,5],["cc.DirectionalLight",["node","__prefab","_staticSettings"],3,1,4,4],["cc.StaticLightSettings",[],3],["61005aUhVFKM6bgjLgmFlYL",["node","__prefab"],3,1,4],["df3b50+/mVJlJiVcgX8xNzL",["node","__prefab","icon"],3,1,4,1],["ecd4cvEC99AlJlPfE0FRrts",["node","__prefab","aidLine","shield_icon","armo_label","tank_materials","tank_toon_materials","emojiSpriteFrameArr","emoji","star_icon","doubleScoreNode","tripleScoreNode","normalTrackMaterial","outlinelTrackMaterial","blueAvatarBg","redAvatarBg","defaultSelfAvatar","defaultOtherAvatar"],3,1,4,1,1,1,3,3,3,1,1,1,1,6,6,6,6,6,6],["ba732oyS/tDm4lYjucpVfd3",["fixedValue","node","__prefab"],2,1,4],["cc.ModelLightmapSettings",[],3],["cc.UIMeshRenderer",["node","__prefab"],3,1,4],["cc.MotionStreak",["_fadeTime","_stroke","node","__prefab","_color","_texture"],1,1,4,5,6],["sp.Skeleton",["_preCacheMode","defaultSkin","defaultAnimation","node","__prefab","_skeletonData"],0,1,4,6],["sp.SkeletonData",["_name","_atlasText","textureNames","_skeletonJson","textures"],-1,3]],[[24,0,2],[12,0,1,2,2],[11,0,1,2,1],[7,1],[0,0,1,7,6,5,9,3],[3,4,5,1],[3,4,5,6,1],[56,0,1,2,2],[11,0,1,2,3,1],[53,0,2],[55,0,1,2,3],[0,0,1,7,6,5,3],[7,3,2],[0,0,1,7,8,6,5,9,3],[11,0,1,1],[3,0,4,5,6,2],[22,0,2],[15,0,1,3],[17,1,2,1],[0,3,4,7,5,3],[0,0,1,7,6,5,9,10,3],[25,0,1,2,3,2],[54,0,1,2,2],[0,0,1,7,8,6,5,3],[6,0,1,4,5,6,7,3],[2,0,3,4,13,14,4],[2,0,1,13,14,3],[41,0,1,3],[13,1],[7,0,1,2,4],[33,0,1,3],[17,0,1,2,2],[3,3,0,4,5,6,3],[0,0,1,8,6,5,3],[0,0,2,1,7,6,5,4],[0,0,2,1,7,8,6,5,4],[45,0,1,2,3],[57,0,1,2,3],[60,0,1,2,3],[0,0,1,6,5,3],[23,0,1,2,3,4,5,6,7,8,3],[13,1,1],[13,0,2,2],[7,0,2,3],[7,0,4,5,3],[7,0,1,3],[27,0,1,2],[28,0,1,2],[29,0,1,1],[15,1],[30,0,1,2,3,4,5,4],[31,0,1,2,3,4,2],[32,0,1,2],[34,0,1,2,3,1],[35,0,1,2,1],[36,0,1,2,3,1],[37,0,1,2,1],[38,0,1,2,3,4,5,5],[39,0,1,2,3,4,1],[40,0,1],[3,0,2,4,5,6,3],[3,0,4,5,7,6,2],[3,1,0,4,5,6,3],[52,0,1,2,3,4,2],[8,0,1,3,4,5,3],[21,0,1,2,4],[0,0,1,7,8,6,5,9,11,12,3],[0,0,1,7,8,6,5,9,10,3],[2,0,1,2,13,14,4],[9,1],[9,0,2],[43,0,1,2,4],[58,0,1,2,2],[5,1,0,2,4,3,10,11,12,6],[76,1],[0,0,1,8,6,5,9,3],[0,0,2,1,7,8,6,5,9,4],[0,0,2,1,7,6,5,9,4],[0,0,1,7,6,5,9,11,12,3],[0,0,3,1,7,6,5,4],[0,0,1,8,5,11,12,3],[0,0,1,7,6,5,11,12,3],[0,0,1,7,6,5,10,3],[6,0,2,1,4,8,5,6,7,4],[2,0,5,13,14,3],[2,0,2,13,14,3],[2,0,1,5,2,13,14,5],[2,0,1,5,2,3,13,14,6],[14,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,3],[4,13,10,0,1,12,11,2,3,4,14,5,6,7,8,9,23,24,28,29,25,26,27,16],[3,4,5,7,6,1],[3,2,4,5,6,2],[3,0,4,5,8,6,2],[49,0,1,3],[8,0,3,4,6,5,2],[8,0,3,4,6,7,8,5,9,10,11,2],[18,1,2,1],[5,1,0,6,5,10,11,13,5],[5,1,0,2,4,3,10,11,13,6],[19,1,2,1],[64,0,1,2,2],[20,1,2,3,4,5,1],[77,0,1,1],[78,0,1,2,3,4,5,3],[0,0,3,1,7,8,6,5,4],[0,0,3,7,6,5,3],[0,0,1,6,5,10,3],[0,0,1,8,6,5,9,10,3],[0,0,1,7,8,6,5,9,11,10,12,3],[0,0,2,1,7,8,6,5,9,10,4],[0,0,2,1,7,6,5,11,10,12,4],[0,0,1,7,8,5,9,11,12,3],[0,0,1,7,6,5,9,11,10,12,3],[6,0,1,4,5,6,3],[6,0,1,4,8,5,6,7,3],[6,0,3,1,4,5,6,7,9,4],[6,0,1,4,5,6,7,9,3],[2,0,2,6,13,14,4],[2,0,7,13,14,3],[2,0,1,7,13,14,4],[2,1,13,14,2],[2,0,5,8,3,4,13,14,6],[2,0,1,9,8,3,4,13,14,7],[2,0,10,3,4,13,14,5],[2,0,1,5,2,6,4,13,14,7],[2,0,1,5,3,4,13,14,6],[2,0,13,14,2],[2,0,1,5,2,7,3,13,14,7],[2,0,1,6,7,13,14,5],[2,0,2,6,4,13,14,5],[2,0,2,11,13,14,4],[2,0,6,12,13,14,4],[12,0,1,2,4,3,2],[12,0,1,2,3,2],[14,0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2],[26,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,3],[9,1,1],[9,0,1,2],[42,0,1,2,3],[4,10,0,1,12,11,2,3,4,14,5,6,7,8,9,23,24,32,25,26,27,15],[4,10,0,1,12,11,2,3,4,19,20,5,6,7,16,17,8,9,23,24,28,30,25,31,18],[4,18,10,0,1,12,11,2,3,4,15,5,6,7,17,8,9,23,24,28,25,26,27,17],[4,13,0,1,11,2,3,4,14,5,6,7,21,8,9,23,24,32,29,30,25,31,26,27,15],[4,10,0,1,12,11,2,3,4,14,5,6,7,8,9,23,24,29,25,26,27,15],[4,18,13,10,0,1,12,11,2,3,4,15,5,6,7,8,9,23,24,30,25,31,26,17],[4,13,10,0,1,2,3,4,15,22,5,6,7,16,8,9,23,24,28,29,30,25,26,16],[44,0,1,2,4],[16,0,2,1,4],[16,0,1,3],[46,0,1,2,4],[47,0,1,2,3,4,5,1],[48,0,1,2,3,4,5,6,7,8,9,10,11,12,1],[3,1,0,4,5,7,6,3],[3,0,4,5,2],[3,4,1],[50,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,1],[51,0,1,2,3,4,5,6,1],[10,0,3,1,7,8,4],[10,2,0,4,5,1,7,8,6],[10,2,0,1,7,8,4],[10,2,0,3,6,7,8,5],[8,2,3,4,5,2],[8,0,1,3,4,6,7,8,5,9,10,11,3],[59,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,1],[18,0,1,2,2],[61,0,1,2,3,4,5,1],[62,0,1,2,3,4,5,1],[5,0,10,11,2],[5,1,0,2,4,3,10,11,13,12,6],[5,1,0,2,4,6,5,3,10,11,12,8],[5,1,0,2,3,7,10,11,6],[5,1,8,0,2,4,5,3,9,10,11,13,12,9],[19,0,1,2,2],[63,0,1,2,3,4,5,6,7,8,9,7],[65,0,1,2,3,4,5,3],[66,0,1,2,3,4,5,6,7,3],[67,0,1,2,3,4,5,6,7,4],[68,0,1,2,3,4,5,6,7,8,9,10,11,12,1],[69,0,1,2,3,4,5,6,7,6],[70,0,1,2,1],[71,1],[72,0,1,1],[73,0,1,2,1],[74,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,1],[75,0,1,2,2],[20,0,1,2,3,4,5,2],[79,0,1,2,3,4,5,4],[80,0,1,2,3,4,5]],[[[{"name":"singleColor","rect":{"x":0,"y":0,"width":2,"height":2},"offset":{"x":0,"y":0},"originalSize":{"width":2,"height":2},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[1],0,[0],[3],[10]],[[[65,"game_time_down_red_font",33.44,{"commonHeight":38,"fontSize":33,"atlasName":"game_time_down_red_sp","fontDefDictionary":{"48":{"xOffset":0,"yOffset":0,"xAdvance":23,"rect":{"x":0,"y":0,"width":23,"height":38}},"49":{"xOffset":0,"yOffset":0,"xAdvance":23,"rect":{"x":23,"y":0,"width":23,"height":38}},"50":{"xOffset":0,"yOffset":0,"xAdvance":23,"rect":{"x":46,"y":0,"width":23,"height":38}},"51":{"xOffset":0,"yOffset":0,"xAdvance":23,"rect":{"x":69,"y":0,"width":23,"height":38}},"52":{"xOffset":0,"yOffset":0,"xAdvance":23,"rect":{"x":92,"y":0,"width":23,"height":38}},"53":{"xOffset":0,"yOffset":0,"xAdvance":23,"rect":{"x":115,"y":0,"width":23,"height":38}},"54":{"xOffset":0,"yOffset":0,"xAdvance":23,"rect":{"x":138,"y":0,"width":23,"height":38}},"55":{"xOffset":0,"yOffset":0,"xAdvance":23,"rect":{"x":161,"y":0,"width":23,"height":38}},"56":{"xOffset":0,"yOffset":0,"xAdvance":23,"rect":{"x":184,"y":0,"width":23,"height":38}},"57":{"xOffset":0,"yOffset":0,"xAdvance":23,"rect":{"x":207,"y":0,"width":23,"height":38}}},"kerningDict":{}}]],0,0,[0],[9],[52]],[[{"name":"skipBtnBg","rect":{"x":0,"y":0,"width":157,"height":81},"offset":{"x":0,"y":0},"originalSize":{"width":157,"height":81},"rotated":false,"capInsets":[69,35,56,42],"packable":true}],[1],0,[0],[3],[53]],[[{"name":"resurrection_countdown_sprite","rect":{"x":2,"y":4,"width":100,"height":1352},"offset":{"x":0,"y":0},"originalSize":{"width":104,"height":1360},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[1],0,[0],[3],[54]],[[[16,"IceSmoke"],[33,"IceSmoke",33554432,[-4,-5,-6,-7],[[2,-2,[0,"ccA+CacNRBirvtTgHbjTx6"],[5,2160,1080]],[25,45,100,100,-3,[0,"b6RUIsckdLQpWVVYr34Enx"]]],[1,"a7VfsM1EtIErcrLNDR9BwQ",-1,0]],[13,"Ice",8388608,1,[-10],[[14,-8,[0,"38NB9mx2hFK6QSVSDDLCzV"]],[26,8,-100,-9,[0,"93VOVKJaZJEaMrNA3YPPm0"]]],[1,"4bkUIarJlE9axVzkBYQrnH",1,0],[1,-1130,0,0]],[13,"Ice-001",33554432,1,[-13],[[14,-11,[0,"1eTPjWhl9F86e3pnAL/Fe9"]],[84,32,-100,-12,[0,"21MhwHN2lLna1zQPQFnn1d"]]],[1,"66WFhxfJJF3K7rck/0maW1",1,0],[1,1130,0,0]],[66,"Ice-002",33554432,1,[-16],[[14,-14,[0,"d1lxaBbqxDP6+n13JgkI83"]],[85,17,-120,-15,[0,"edPs77qQpKnZ1WLj9SUpwu"]]],[1,"92epLLHlFP+7KJW0Ac2s8D",1,0],[1,0,610,0],[3,0,0,0.7071067811865475,0.7071067811865476],[1,0,0,90]],[66,"Ice-003",33554432,1,[-19],[[14,-17,[0,"0a5eFDmpNNs6HRNuftJ/xX"]],[117,20,-100,-120,-18,[0,"1a4KiHh79NeYVCEfLr7z1a"]]],[1,"efYoglfu1B+63jcsGuqT7J",1,0],[1,0,-610,0],[3,0,0,0.7071067811865475,0.7071067811865476],[1,0,0,90]],[40,"Somke",8388608,2,[-20],[1,"06qX13C2tHn7+XFnKuOW6K",1,0],[1,0,0.659,0],[3,0.7071067811865475,0,0,0.7071067811865476],[1,300,300,300],[1,90,0,0]],[134,30,6,[0,"1bbT5FXpFMfJpUcck/eJ2+"],[[0,null],6,0],[41,[4,3036676095]],[29,3,0.8,1.2],[3],[3],[43,3,-0.2],[3],[3],[3],[3],[29,3,5,2.7],[3],[12,50],[3],[[46,0.01,[12,40]]],[47,true,[42,1,[48,[[69],[70,1]],[[49],[17,255,0.1450892857142857],[17,255,0.7299107142857143],[17,0,1]]]]],[50,true,0,true,[12,1],[1,10,0,0],[1,0.1,6,6]],[51,true,[44,1,1.4,[52,[0,1],[[30,2,1],[30,2,1]]]],[3],[3],[3]],[53,[3],[3],[3],[12,1]],[54,[3],[3],[3]],[55,[3],[3],[3],[3]],[56,[3],[3],[3]],[57,true,4,4,1,[45,3,15],[3]],[58,[12,1],[3],[28],[28],-21],[59,1]],[40,"Somke",8388608,3,[-22],[1,"3etzAWFatEIaJPMDCPnmp4",1,0],[1,0,0.659,0],[3,0.7071067811865475,0,0,0.7071067811865476],[1,300,300,300],[1,90,0,0]],[135,30,false,8,[0,"cciZlh/shKt7T+VcHngUXH"],[2],[41,[4,3036676095]],[29,3,0.8,1.2],[3],[3],[43,3,0.2],[3],[3],[12,3.141592653589793],[3],[29,3,5,2.7],[3],[12,100],[3],[[46,0.01,[12,40]]],[47,true,[42,1,[48,[[136,[4,33554431]],[137,1,[4,33554431]]],[[49],[17,255,0.1450892857142857],[17,255,0.7299107142857143],[17,0,1]]]]],[50,true,0,true,[12,1],[1,10,0,0],[1,0.1,6,6]],[51,true,[44,1,1.4,[52,[0,1],[[30,2,1],[30,2,1]]]],[3],[3],[3]],[53,[3],[3],[3],[12,1]],[54,[3],[3],[3]],[55,[3],[3],[3],[3]],[56,[3],[3],[3]],[57,true,4,4,1,[45,3,15],[3]],[58,[12,1],[3],[28],[28],-23],[59,3]],[40,"Somke",8388608,4,[-24],[1,"23z9EPW5dHpoPvpPe9g8Pf",1,0],[1,0,0.659,0],[3,0.7071067811865475,0,0,0.7071067811865476],[1,300,300,400],[1,90,0,0]],[88,30,false,10,[0,"02iAH9OJRHnaRs0DgUX1Xq"],[[4,null],6,0],[41,[4,2617245695]],[29,3,0.8,1.2],[3],[3],[43,3,0.2],[3],[3],[12,3.141592653589793],[3],[29,3,5,2.7],[3],[12,50],[3],[[46,0.01,[12,40]]],[47,true,[42,1,[48,[[69],[70,1]],[[49],[17,255,0.1450892857142857],[17,255,0.7299107142857143],[17,0,1]]]]],[50,true,0,true,[12,1],[1,10,0,0],[1,0.1,6,6]],[51,true,[44,1,1.4,[52,[0,1],[[30,2,1],[30,2,1]]]],[3],[3],[3]],[53,[3],[3],[3],[12,1]],[54,[3],[3],[3]],[55,[3],[3],[3],[3]],[56,[3],[3],[3]],[57,true,4,4,1,[45,3,15],[3]],[58,[12,1],[3],[28],[28],-25],[59,5]],[40,"Somke",8388608,5,[-26],[1,"34RX1gOdZNTYJM/CaIxiAr",1,0],[1,0,0.659,0],[3,0.7071067811865475,0,0,0.7071067811865476],[1,300,300,400],[1,90,0,0]],[88,30,false,12,[0,"980Q9M9ABGEoO/XCAtC7eB"],[[6,null],6,0],[41,[4,2617245695]],[29,3,0.8,1.2],[3],[3],[43,3,-0.2],[3],[3],[12,3.141592653589793],[3],[29,3,5,2.7],[3],[12,50],[3],[[46,0.01,[12,40]]],[47,true,[42,1,[48,[[69],[70,1]],[[49],[17,255,0.1450892857142857],[17,255,0.7299107142857143],[17,0,1]]]]],[50,true,0,true,[12,1],[1,10,0,0],[1,0.1,6,6]],[51,true,[44,1,1.4,[52,[0,1],[[30,2,1],[30,2,1]]]],[3],[3],[3]],[53,[3],[3],[3],[12,1]],[54,[3],[3],[3]],[55,[3],[3],[3],[3]],[56,[3],[3],[3]],[57,true,4,4,1,[45,3,15],[3]],[58,[12,1],[3],[28],[28],-27],[59,7]]],0,[0,4,1,0,0,1,0,0,1,0,-1,2,0,-2,3,0,-3,4,0,-4,5,0,0,2,0,0,2,0,-1,6,0,0,3,0,0,3,0,-1,8,0,0,4,0,0,4,0,-1,10,0,0,5,0,0,5,0,-1,12,0,-1,7,0,13,7,0,-1,9,0,13,9,0,-1,11,0,13,11,0,-1,13,0,13,13,0,5,1,27],[0,0,0,0,0,0,0,0],[-1,14,-1,14,-1,14,-1,14],[5,2,5,2,5,2,5,2]],[[[27,"bullet",".plist"],-1],0,0,[0],[9],[19]],[[{"name":"tank_explode2_sprite_frame","rect":{"x":0,"y":0,"width":57,"height":57},"offset":{"x":0,"y":0},"originalSize":{"width":57,"height":57},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[1],0,[0],[3],[55]],[[[138,".bin",2864929873,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":73976,"length":24576,"count":6144,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":73976,"count":1321,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.5,-1,-0.5],"maxPosition",8,[1,0.5,1,0.5]]],-1],0,0,[],[],[]],[[[71,"SimpleToon",[{"hash":2285632444,"name":"SimpleToon|outline-vs:vert|outline-fs:frag","blocks":[{"name":"OutlineVert","stageFlags":1,"binding":0,"members":[{"name":"outlineParams","type":16,"count":1}],"defines":[]},{"name":"OutlineFrag","stageFlags":16,"binding":1,"members":[{"name":"baseColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"baseColorMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_BASE_COLOR_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_vertexId","format":11,"location":13,"defines":["CC_USE_MORPH"]}],"varyings":[{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    layout(location = 6) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(location = 7) in vec4 a_matWorld0;\n  layout(location = 8) in vec4 a_matWorld1;\n  layout(location = 9) in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    layout(location = 10) in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    layout(location = 11) in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n#endif\n#if CC_USE_MORPH\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(set = 2, binding = 0) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(set = 2, binding = 0) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n}\nlayout(location = 0) out vec2 v_uv;\nlayout(set = 1, binding = 0) uniform OutlineVert {\n  vec4 outlineParams;\n};\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld;\n  CCGetWorldMatrix(matWorld);\n  float width = outlineParams.x * 0.001;\n  #if USE_POSITION_SCALING\n    vec3 dir = normalize(In.position.xyz);\n    float flip = dot(dir, normalize(In.normal)) < 0.0 ? -1.0 : 1.0;\n    In.position.xyz += flip * dir * width * 2.0;\n    vec4 pos = cc_matProj * (cc_matView * matWorld) * In.position;\n  #else\n    In.position.xyz += normalize(In.normal) * width;\n    vec4 pos = cc_matProj * (cc_matView * matWorld) * In.position;\n  #endif\n  pos.z -= outlineParams.y * 0.002;\n  v_uv = a_texCoord;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nlayout(location = 0) in vec2 v_uv;\nlayout(set = 1, binding = 1) uniform OutlineFrag {\n  vec4 baseColor;\n};\n#if USE_BASE_COLOR_MAP\n  layout(set = 1, binding = 2) uniform sampler2D baseColorMap;\n#endif\nvec4 frag () {\n  vec4 color = baseColor * cc_mainLitColor;\n  #if USE_BASE_COLOR_MAP\n    vec4 texColor = texture(baseColorMap, v_uv);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    color *= texColor;\n  #endif\n  return CCFragOutput(vec4(color.rgb, 1.0));\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(std140) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n}\nout vec2 v_uv;\nlayout(std140) uniform OutlineVert {\n  vec4 outlineParams;\n};\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld;\n  CCGetWorldMatrix(matWorld);\n  float width = outlineParams.x * 0.001;\n  #if USE_POSITION_SCALING\n    vec3 dir = normalize(In.position.xyz);\n    float flip = dot(dir, normalize(In.normal)) < 0.0 ? -1.0 : 1.0;\n    In.position.xyz += flip * dir * width * 2.0;\n    vec4 pos = cc_matProj * (cc_matView * matWorld) * In.position;\n  #else\n    In.position.xyz += normalize(In.normal) * width;\n    vec4 pos = cc_matProj * (cc_matView * matWorld) * In.position;\n  #endif\n  pos.z -= outlineParams.y * 0.002;\n  v_uv = a_texCoord;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nin vec2 v_uv;\nlayout(std140) uniform OutlineFrag {\n  vec4 baseColor;\n};\n#if USE_BASE_COLOR_MAP\n  uniform sampler2D baseColorMap;\n#endif\nvec4 frag () {\n  vec4 color = baseColor * cc_mainLitColor;\n  #if USE_BASE_COLOR_MAP\n    vec4 texColor = texture(baseColorMap, v_uv);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    color *= texColor;\n  #endif\n  return CCFragOutput(vec4(color.rgb, 1.0));\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    uniform highp mat4 cc_matWorlds[10];\n  #else\n    uniform highp mat4 cc_matWorld;\n  #endif\n#endif\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n}\nvarying vec2 v_uv;\n   uniform vec4 outlineParams;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld;\n  CCGetWorldMatrix(matWorld);\n  float width = outlineParams.x * 0.001;\n  #if USE_POSITION_SCALING\n    vec3 dir = normalize(In.position.xyz);\n    float flip = dot(dir, normalize(In.normal)) < 0.0 ? -1.0 : 1.0;\n    In.position.xyz += flip * dir * width * 2.0;\n    vec4 pos = cc_matProj * (cc_matView * matWorld) * In.position;\n  #else\n    In.position.xyz += normalize(In.normal) * width;\n    vec4 pos = cc_matProj * (cc_matView * matWorld) * In.position;\n  #endif\n  pos.z -= outlineParams.y * 0.002;\n  v_uv = a_texCoord;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nuniform mediump vec4 cc_mainLitColor;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nvarying vec2 v_uv;\n   uniform vec4 baseColor;\n#if USE_BASE_COLOR_MAP\n  uniform sampler2D baseColorMap;\n#endif\nvec4 frag () {\n  vec4 color = baseColor * cc_mainLitColor;\n  #if USE_BASE_COLOR_MAP\n    vec4 texColor = texture2D(baseColorMap, v_uv);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    color *= texColor;\n  #endif\n  return CCFragOutput(vec4(color.rgb, 1.0));\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":198,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":40}},"defines":[{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"USE_POSITION_SCALING","type":"boolean","defines":[]},{"name":"USE_BASE_COLOR_MAP","type":"boolean","defines":[]}]},{"hash":2281101054,"name":"SimpleToon|toon-vs:vert|toon-fs:frag","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"grayColor","type":16,"count":1},{"name":"tilingOffset","type":16,"count":1},{"name":"mainColor","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"rimColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"baseColorMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_BASE_COLOR_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_vertexId","format":11,"location":13,"defines":["CC_USE_MORPH"]}],"varyings":[{"name":"v_position","type":15,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":1,"defines":[]},{"name":"v_normal","type":15,"count":1,"stageFlags":17,"location":2,"defines":[]},{"name":"v_view_normal","type":15,"count":1,"stageFlags":17,"location":3,"defines":["USE_RIM_LIGHT"]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    layout(location = 6) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(location = 7) in vec4 a_matWorld0;\n  layout(location = 8) in vec4 a_matWorld1;\n  layout(location = 9) in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    layout(location = 10) in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    layout(location = 11) in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n#endif\n#if CC_USE_MORPH\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(set = 2, binding = 0) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(set = 2, binding = 0) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 grayColor;\n  vec4 tilingOffset;\n  vec4 mainColor;\n  vec4 emissive;\n  vec4 rimColor;\n};\nlayout(location = 0) out vec3 v_position;\nlayout(location = 1) out vec2 v_uv;\nlayout(location = 2) out vec3 v_normal;\n#if USE_RIM_LIGHT\n    layout(location = 3) out vec3 v_view_normal;\n#endif\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  vec4 normal = vec4(In.normal,0.0);\n  v_normal = (matWorldIT * normal).xyz;\n  #if USE_RIM_LIGHT\n      v_view_normal = normalize(((cc_matView * matWorldIT) * normal).xyz);\n  #endif\n  return cc_matProj * (cc_matView * matWorld) * In.position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 grayColor;\n  vec4 tilingOffset;\n  vec4 mainColor;\n  vec4 emissive;\n  vec4 rimColor;\n};\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nlayout(location = 0) in vec3 v_position;\nlayout(location = 1) in vec2 v_uv;\n#if USE_RIM_LIGHT\n    layout(location = 3) in vec3 v_view_normal;\n#endif\n#if USE_BASE_COLOR_MAP\n  layout(set = 1, binding = 1) uniform sampler2D baseColorMap;\n#endif\nlayout(location = 2) in vec3 v_normal;\nvec4 frag () {\n  vec4 color = mainColor;\n  #if USE_BASE_COLOR_MAP\n    vec4 baseColorMap = texture(baseColorMap, v_uv);\n    baseColorMap.rgb = SRGBToLinear(baseColorMap.rgb);\n    color *= baseColorMap;\n  #endif\n  #if USE_EMISSIVE\n  color.rgb += emissive.rgb;\n  #endif\n  #if USE_GRAYCOLOR\n     if (grayColor.w > 0.0) {\n        float gray  = grayColor.r * color.r + grayColor.g * color.g + grayColor.b * color.b;\n        color.r = color.g = color.b = gray;\n     }\n  #endif\n  #if USE_RIM_LIGHT\n      float fRim = (1.0 - dot(v_view_normal,vec3(0,0,1.0))) * rimColor.w;\n      color.rgb = mix(color.rgb,rimColor.rgb,fRim);\n  #endif\n  return CCFragOutput(color);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(std140) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4 grayColor;\n  vec4 tilingOffset;\n  vec4 mainColor;\n  vec4 emissive;\n  vec4 rimColor;\n};\nout vec3 v_position;\nout vec2 v_uv;\nout vec3 v_normal;\n#if USE_RIM_LIGHT\n    out vec3 v_view_normal;\n#endif\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  vec4 normal = vec4(In.normal,0.0);\n  v_normal = (matWorldIT * normal).xyz;\n  #if USE_RIM_LIGHT\n      v_view_normal = normalize(((cc_matView * matWorldIT) * normal).xyz);\n  #endif\n  return cc_matProj * (cc_matView * matWorld) * In.position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform Constants {\n  vec4 grayColor;\n  vec4 tilingOffset;\n  vec4 mainColor;\n  vec4 emissive;\n  vec4 rimColor;\n};\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nin vec3 v_position;\nin vec2 v_uv;\n#if USE_RIM_LIGHT\n    in vec3 v_view_normal;\n#endif\n#if USE_BASE_COLOR_MAP\n  uniform sampler2D baseColorMap;\n#endif\nin vec3 v_normal;\nvec4 frag () {\n  vec4 color = mainColor;\n  #if USE_BASE_COLOR_MAP\n    vec4 baseColorMap = texture(baseColorMap, v_uv);\n    baseColorMap.rgb = SRGBToLinear(baseColorMap.rgb);\n    color *= baseColorMap;\n  #endif\n  #if USE_EMISSIVE\n  color.rgb += emissive.rgb;\n  #endif\n  #if USE_GRAYCOLOR\n     if (grayColor.w > 0.0) {\n        float gray  = grayColor.r * color.r + grayColor.g * color.g + grayColor.b * color.b;\n        color.r = color.g = color.b = gray;\n     }\n  #endif\n  #if USE_RIM_LIGHT\n      float fRim = (1.0 - dot(v_view_normal,vec3(0,0,1.0))) * rimColor.w;\n      color.rgb = mix(color.rgb,rimColor.rgb,fRim);\n  #endif\n  return CCFragOutput(color);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    uniform highp mat4 cc_matWorlds[10];\n  #else\n    uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 tilingOffset;\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvarying vec3 v_normal;\n#if USE_RIM_LIGHT\n    varying vec3 v_view_normal;\n#endif\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  vec4 normal = vec4(In.normal,0.0);\n  v_normal = (matWorldIT * normal).xyz;\n  #if USE_RIM_LIGHT\n      v_view_normal = normalize(((cc_matView * matWorldIT) * normal).xyz);\n  #endif\n  return cc_matProj * (cc_matView * matWorld) * In.position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nuniform vec4 grayColor;\n     uniform vec4 mainColor;\n     uniform vec4 emissive;\n     uniform vec4 rimColor;\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nvarying vec3 v_position;\nvarying vec2 v_uv;\n#if USE_RIM_LIGHT\n    varying vec3 v_view_normal;\n#endif\n#if USE_BASE_COLOR_MAP\n  uniform sampler2D baseColorMap;\n#endif\nvarying vec3 v_normal;\nvec4 frag () {\n  vec4 color = mainColor;\n  #if USE_BASE_COLOR_MAP\n    vec4 baseColorMap = texture2D(baseColorMap, v_uv);\n    baseColorMap.rgb = SRGBToLinear(baseColorMap.rgb);\n    color *= baseColorMap;\n  #endif\n  #if USE_EMISSIVE\n  color.rgb += emissive.rgb;\n  #endif\n  #if USE_GRAYCOLOR\n     if (grayColor.w > 0.0) {\n        float gray  = grayColor.r * color.r + grayColor.g * color.g + grayColor.b * color.b;\n        color.r = color.g = color.b = gray;\n     }\n  #endif\n  #if USE_RIM_LIGHT\n      float fRim = (1.0 - dot(v_view_normal,vec3(0,0,1.0))) * rimColor.w;\n      color.rgb = mix(color.rgb,rimColor.rgb,fRim);\n  #endif\n  return CCFragOutput(color);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":202,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":44}},"defines":[{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"USE_RIM_LIGHT","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]},{"name":"USE_BASE_COLOR_MAP","type":"boolean","defines":[]},{"name":"USE_EMISSIVE","type":"boolean","defines":[]},{"name":"USE_GRAYCOLOR","type":"boolean","defines":[]}]},{"hash":2757093832,"name":"SimpleToon|shadow-caster-vs:vert|shadow-caster-fs:frag","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"grayColor","type":16,"count":1},{"name":"tilingOffset","type":16,"count":1},{"name":"mainColor","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"rimColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"baseColorMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_BASE_COLOR_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_vertexId","format":11,"location":13,"defines":["CC_USE_MORPH"]}],"varyings":[{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"v_worldPos","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]},{"name":"v_clip_depth","type":13,"count":1,"stageFlags":17,"location":2,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    layout(location = 6) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(location = 7) in vec4 a_matWorld0;\n  layout(location = 8) in vec4 a_matWorld1;\n  layout(location = 9) in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    layout(location = 10) in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    layout(location = 11) in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n#endif\n#if CC_USE_MORPH\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(set = 2, binding = 0) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(set = 2, binding = 0) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 grayColor;\n  vec4 tilingOffset;\n  vec4 mainColor;\n  vec4 emissive;\n  vec4 rimColor;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nlayout(location = 0) out vec2 v_uv;\nlayout(location = 1) out vec4 v_worldPos;\nlayout(location = 2) out float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 grayColor;\n  vec4 tilingOffset;\n  vec4 mainColor;\n  vec4 emissive;\n  vec4 rimColor;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\nlayout(location = 0) in vec2 v_uv;\nlayout(location = 1) in vec4 v_worldPos;\nlayout(location = 2) in float v_clip_depth;\n#if USE_BASE_COLOR_MAP\n  layout(set = 1, binding = 1) uniform sampler2D baseColorMap;\n#endif\nvec4 frag () {\n  vec4 baseColor = mainColor;\n  #if USE_BASE_COLOR_MAP\n    baseColor *= texture(baseColorMap, v_uv);\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(std140) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4 grayColor;\n  vec4 tilingOffset;\n  vec4 mainColor;\n  vec4 emissive;\n  vec4 rimColor;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nout vec2 v_uv;\nout vec4 v_worldPos;\nout float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform Constants {\n  vec4 grayColor;\n  vec4 tilingOffset;\n  vec4 mainColor;\n  vec4 emissive;\n  vec4 rimColor;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\nin vec2 v_uv;\nin vec4 v_worldPos;\nin float v_clip_depth;\n#if USE_BASE_COLOR_MAP\n  uniform sampler2D baseColorMap;\n#endif\nvec4 frag () {\n  vec4 baseColor = mainColor;\n  #if USE_BASE_COLOR_MAP\n    baseColor *= texture(baseColorMap, v_uv);\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    uniform highp mat4 cc_matWorlds[10];\n  #else\n    uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 tilingOffset;\nuniform highp mat4 cc_matLightViewProj;\nvarying vec2 v_uv;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\n   uniform vec4 mainColor;\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nuniform highp mat4 cc_matLightView;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\nvarying vec2 v_uv;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\n#if USE_BASE_COLOR_MAP\n  uniform sampler2D baseColorMap;\n#endif\nvec4 frag () {\n  vec4 baseColor = mainColor;\n  #if USE_BASE_COLOR_MAP\n    baseColor *= texture2D(baseColorMap, v_uv);\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCShadow","defines":[]},{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":183,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":74}},"defines":[{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"USE_BASE_COLOR_MAP","type":"boolean","defines":[]}]}],[{"passes":[{"program":"SimpleToon|outline-vs:vert|outline-fs:frag","switch":"USE_OUTLINE_PASS","rasterizerState":{"cullMode":1},"depthStencilState":{"depthFunc":3,"depthTest":true,"depthWrite":true},"properties":{"lineWidth":{"type":13,"value":[10],"handleInfo":["outlineParams",0,13]},"depthBias":{"type":13,"value":[0],"handleInfo":["outlineParams",1,13]},"baseColor":{"type":16,"editor":{"type":"color"}},"baseColorMap":{"value":"grey","type":28},"outlineParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[10,0,0,0]}}},{"program":"SimpleToon|toon-vs:vert|toon-fs:frag","properties":{"mainTexture":{"value":"white","type":28,"editor":{"displayName":"BaseColorMap"},"handleInfo":["baseColorMap",0,28]},"grayColor":{"type":16,"value":[0.2126,0.7152,0.0722,0],"editor":{"parent":"USE_GRAYCOLOR","displayName":"gray Color","type":"color"}},"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[0.9,0.9,0.9,1],"editor":{"displayName":"main Color","type":"color","deprecated":true},"handleInfo":["mainColor",0,16]},"rimLightColor":{"type":16,"value":[1,1,1,0.5],"editor":{"parent":"USE_RIM_LIGHT","displayName":"rim Color","type":"color"},"handleInfo":["rimColor",0,16]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"parent":"USE_EMISSIVE","displayName":"emissive Color","type":"color"}},"baseColorMap":{"type":28,"value":"white","editor":{"visible":false,"deprecated":true}},"rimColor":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]}}},{"phase":"shadow-caster","propertyIndex":1,"program":"SimpleToon|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"mainTexture":{"value":"white","type":28,"editor":{"displayName":"BaseColorMap"},"handleInfo":["baseColorMap",0,28]},"grayColor":{"type":16,"value":[0.2126,0.7152,0.0722,0],"editor":{"parent":"USE_GRAYCOLOR","displayName":"gray Color","type":"color"}},"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[0.9,0.9,0.9,1],"editor":{"displayName":"main Color","type":"color","deprecated":true},"handleInfo":["mainColor",0,16]},"rimLightColor":{"type":16,"value":[1,1,1,0.5],"editor":{"parent":"USE_RIM_LIGHT","displayName":"rim Color","type":"color"},"handleInfo":["rimColor",0,16]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"parent":"USE_EMISSIVE","displayName":"emissive Color","type":"color"}},"baseColorMap":{"type":28,"value":"white","editor":{"visible":false,"deprecated":true}},"rimColor":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]}}}]}]]],0,0,[],[],[]],[[[16,"base_explode"],[39,"base_explode",33554432,[[14,-2,[0,"b9wUePBaFEBJzDODjgjy3X"]],[89,1,0.05,1500,0.3,0.1,104,180,110,10,-1,600,20,-700,true,800,-3,[0,"90TfLWdytGDpsZcBnwg2Lh"],[0,-20,55],[4,3795019519],[4,4278190080],0,1]],[1,"461W23F7BFRp4dEaR5pVXr",-1,0]]],0,[0,4,1,0,0,1,0,0,1,0,5,1,3],[0,0],[10,1],[56,20]],[[{"name":"myFont","rect":{"x":3,"y":2,"width":365,"height":476},"offset":{"x":0,"y":11.5},"originalSize":{"width":371,"height":503},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[1],0,[0],[3],[57]],[[[146,"arial_font",64,{"commonHeight":74,"fontSize":64,"atlasName":"myFont.png","fontDefDictionary":{"32":{"xOffset":0,"yOffset":61,"xAdvance":16,"rect":{"x":146,"y":460,"width":0,"height":0}},"33":{"xOffset":6,"yOffset":12,"xAdvance":21,"rect":{"x":177,"y":228,"width":12,"height":50}},"34":{"xOffset":4,"yOffset":12,"xAdvance":31,"rect":{"x":338,"y":421,"width":26,"height":19}},"35":{"xOffset":1,"yOffset":12,"xAdvance":35,"rect":{"x":43,"y":176,"width":37,"height":50}},"36":{"xOffset":2,"yOffset":6,"xAdvance":38,"rect":{"x":2,"y":2,"width":35,"height":67}},"37":{"xOffset":2,"yOffset":12,"xAdvance":55,"rect":{"x":2,"y":71,"width":54,"height":51}},"38":{"xOffset":4,"yOffset":12,"xAdvance":49,"rect":{"x":169,"y":71,"width":46,"height":50}},"39":{"xOffset":3,"yOffset":12,"xAdvance":15,"rect":{"x":2,"y":460,"width":12,"height":19}},"40":{"xOffset":4,"yOffset":11,"xAdvance":23,"rect":{"x":156,"y":2,"width":18,"height":63}},"41":{"xOffset":3,"yOffset":11,"xAdvance":23,"rect":{"x":176,"y":2,"width":18,"height":63}},"42":{"xOffset":1,"yOffset":10,"xAdvance":28,"rect":{"x":256,"y":421,"width":28,"height":27}},"43":{"xOffset":3,"yOffset":19,"xAdvance":37,"rect":{"x":184,"y":421,"width":35,"height":35}},"44":{"xOffset":5,"yOffset":50,"xAdvance":20,"rect":{"x":323,"y":421,"width":13,"height":21}},"45":{"xOffset":1,"yOffset":38,"xAdvance":21,"rect":{"x":85,"y":460,"width":22,"height":10}},"46":{"xOffset":5,"yOffset":50,"xAdvance":20,"rect":{"x":54,"y":460,"width":12,"height":12}},"47":{"xOffset":1,"yOffset":12,"xAdvance":18,"rect":{"x":135,"y":228,"width":19,"height":50}},"48":{"xOffset":3,"yOffset":13,"xAdvance":38,"rect":{"x":41,"y":280,"width":35,"height":49}},"49":{"xOffset":4,"yOffset":13,"xAdvance":38,"rect":{"x":102,"y":331,"width":25,"height":49}},"50":{"xOffset":4,"yOffset":12,"xAdvance":38,"rect":{"x":78,"y":280,"width":35,"height":49}},"51":{"xOffset":3,"yOffset":13,"xAdvance":38,"rect":{"x":115,"y":280,"width":35,"height":49}},"52":{"xOffset":1,"yOffset":12,"xAdvance":38,"rect":{"x":262,"y":124,"width":39,"height":50}},"53":{"xOffset":3,"yOffset":13,"xAdvance":38,"rect":{"x":152,"y":280,"width":35,"height":49}},"54":{"xOffset":3,"yOffset":13,"xAdvance":38,"rect":{"x":189,"y":280,"width":35,"height":49}},"55":{"xOffset":5,"yOffset":13,"xAdvance":38,"rect":{"x":2,"y":331,"width":34,"height":49}},"56":{"xOffset":3,"yOffset":13,"xAdvance":38,"rect":{"x":226,"y":280,"width":35,"height":49}},"57":{"xOffset":2,"yOffset":13,"xAdvance":38,"rect":{"x":263,"y":280,"width":35,"height":49}},"58":{"xOffset":5,"yOffset":25,"xAdvance":20,"rect":{"x":133,"y":421,"width":12,"height":37}},"59":{"xOffset":5,"yOffset":24,"xAdvance":20,"rect":{"x":301,"y":331,"width":13,"height":47}},"60":{"xOffset":3,"yOffset":19,"xAdvance":37,"rect":{"x":204,"y":382,"width":34,"height":37}},"61":{"xOffset":3,"yOffset":24,"xAdvance":37,"rect":{"x":286,"y":421,"width":35,"height":25}},"62":{"xOffset":3,"yOffset":19,"xAdvance":37,"rect":{"x":240,"y":382,"width":34,"height":37}},"63":{"xOffset":3,"yOffset":12,"xAdvance":37,"rect":{"x":309,"y":176,"width":34,"height":50}},"64":{"xOffset":2,"yOffset":12,"xAdvance":63,"rect":{"x":39,"y":2,"width":63,"height":63}},"65":{"xOffset":2,"yOffset":12,"xAdvance":46,"rect":{"x":265,"y":71,"width":45,"height":50}},"66":{"xOffset":5,"yOffset":13,"xAdvance":46,"rect":{"x":218,"y":331,"width":41,"height":48}},"67":{"xOffset":3,"yOffset":12,"xAdvance":47,"rect":{"x":312,"y":71,"width":43,"height":50}},"68":{"xOffset":5,"yOffset":13,"xAdvance":47,"rect":{"x":174,"y":331,"width":42,"height":48}},"69":{"xOffset":5,"yOffset":13,"xAdvance":43,"rect":{"x":261,"y":331,"width":38,"height":48}},"70":{"xOffset":5,"yOffset":13,"xAdvance":39,"rect":{"x":38,"y":331,"width":34,"height":49}},"71":{"xOffset":3,"yOffset":12,"xAdvance":51,"rect":{"x":217,"y":71,"width":46,"height":50}},"72":{"xOffset":5,"yOffset":12,"xAdvance":49,"rect":{"x":91,"y":124,"width":41,"height":50}},"73":{"xOffset":5,"yOffset":12,"xAdvance":20,"rect":{"x":191,"y":228,"width":12,"height":50}},"74":{"xOffset":1,"yOffset":12,"xAdvance":37,"rect":{"x":2,"y":228,"width":33,"height":50}},"75":{"xOffset":5,"yOffset":12,"xAdvance":47,"rect":{"x":47,"y":124,"width":42,"height":50}},"76":{"xOffset":5,"yOffset":12,"xAdvance":39,"rect":{"x":300,"y":280,"width":35,"height":49}},"77":{"xOffset":5,"yOffset":13,"xAdvance":53,"rect":{"x":231,"y":228,"width":47,"height":49}},"78":{"xOffset":5,"yOffset":12,"xAdvance":49,"rect":{"x":134,"y":124,"width":41,"height":50}},"79":{"xOffset":3,"yOffset":12,"xAdvance":51,"rect":{"x":120,"y":71,"width":47,"height":50}},"80":{"xOffset":5,"yOffset":13,"xAdvance":43,"rect":{"x":2,"y":280,"width":37,"height":49}},"81":{"xOffset":3,"yOffset":12,"xAdvance":51,"rect":{"x":273,"y":2,"width":50,"height":53}},"82":{"xOffset":5,"yOffset":13,"xAdvance":46,"rect":{"x":280,"y":228,"width":41,"height":49}},"83":{"xOffset":3,"yOffset":12,"xAdvance":43,"rect":{"x":303,"y":124,"width":39,"height":50}},"84":{"xOffset":1,"yOffset":13,"xAdvance":40,"rect":{"x":323,"y":228,"width":41,"height":49}},"85":{"xOffset":5,"yOffset":12,"xAdvance":49,"rect":{"x":177,"y":124,"width":41,"height":50}},"86":{"xOffset":2,"yOffset":12,"xAdvance":44,"rect":{"x":2,"y":124,"width":43,"height":50}},"87":{"xOffset":1,"yOffset":12,"xAdvance":60,"rect":{"x":58,"y":71,"width":60,"height":50}},"88":{"xOffset":1,"yOffset":12,"xAdvance":39,"rect":{"x":2,"y":176,"width":39,"height":50}},"89":{"xOffset":1,"yOffset":12,"xAdvance":40,"rect":{"x":220,"y":124,"width":40,"height":50}},"90":{"xOffset":0,"yOffset":13,"xAdvance":41,"rect":{"x":129,"y":331,"width":43,"height":48}},"91":{"xOffset":5,"yOffset":12,"xAdvance":23,"rect":{"x":229,"y":2,"width":20,"height":61}},"92":{"xOffset":1,"yOffset":12,"xAdvance":18,"rect":{"x":156,"y":228,"width":19,"height":50}},"93":{"xOffset":1,"yOffset":12,"xAdvance":23,"rect":{"x":251,"y":2,"width":20,"height":61}},"94":{"xOffset":4,"yOffset":12,"xAdvance":37,"rect":{"x":221,"y":421,"width":33,"height":27}},"95":{"xOffset":0,"yOffset":63,"xAdvance":32,"rect":{"x":109,"y":460,"width":35,"height":6}},"96":{"xOffset":3,"yOffset":13,"xAdvance":21,"rect":{"x":68,"y":460,"width":15,"height":11}},"97":{"xOffset":3,"yOffset":25,"xAdvance":38,"rect":{"x":93,"y":382,"width":35,"height":37}},"98":{"xOffset":4,"yOffset":12,"xAdvance":40,"rect":{"x":82,"y":176,"width":36,"height":50}},"99":{"xOffset":3,"yOffset":25,"xAdvance":38,"rect":{"x":130,"y":382,"width":35,"height":37}},"100":{"xOffset":2,"yOffset":12,"xAdvance":40,"rect":{"x":120,"y":176,"width":36,"height":50}},"101":{"xOffset":3,"yOffset":25,"xAdvance":38,"rect":{"x":167,"y":382,"width":35,"height":37}},"102":{"xOffset":-1,"yOffset":12,"xAdvance":21,"rect":{"x":106,"y":228,"width":27,"height":50}},"103":{"xOffset":3,"yOffset":24,"xAdvance":40,"rect":{"x":158,"y":176,"width":36,"height":50}},"104":{"xOffset":4,"yOffset":12,"xAdvance":39,"rect":{"x":37,"y":228,"width":33,"height":50}},"105":{"xOffset":4,"yOffset":12,"xAdvance":17,"rect":{"x":205,"y":228,"width":11,"height":50}},"106":{"xOffset":-5,"yOffset":12,"xAdvance":17,"rect":{"x":207,"y":2,"width":20,"height":62}},"107":{"xOffset":5,"yOffset":12,"xAdvance":37,"rect":{"x":72,"y":228,"width":32,"height":50}},"108":{"xOffset":4,"yOffset":12,"xAdvance":17,"rect":{"x":218,"y":228,"width":11,"height":50}},"109":{"xOffset":4,"yOffset":25,"xAdvance":57,"rect":{"x":2,"y":382,"width":51,"height":37}},"110":{"xOffset":4,"yOffset":25,"xAdvance":39,"rect":{"x":312,"y":382,"width":33,"height":37}},"111":{"xOffset":2,"yOffset":25,"xAdvance":39,"rect":{"x":55,"y":382,"width":36,"height":37}},"112":{"xOffset":4,"yOffset":24,"xAdvance":40,"rect":{"x":196,"y":176,"width":36,"height":50}},"113":{"xOffset":3,"yOffset":24,"xAdvance":40,"rect":{"x":234,"y":176,"width":36,"height":50}},"114":{"xOffset":4,"yOffset":25,"xAdvance":28,"rect":{"x":105,"y":421,"width":26,"height":37}},"115":{"xOffset":3,"yOffset":25,"xAdvance":35,"rect":{"x":37,"y":421,"width":32,"height":37}},"116":{"xOffset":1,"yOffset":13,"xAdvance":23,"rect":{"x":74,"y":331,"width":26,"height":49}},"117":{"xOffset":4,"yOffset":25,"xAdvance":39,"rect":{"x":2,"y":421,"width":33,"height":37}},"118":{"xOffset":2,"yOffset":25,"xAdvance":35,"rect":{"x":276,"y":382,"width":34,"height":37}},"119":{"xOffset":1,"yOffset":25,"xAdvance":52,"rect":{"x":316,"y":331,"width":52,"height":37}},"120":{"xOffset":2,"yOffset":25,"xAdvance":33,"rect":{"x":71,"y":421,"width":32,"height":37}},"121":{"xOffset":1,"yOffset":24,"xAdvance":35,"rect":{"x":272,"y":176,"width":35,"height":50}},"122":{"xOffset":1,"yOffset":25,"xAdvance":33,"rect":{"x":147,"y":421,"width":35,"height":36}},"123":{"xOffset":2,"yOffset":11,"xAdvance":25,"rect":{"x":104,"y":2,"width":24,"height":63}},"124":{"xOffset":6,"yOffset":11,"xAdvance":18,"rect":{"x":196,"y":2,"width":9,"height":63}},"125":{"xOffset":1,"yOffset":11,"xAdvance":25,"rect":{"x":130,"y":2,"width":24,"height":63}},"126":{"xOffset":2,"yOffset":30,"xAdvance":37,"rect":{"x":16,"y":460,"width":36,"height":15}}},"kerningDict":{"2621514":-1,"2621546":5,"4259907":-1,"4259911":-1,"4259924":-5,"4259925":-2,"4259926":-3,"4259929":-4,"4259958":-1,"4325420":-2,"4325422":-3,"4325441":-2,"4325461":-2,"4390956":-2,"4390958":-3,"4456492":-4,"4456494":-4,"4456513":-2,"4456534":-1,"4456535":1,"4456537":-2,"4587564":-7,"4587566":-8,"4587585":-4,"4587617":-1,"4587621":-2,"4587631":-2,"4587634":-2,"4653102":-1,"4653121":-2,"4849708":-4,"4849710":-4,"4849729":-1,"4915241":-2,"4915267":-3,"4915271":-3,"4915279":-2,"4915301":-2,"4915311":-2,"4915317":-2,"4915318":-4,"4915319":-3,"4915321":-1,"4980803":-3,"4980807":-4,"4980815":-3,"4980819":-2,"4980820":-8,"4980821":-3,"4980822":-7,"4980823":-4,"4980825":-8,"4980855":-2,"4980857":-2,"5111854":-1,"5177388":-2,"5177390":-3,"5177409":-2,"5177428":-2,"5177430":-1,"5177432":-1,"5177433":-2,"5242924":-8,"5242926":-9,"5242945":-5,"5242977":-2,"5242981":-2,"5242991":-2,"5308500":-2,"5308503":1,"5308505":-3,"5308518":2,"5308519":1,"5308522":3,"5308528":1,"5373993":-1,"5374036":-3,"5374037":-1,"5374038":-1,"5374041":-2,"5374053":-1,"5374063":-1,"5374069":-1,"5374070":-1,"5439532":-1,"5439534":-2,"5505068":-7,"5505069":-3,"5505070":-8,"5505082":-3,"5505083":-3,"5505089":-4,"5505091":-1,"5505095":-1,"5505121":-3,"5505123":-4,"5505125":-4,"5505133":-2,"5505135":-4,"5505138":-2,"5505139":-4,"5505141":-3,"5505143":-2,"5505145":-2,"5505146":-1,"5570604":-2,"5570606":-3,"5570625":-3,"5636140":-7,"5636141":-3,"5636142":-8,"5636154":-1,"5636155":-1,"5636161":-3,"5636193":-3,"5636197":-3,"5636207":-3,"5636210":-2,"5636213":-2,"5636217":-2,"5701676":-3,"5701678":-4,"5701690":-1,"5701691":-1,"5701729":-1,"5701732":-1,"5701733":-1,"5701743":-1,"5701749":-2,"5701753":-1,"5767235":-1,"5767239":-1,"5832748":-6,"5832749":-3,"5832750":-7,"5832762":-3,"5832763":-3,"5832769":-4,"5832771":-1,"5832775":-1,"5832787":-1,"5832801":-4,"5832804":-4,"5832805":-4,"5832815":-4,"5832816":-3,"5832817":-4,"5832821":-3,"5832822":-2,"6357108":-1,"6357110":-1,"6357111":-1,"6422572":-3,"6422574":-4,"6488108":-2,"6488110":-3,"6488168":-1,"6488171":-2,"6488172":-1,"6488185":-1,"6619180":-2,"6619182":-3,"6619254":-1,"6619257":-1,"6684704":7,"6684705":2,"6684713":2,"6684716":-2,"6684718":-3,"6684735":3,"6684774":2,"6750252":-1,"6750254":-2,"6750305":-1,"6750309":-1,"6750311":-1,"6750319":-1,"7012449":-2,"7012451":-1,"7012452":-2,"7012453":-2,"7012455":-2,"7012457":-1,"7012460":-1,"7012463":-2,"7012464":-1,"7012465":-2,"7012467":-1,"7012469":-1,"7012473":-1,"7274540":-2,"7274542":-3,"7274616":-1,"7340076":-2,"7340078":-3,"7471148":-7,"7471150":-8,"7471201":-1,"7471203":-1,"7471204":-1,"7471205":-1,"7471207":-1,"7471211":-1,"7471215":-2,"7471217":-2,"7471219":-1,"7471221":-1,"7536684":-2,"7536686":-3,"7536759":-1,"7733292":-4,"7733294":-4,"7733347":-1,"7798828":-4,"7798830":-5,"7864419":-1,"7929900":-4,"7929902":-5}}]],0,0,[0],[9],[58]],[[[36,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[12,11],[2,59]],[[{"name":"Wood","rect":{"x":0,"y":0,"width":30,"height":32},"offset":{"x":0,"y":0},"originalSize":{"width":30,"height":32},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[1],0,[0],[3],[60]],[[{"name":"default_btn_normal","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"packable":true}],[1],0,[0],[3],[61]],[[[149,"战斗准备音乐",".mp3",2.481633],-1],0,0,[],[],[]],[[[71,"circleAvatar/CircleAvatar",[{"hash":3194979996,"name":"circleAvatar/CircleAvatar|sprite-vs:vert|sprite-fs:frag","blocks":[{"name":"ALPHA_TEST_DATA","stageFlags":16,"binding":0,"members":[{"name":"alphaThreshold","type":13,"count":1}],"defines":["USE_ALPHA_TEST"]},{"name":"ARGS","stageFlags":16,"binding":1,"members":[{"name":"radius","type":13,"count":1},{"name":"blur","type":13,"count":1},{"name":"center","type":14,"count":1},{"name":"wh_ratio","type":13,"count":1}],"defines":[]}],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":21,"location":1,"defines":[]},{"name":"a_color","format":44,"location":2,"defines":[]},{"name":"a_uv0","format":21,"location":3,"defines":["USE_TEXTURE"]}],"varyings":[{"name":"v_color","type":16,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"v_uv0","type":14,"count":1,"stageFlags":17,"location":1,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if USE_LOCAL\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n  };\n#endif\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec2 a_texCoord;\nlayout(location = 2) in vec4 a_color;\nlayout(location = 0) out vec4 v_color;\nlayout(location = 1) out vec2 v_uv0;\n#if USE_TEXTURE\n  layout(location = 3) in vec2 a_uv0;\n#endif\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matWorld * pos;\n  #endif\n  #if USE_PIXEL_ALIGNMENT\n    pos = cc_matView * pos;\n    pos.xyz = floor(pos.xyz);\n    pos = cc_matProj * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n    v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  v_uv0 = a_texCoord;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvec4 CCSampleWithAlphaSeparated(sampler2D tex, vec2 uv) {\n#if CC_USE_EMBEDDED_ALPHA\n  return vec4(texture(tex, uv).rgb, texture(tex, uv + vec2(0.0, 0.5)).r);\n#else\n  return texture(tex, uv);\n#endif\n}\n#if USE_ALPHA_TEST\n  layout(set = 1, binding = 0) uniform ALPHA_TEST_DATA {\n    float alphaThreshold;\n  };\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n    if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n    if (alpha < alphaThreshold) discard;\n  #endif\n}\nlayout(location = 0) in vec4 v_color;\nlayout(location = 1) in vec2 v_uv0;\n#if USE_TEXTURE\n  layout(set = 2, binding = 11) uniform sampler2D cc_spriteTexture;\n#endif\nlayout(set = 1, binding = 1) uniform ARGS{\n  float radius;\n  float blur;\n  vec2 center;\n  float wh_ratio;\n};\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  o *= CCSampleWithAlphaSeparated(cc_spriteTexture, v_uv0);\n  o *= v_color;\n  ALPHA_TEST(o);\n  float circle = radius * radius;\n  float rx = center.x * wh_ratio;\n  float ry = center.y;\n  float uv_x = v_uv0.x * wh_ratio;\n  float uv_y = v_uv0.y;\n  float a2 = (uv_x - rx) * (uv_x - rx);\n  float b2 = (uv_y - ry) * (uv_y - ry);\n  float dis = a2 + b2;\n  o.a = smoothstep(circle, circle - blur, dis) * o.a;\n  return o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if USE_LOCAL\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n  };\n#endif\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\nout vec4 v_color;\nout vec2 v_uv0;\n#if USE_TEXTURE\n  in vec2 a_uv0;\n#endif\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matWorld * pos;\n  #endif\n  #if USE_PIXEL_ALIGNMENT\n    pos = cc_matView * pos;\n    pos.xyz = floor(pos.xyz);\n    pos = cc_matProj * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n    v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  v_uv0 = a_texCoord;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvec4 CCSampleWithAlphaSeparated(sampler2D tex, vec2 uv) {\n#if CC_USE_EMBEDDED_ALPHA\n  return vec4(texture(tex, uv).rgb, texture(tex, uv + vec2(0.0, 0.5)).r);\n#else\n  return texture(tex, uv);\n#endif\n}\n#if USE_ALPHA_TEST\n  layout(std140) uniform ALPHA_TEST_DATA {\n    float alphaThreshold;\n  };\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n    if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n    if (alpha < alphaThreshold) discard;\n  #endif\n}\nin vec4 v_color;\nin vec2 v_uv0;\n#if USE_TEXTURE\n  uniform sampler2D cc_spriteTexture;\n#endif\nlayout(std140) uniform ARGS{\n  float radius;\n  float blur;\n  vec2 center;\n  float wh_ratio;\n};\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  o *= CCSampleWithAlphaSeparated(cc_spriteTexture, v_uv0);\n  o *= v_color;\n  ALPHA_TEST(o);\n  float circle = radius * radius;\n  float rx = center.x * wh_ratio;\n  float ry = center.y;\n  float uv_x = v_uv0.x * wh_ratio;\n  float uv_y = v_uv0.y;\n  float a2 = (uv_x - rx) * (uv_x - rx);\n  float b2 = (uv_y - ry) * (uv_y - ry);\n  float dis = a2 + b2;\n  o.a = smoothstep(circle, circle - blur, dis) * o.a;\n  return o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp mat4 cc_matViewProj;\n#if USE_LOCAL\n  uniform highp mat4 cc_matWorld;\n#endif\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nvarying vec4 v_color;\nvarying vec2 v_uv0;\n#if USE_TEXTURE\n  attribute vec2 a_uv0;\n#endif\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matWorld * pos;\n  #endif\n  #if USE_PIXEL_ALIGNMENT\n    pos = cc_matView * pos;\n    pos.xyz = floor(pos.xyz);\n    pos = cc_matProj * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n    v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  v_uv0 = a_texCoord;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvec4 CCSampleWithAlphaSeparated(sampler2D tex, vec2 uv) {\n#if CC_USE_EMBEDDED_ALPHA\n  return vec4(texture2D(tex, uv).rgb, texture2D(tex, uv + vec2(0.0, 0.5)).r);\n#else\n  return texture2D(tex, uv);\n#endif\n}\n#if USE_ALPHA_TEST\n      uniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n    if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n    if (alpha < alphaThreshold) discard;\n  #endif\n}\nvarying vec4 v_color;\nvarying vec2 v_uv0;\n#if USE_TEXTURE\n  uniform sampler2D cc_spriteTexture;\n#endif\n   uniform float radius;\n   uniform float blur;\n   uniform vec2 center;\n   uniform float wh_ratio;\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  o *= CCSampleWithAlphaSeparated(cc_spriteTexture, v_uv0);\n  o *= v_color;\n  ALPHA_TEST(o);\n  float circle = radius * radius;\n  float rx = center.x * wh_ratio;\n  float ry = center.y;\n  float uv_x = v_uv0.x * wh_ratio;\n  float uv_y = v_uv0.y;\n  float a2 = (uv_x - rx) * (uv_x - rx);\n  float b2 = (uv_y - ry) * (uv_y - ry);\n  float dis = a2 + b2;\n  o.a = smoothstep(circle, circle - blur, dis) * o.a;\n  return o;\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":["USE_LOCAL"]}],"samplerTextures":[{"name":"cc_spriteTexture","defines":["USE_TEXTURE"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":49,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":5}},"defines":[{"name":"USE_LOCAL","type":"boolean","defines":[]},{"name":"USE_TEXTURE","type":"boolean","defines":[]},{"name":"USE_PIXEL_ALIGNMENT","type":"boolean","defines":[]},{"name":"CC_USE_EMBEDDED_ALPHA","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]}]}],[{"passes":[{"program":"circleAvatar/CircleAvatar|sprite-vs:vert|sprite-fs:frag","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"rasterizerState":{"cullMode":0},"depthStencilState":{"depthTest":false,"depthWrite":false},"properties":{"alphaThreshold":{"type":13,"value":[0.5]},"wh_ratio":{"type":13,"value":[1],"editor":{"tooltip":"宽高比"}},"blur":{"type":13,"value":[0.01],"editor":{"tooltip":"光圈模糊程度"}},"radius":{"type":13,"value":[0.5],"editor":{"tooltip":"光圈半径"}},"center":{"type":14,"value":[0.5,0.5],"editor":{"tooltip":"光圈起点"}}}}]}]]],0,0,[],[],[]],[[[27,"wall_explode",".plist"],-1],0,0,[],[],[]],[[[16,"wallExplode"],[33,"wallExplode",33554432,[-5,-6],[[14,-2,[0,"c1r0lHG0tKq5Pwa9GKkWnP"]],[150,-4,[0,"ea7uVwv4dOs52m/A5qmomA"],-3,2,3,4]],[1,"06gAbLIA9Gl4hqcufELOeV",-1,0]],[11,"xiangzi",33554432,1,[[14,-7,[0,"56+cIgoLtEhKMAik9YMdXH"]],[139,0.05,1111,0.3,0.2,76,180,60,10,-1,150,20,0,true,30,-8,[0,"68/tXVfbFOAqMoavCSDDva"],[0,80,20],[4,4291546062],0,1],[31,170,-9,[0,"f8OIy265ZNur54sGkQXRll"]]],[1,"1cnNCufl5Izq7tTkjWEiy6",1,0]],[113,"Node",33554432,1,[[[14,-10,[0,"a6hxZN4G5JYpMLQDJDkcLF"]],-11],4,1],[1,"1d6AGPHOROnospWq+Il/fx",1,0]],[140,0.08,100,0.5,0.2,0,180,100,2,10,256,500,0,0,-343,true,true,73,3,[0,"5de4OaiFNKKK7zx9MS3JkT"],[0,0,-1400],[4,422772736],[4,4294967295],[4,3342336]]],0,[0,4,1,0,0,1,0,32,4,0,0,1,0,-1,2,0,-2,3,0,0,2,0,0,2,0,0,2,0,0,3,0,-2,4,0,5,1,11],[0,0,0,0,0,4,4],[10,1,33,34,35,10,1],[62,6,21,63,64,65,21]],[[[36,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[12,11],[22,23]],[[{"name":"shiqu","rect":{"x":1,"y":0,"width":47,"height":45},"offset":{"x":0.5,"y":0.5},"originalSize":{"width":48,"height":46},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[1],0,[0],[3],[66]],[[[65,"resurrection_countdown_font",119.68,{"commonHeight":136,"fontSize":119,"atlasName":"resurrection_countdown_sprite","fontDefDictionary":{"48":{"xOffset":0,"yOffset":0,"xAdvance":104,"rect":{"x":0,"y":0,"width":104,"height":136}},"49":{"xOffset":0,"yOffset":0,"xAdvance":104,"rect":{"x":0,"y":136,"width":104,"height":136}},"50":{"xOffset":0,"yOffset":0,"xAdvance":104,"rect":{"x":0,"y":272,"width":104,"height":136}},"51":{"xOffset":0,"yOffset":0,"xAdvance":104,"rect":{"x":0,"y":408,"width":104,"height":136}},"52":{"xOffset":0,"yOffset":0,"xAdvance":104,"rect":{"x":0,"y":544,"width":104,"height":136}},"53":{"xOffset":0,"yOffset":0,"xAdvance":104,"rect":{"x":0,"y":680,"width":104,"height":136}},"54":{"xOffset":0,"yOffset":0,"xAdvance":104,"rect":{"x":0,"y":816,"width":104,"height":136}},"55":{"xOffset":0,"yOffset":0,"xAdvance":104,"rect":{"x":0,"y":952,"width":104,"height":136}},"56":{"xOffset":0,"yOffset":0,"xAdvance":104,"rect":{"x":0,"y":1088,"width":104,"height":136}},"57":{"xOffset":0,"yOffset":0,"xAdvance":104,"rect":{"x":0,"y":1224,"width":104,"height":136}}},"kerningDict":{}}]],0,0,[0],[9],[67]],[[[27,"shiqu",".plist"],-1],0,0,[0],[9],[24]],[[[27,"star",".plist"],-1],0,0,[],[],[]],[[{"name":"default_btn_pressed","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"packable":true}],[1],0,[0],[3],[68]],[[{"name":"Star","rect":{"x":1,"y":0,"width":122,"height":114},"offset":{"x":0.5,"y":0.5},"originalSize":{"width":123,"height":115},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[1],0,[0],[3],[69]],[[[27,"tank_explode2",".plist"],-1],0,0,[0],[9],[6]],[[[16,"star"],[39,"star",33554432,[[14,-2,[0,"11b9AAM4BP0oFLQ+oLlN1j"]],[141,1,0.1,1000,0,1.05,180,360,30,153.52,168,400,0,0,true,true,15,-3,[0,"acmOBiBAFCbbV3wIrEvsSj"],[0,0,-400],[4,4294967295],0,1]],[1,"95KP1pZ5ZOYJCiCnUPeSPm",-1,0]]],0,[0,4,1,0,0,1,0,0,1,0,5,1,3],[0,0],[10,1],[70,25]],[[{"name":"head_my","rect":{"x":0,"y":0,"width":300,"height":300},"offset":{"x":0,"y":0},"originalSize":{"width":300,"height":300},"rotated":false,"capInsets":[0,0,0,0],"packable":false}],[1],0,[0],[3],[71]],[[[16,"Grid"],[33,"Grid",8388608,[-8,-9],[[151,-4,[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],-3,-2,4,5,6],[2,-5,[0,"55pCbtzR5GbojKMArZkfim"],[5,132,132]],[152,false,0,-6,[0,"20UGQn4U9GUoln0NJQTkbG"],[4,4290159275],21],[18,-7,[0,"47ANUZeb1BOLFjdqsU2l+Y"]]],[1,"354iN6uTdCZ7aEy6RCSrSK",-1,0]],[23,"obstacle1",8388608,1,[-13],[[2,-10,[0,"137/xNxYVOgKfGX7HPew1i"],[5,200,200]],[60,0,false,-11,[0,"dc7vWaDONGdbMjcVjWX0yt"],1],[18,-12,[0,"aaBZOMUY1Gqple3FLscfra"]]],[1,"14oIOx7wtD/Yltajxdbr4N",1,0]],[23,"obstacle2",8388608,1,[-17],[[2,-14,[0,"ab6+E0hCBFo6k8+vxgCncG"],[5,200,200]],[60,0,false,-15,[0,"24hxLtY6lBvq0IhgP2HyV4"],3],[18,-16,[0,"b8PU+evIxByYSSVHVmoK3a"]]],[1,"2196m47WhEEZLeBPQzg2gS",1,0]],[11,"SpriteSplash",8388608,2,[[2,-18,[0,"50MEwUCK9OQJmhn+QkTzq4"],[5,200,200]],[60,0,false,-19,[0,"4eGbtXuOZGQqe1ipCNt9CT"],0]],[1,"feyDkM43BEj4cZTTJmqpkZ",1,0]],[11,"SpriteSplash",8388608,3,[[2,-20,[0,"a3ECY3hP5Jo5imsUPGGwQ5"],[5,200,200]],[60,0,false,-21,[0,"d6Yh6yVDZMaJ8hks1iJduM"],2]],[1,"18a0RywDdC2omkxW+yd1Id",1,0]]],0,[0,4,1,0,36,3,0,37,2,0,0,1,0,0,1,0,0,1,0,0,1,0,-1,2,0,-2,3,0,0,2,0,0,2,0,0,2,0,-1,4,0,0,3,0,0,3,0,0,3,0,-1,5,0,0,4,0,0,4,0,0,5,0,0,5,0,5,1,21],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,1,1,38,39,40,-1,-2,-1,-2,-1,-2,-1,-2,-1,-2,-1,-2,-1,-2,1],[26,27,28,29,27,72,73,74,29,75,76,77,78,79,80,26,28,81,82,83,84,30]],[[[27,"tank_explode",".plist"],-1],0,0,[],[],[]],[[[36,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_OUTLINE_PASS":true},{"USE_RIM_LIGHT":true,"USE_BASE_COLOR_MAP":true,"USE_EMISSIVE":true,"USE_GRAYCOLOR":true},{}],[[{"lineWidth":0},[{},"rimLightColor",8,[4,4060086272],"mainTexture",6,0],{}],0,11,0]]],0,0,[0,0],[12,11],[22,11]],[[[93,"Mukta-ExtraBold","Mukta-ExtraBold.ttf"],-1],0,0,[],[],[]],[[[147,[{}],[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_TEXTURE":true}]]],0,0,[0],[11],[85]],[[{"name":"01Backgroundy_2","rect":{"x":0,"y":0,"width":200,"height":2366},"offset":{"x":0,"y":0},"originalSize":{"width":200,"height":2366},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[1],0,[0],[3],[86]],[[[16,"GameUI"],[33,"GameUI",33554432,[-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49],[[155,-23,[0,"b19oCniaxFV5nM17DCZ5rH"],-22,-21,-20,-19,-18,-17,-16,-15,-14,-13,-12,-11,90,91,92,93,94,95,96,97,98,99,100,101],[2,-24,[0,"8fX+5LwnNLhLpWKgupX54W"],[5,2160,1080]],[25,45,100,100,-25,[0,"8fQsi8O9xOpJyh/RrcM91Z"]],[156,-29,[0,"09DoFh/LNMw4Zg3wYTGhNT"],-28,-27,-26,102,103]],[132,"553AL2oZZOKZ0nOlcr1ecL",-10,0,[[63,["_trailModule","_particleSystem"],-3,[9,["980Q9M9ABGEoO/XCAtC7eB"]],-2,[9,["980Q9M9ABGEoO/XCAtC7eB"]]],[63,["_trailModule","_particleSystem"],-5,[9,["02iAH9OJRHnaRs0DgUX1Xq"]],-4,[9,["02iAH9OJRHnaRs0DgUX1Xq"]]],[63,["_trailModule","_particleSystem"],-7,[9,["cciZlh/shKt7T+VcHngUXH"]],-6,[9,["cciZlh/shKt7T+VcHngUXH"]]],[63,["_trailModule","_particleSystem"],-9,[9,["1bbT5FXpFMfJpUcck/eJ2+"]],-8,[9,["1bbT5FXpFMfJpUcck/eJ2+"]]]],[-1]]],[75,"groundLayer",4,[-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88],[[2,-50,[0,"06dqY33K5KHoDVO5CNa6F9"],[5,3200,3300]],[118,16,7,-51,[0,"62JukSwThO+Y1ey7PZ5vRd"]],[157,3,-2,-2,-52,[0,"90IgFQmvhKdZWEcWteHAjT"]]],[1,"bdhv+O7WpHOJvZr3zRWPn7",1,0],[1,1621.5,2127.282,0]],[75,"content",8388608,[-91,-92,-93,-94,-95,-96,-97,-98,-99,-100],[[8,-89,[0,"caiE1El29JmJ1dOHVaZjYf"],[5,2508,2508],[0,0,0]],[119,16,346,-4.22199999999998,-90,[0,"96gufCYxRClJJZdzGgXId1"]]],[1,"06Sj0KpW9MXodqV1Fw+fEm",1,0],[1,356.278,840,0]],[114,"map",4294967295,1,[2,-104,-105,-106,3,-107,-108,-109,-110],[[-101,[8,-102,[0,"f7NISe7HdAD68SLfhnddy8"],[5,3229,4731],[0,0,0]],[120,1380,-103,[0,"f3wgp9R39PnLjYspk+CnUb"]]],1,4,4],[1,"a7rc4/zoFEba9ZY1jYOCna",1,0],[1,-1614.5,-2121.96,0]],[13,"emojiContent",1,1,[-116,-117,-118,-119],[[2,-111,[0,"ceVK+bq89CnLy8EatHN2QM"],[5,106,394]],[158,1,2,10,10,10,-112,[0,"f2cRtCE1xGH6qFTstN/0MG"]],[32,1,0,-113,[0,"5bkxFASgFJ2oD7N8GfbDcD"],37],[84,34,50,-114,[0,"felV3b8gJFh7KB4wa5ikm0"]],[161,false,-115,[0,"ceHyBlepxPrLZdkrlSYce/"],38]],[1,"b8Bz8R6XtNU5UsHk2tyE0p",1,0],[1,977,0,0]],[19,512,{},1,[21,"a7VfsM1EtIErcrLNDR9BwQ",-146,[22,"ffgqteKTlFCqBjqeH3+NHc",1,[[10,"IceSmoke",["_name"],-120],[7,["_lpos"],-121,[1,0,0,0]],[7,["_lrot"],-122,[3,0,0,0,1]],[7,["_euler"],-123,[1,0,0,0]],[10,1,["_layer"],-124],[37,1,["_layer"],[9,["4bkUIarJlE9axVzkBYQrnH"]]],[10,1,["_layer"],-125],[10,1,["_layer"],-126],[10,1,["_layer"],-127],[37,1,["_layer"],[9,["06qX13C2tHn7+XFnKuOW6K"]]],[37,1,["_layer"],[9,["3etzAWFatEIaJPMDCPnmp4"]]],[37,1,["_layer"],[9,["23z9EPW5dHpoPvpPe9g8Pf"]]],[37,1,["_layer"],[9,["34RX1gOdZNTYJM/CaIxiAr"]]],[7,["_colorOverLifetimeModule","color","gradient","colorKeys","0","color"],-128,[4,4294967295]],[7,["_colorOverLifetimeModule","color","gradient","colorKeys","1","color"],-129,[4,4294967295]],[7,["startColor","color"],-130,[4,1023410175]],[7,["startColor","color"],-131,[4,1023410175]],[7,["startColor","color"],-132,[4,1023410175]],[7,["startColor","color"],-133,[4,1023410175]],[10,true,["_active"],-134],[10,true,["_active"],-135],[10,true,["_active"],-136],[10,1,["_colorOverLifetimeModule","color","gradient","colorKeys","1","time"],-137],[7,["_colorOverLifetimeModule","color","gradient","colorKeys","1","color"],-138,[4,4294967295]],[10,true,["loop"],-139],[10,true,["loop"],-140],[10,true,["loop"],-141],[10,false,["playOnAwake"],-142],[10,false,["playOnAwake"],-143],[10,false,["playOnAwake"],-144],[10,false,["playOnAwake"],-145]]],55]],[67,"MultiScoreRank",1,1,[-150,-151,-152,-153,-154],[[8,-147,[0,"e6mEkovFlIcZ7o6s+P7OTz"],[5,260,70],[0,0.5,1]],[32,1,0,-148,[0,"736eIov49JA4Y1k1ltCZWi"],78],[86,33,1689.864,164,50,-149,[0,"53BMr21M1F7oRo7mAEFzGV"]]],[1,"afHiza7wBAM7sA1o9lAwSx",1,0],[1,760,490,0],[1,1.2,1.2,1.2]],[104,"GuideManager",512,1,1,[-168,-169,-170,-171,-172],[[2,-155,[0,"31RMVno1FO1ZItagrTsJkd"],[5,2160,1080]],[163,-166,[0,"fasReWGXlGaawKjvn8jr7P"],-165,-164,-163,-162,-161,-160,-159,5,7,-158,-157,-156,68],[25,45,100,100,-167,[0,"ddlLuqcMNHKqgPiD4zZbrp"]]],[1,"a7fqxUnj5H+78sqCd++Yyf",1,0]],[83,"LeftJoyStick",512,1,1,[-177,-178,-179],[[-173,[8,-174,[0,"e6R4ZYMtVGApI8SaL4JWm4"],[5,1080,1080],[0,0,0]],[18,-175,[0,"4bA4v1P4VDdaAmAiLlMn6B"]],[121,45,0.5,false,750,1334,-176,[0,"4ftYhmxgdCBboPpaDG1C/N"]]],1,4,4,4],[1,"18jdn482ZJMKDYNuDLbGyx",1,0],[1,-1080,-540,0]],[83,"RightJoyStick",512,1,1,[-184,-185,-186],[[[8,-180,[0,"79hhQKT0pELJL2IIyWsmZn"],[5,1080,1080],[0,0,0]],-181,[18,-182,[0,"11rf4hG7FBWasLW5OtcPNm"]],[122,45,0.5,false,false,750,1334,-183,[0,"c95OoXSmFH660WBTc39QQI"]]],4,1,4,4],[1,"00OBVNoS5KV4OTL+aEQ9Hs",1,0],[1,0,-540,0]],[35,"ReadyGo",false,1,1,[-190,-191,-192],[[2,-187,[0,"7duzunuVRO+Yx5BAO8Bvxb"],[5,2160,1080]],[123,45,false,100,100,-188,[0,"12C4CqInVKqq72vQxhDBta"]],[164,false,-189,[0,"a77qaUy7FCyp9IIAj+C+Pb"]]],[1,"69ZTBtx29ONKMyX6H3+cvi",1,0]],[13,"skipBtn",1,8,[-198],[[2,-193,[0,"36npFTLUNKE6j0X31F9Nz1"],[5,200,120]],[32,1,0,-194,[0,"4abwi8N/BKR6cmX3BC/8NU"],62],[162,3,0.9,-196,[0,"e2w1U60bVA4aYAlxt7Ad7Q"],[[38,"23364oJA25BaJZeFx0fKnWG","onSkipBtnTap",8]],[4,4292269782],-195,63,64,65,66],[68,9,-0.4179999999998927,13.341000000000008,-197,[0,"5etWf5vc1LUJOd3kv0IHts"]]],[1,"6e2ifWE11HnYoE2ntvObkc",1,0],[1,-980.4179999999999,466.659,0]],[35,"around_wall_layer",false,4294967295,3,[-201,-202,-203,-204],[[8,-199,[0,"5abPCHLXRIMIS5MkSaxQhU"],[5,2508,2508],[0,0,0]],[26,16,346,-200,[0,"5dkm3pKYdBqb9ww0KCqJcg"]]],[1,"8cIocHA1tK55k2eSqdkyXI",1,0]],[13,"ring",1,9,[-207,-208,-209],[[2,-205,[0,"67UedHyvNIb4Wx/DeFGiX+"],[5,268,268]],[18,-206,[0,"a2P/HYLA9FW55VjbvjBcIc"]]],[1,"e6h1x0IOxP/a/m05V69bxK",1,0],[1,350,230,0]],[35,"reliveTimeDown",false,1,1,[-212,-213,-214],[[2,-210,[0,"1ccePJQpRLQ6adI9G5vY4X"],[5,2160,1080]],[25,45,100,100,-211,[0,"d5iTTxH8RLx51JZHNCPAVM"]]],[1,"d8NkStoiVES5lfPlBoA9CR",1,0]],[67,"ping",1,1,[-218,-219],[[2,-215,[0,"f7NISe7HdAD68SLfhnddy8"],[5,136,99]],[90,-216,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,4282901015],54],[87,33,1077.716,576.3789999999999,84.755,136,-217,[0,"dbTIViCWBPl76ZwOhhfHml"]]],[1,"24RI4dNCZIHI6/6PpSuW1g",1,0],[1,476.4210000000001,435.445,0],[1,0.4,0.4,0.4]],[76,"multiple_score_item",false,1,7,[-225,-226,-227],[[2,-220,[0,"2eSP5j3UZK7plU0ImT+mlU"],[5,260,40]],[165,-224,[0,"77fhGzOCdLyqlpeF2meF0M"],[72,73,74,75,76,77],-223,-222,-221]],[1,"1c94kwjOVH7Kqu+9CtQuav",1,0],[1,2.2737367544323206e-13,-70,0]],[35,"bg1_edge_map",false,4,4,[-229,-230,-231,-232],[[14,-228,[0,"5dCXRlopFF5pNNmk6dLts0"]]],[1,"19QWOH/vZHRKickhOOrw+P",1,0]],[13,"tip_ring",1,9,[-235,-236],[[2,-233,[0,"a7WvOpVYFFEJynJNYrkbta"],[5,268,268]],[18,-234,[0,"f3lEwcPzFAg7q0dksV59Rz"]]],[1,"e064XJjNNGQ6eDhz8TRaQU",1,0],[1,350,230,0]],[13,"ring",1,10,[-239,-240],[[2,-237,[0,"a1kzeznOxGlp/RK7CMYdaC"],[5,268,268]],[18,-238,[0,"deR0B0J8RE7ZoF3BrTYQI4"]]],[1,"9e3Gqv1ZdIiIQOl9n2/O09",1,0],[1,690,230,0]],[13,"tip_ring",1,10,[-243,-244],[[2,-241,[0,"13d2nAp+RArq2sTj+RAk/f"],[5,268,268]],[18,-242,[0,"e8sWc+QtdBOpYml35Yx+tE"]]],[1,"95GV9W8npJ8ZMpe1Q53ZcJ",1,0],[1,690,230,0]],[4,"closeBtn",1,1,[[2,-245,[0,"f7NISe7HdAD68SLfhnddy8"],[5,89,89]],[6,-246,[0,"e71ctEmpxFC4KlSYRZNz/a"],25],[68,9,55,55,-247,[0,"5af6FlslJIR5vGUgutNXeB"]],[94,3,-248,[0,"e3H9p7RxNDD4rReHaB5R2G"],[[38,"c673aDLeWxH65MtEgUt6vqS","onQuitBtnTap",1]],26]],[1,"d7poO9oK5GU4PdCFgBhYCU",1,0],[1,-980.5,440.5,0]],[4," soundBtn",1,1,[[2,-249,[0,"f7NISe7HdAD68SLfhnddy8"],[5,89,89]],[6,-250,[0,"e71ctEmpxFC4KlSYRZNz/a"],27],[124,33,55,50,50,936,89,-251,[0,"c0WqfLtilK+IUZyN8W0gPj"]],[94,3,-252,[0,"b9WttRq+1Dep4vG8hfIPL3"],[[38,"c673aDLeWxH65MtEgUt6vqS","onSoundBtnTap",1]],28]],[1,"46aHmRM+xDS5H+NehVx4pQ",1,0],[1,985.5,445.5,0]],[13,"GameCountdown",1,1,[-259],[[2,-253,[0,"39L5popd5FFYHnevdZ/0ft"],[5,38.33,55]],[166,-256,[0,"3e6lOdgkRGSrH5E837i26x"],-255,-254,49,50],[73,"9",55,55,55,false,-257,[0,"1afHNAwk5Hd5yqNFlFDgbt"],52],[87,17,1077.716,290.35300000000007,20,136,-258,[0,"9dbqL5n/JNEqsi6G9qRk0c"]]],[1,"8fUX/pEqhGCbfnXCu8zXWR",1,0],[1,0,492.5,0]],[11,"warningBg",1,1,[[2,-260,[0,"4aX2i/DPRDPKQ4GbrcdyTy"],[5,2188,1080]],[32,1,0,-261,[0,"71So8y6+hN6KtMZBEnynnP"],51],[125,45,-14,-14,1024,640,-262,[0,"62MMtOkjhAAIPiyyjFUpnT"]],[31,0,-263,[0,"e5fzNYNthF+pLzoQbG9Nm0"]]],[1,"a3HmCWVTpObocsDBEsJVEU",1,0]],[13,"tip",1,8,[-267,-268],[[2,-264,[0,"5cC1QAnW9IApQkr4IfX6e6"],[5,0,110]],[85,1,80.648,-265,[0,"b5+513mqpC+aRnMpkNlATk"]],[99,-266,[0,"0dCvztLGpAX7GoQmnjm2b0"]]],[1,"dd13GgqDJHf7lxNt+isJL9",1,0],[1,0,404.352,0]],[13,"testButton1",1,1,[-273],[[2,-269,[0,"e0aWKDivBGRqUOAHxy5VqW"],[5,200,80]],[32,1,0,-270,[0,"ceGRAgcExGhIc3rWgIpE2R"],80],[95,2,-272,[0,"f6RcKQ4VVIibGy0jdCNcNj"],[[38,"c673aDLeWxH65MtEgUt6vqS","player1Connect",1]],[4,4292269782],-271,81,82,83,84]],[1,"c4L3LgomZJ+b2h3rnlJX64",1,0],[1,-150,0,0]],[13,"testButton2",1,1,[-278],[[2,-274,[0,"00wvXP4zxGSrk1iXeC6J2X"],[5,200,80]],[32,1,0,-275,[0,"b8XhJRkmdEHJU6PQQYmJy8"],85],[95,2,-277,[0,"ae+2XU1cpGrr2Pu+nwsFAO"],[[38,"c673aDLeWxH65MtEgUt6vqS","player2Connect",1]],[4,4292269782],-276,86,87,88,89]],[1,"76O+0IIrJEaZKiL4r2ZS9z",1,0],[1,150,0,0]],[4,"Prop Land",8388608,3,[[2,-279,[0,"c0S4LSUQNErbOGWpg71CUo"],[5,437,439]],[6,-280,[0,"f5jx0/jyJFC6LCfukVmc40"],4],[126,18,-281,[0,"60QxkAKhdCVLS6U3lRzgga"]]],[1,"3aBqeoODlNeKzQmbYpyAh/",1,0],[1,1254,1254,0]],[11,"tank_layer",8388608,3,[[8,-282,[0,"9biCmBXgZG56zEoHIuZ3Y5"],[5,2508,2508],[0,0,0]],[26,16,346,-283,[0,"56ha49av9KbKOoxlfVoz1u"]]],[1,"b9L4mrs4lDb4dbjR6SMKes",1,0]],[23,"joystickBG",1,19,[-287],[[2,-284,[0,"b632lrmkVE779S0WSVlcsa"],[5,268,268]],[15,0,-285,[0,"f1xBNdAsNGnLtQ3YBKiNWj"],17],[31,100,-286,[0,"17g+K/e1hHLbtDGftGaayW"]]],[1,"eeCkz0cHZFybqqiqCe+MNF",1,0]],[23,"joystickBG",1,21,[-291],[[2,-288,[0,"a4vGhTnW1EZZRCYBOKquhc"],[5,268,268]],[15,0,-289,[0,"bapdyoDOpAypt557JRqoVR"],23],[31,100,-290,[0,"ccvCeMAMZM26AXbUuZDgpy"]]],[1,"dfphtVk+NPqYO3etqsWDqH",1,0]],[23,"go",1,11,[-294,-295],[[8,-292,[0,"edMgXaBiNPxY8EM7DBliFh"],[5,224,173],[0,0.5,-0.1]],[6,-293,[0,"43Y340mltHloTpD8x3vqwD"],43]],[1,"858fSigYxInJw1le4PyjaO",1,0]],[11,"blackBg",1,15,[[2,-296,[0,"52YYbblC1NFJaA0En/iW5Y"],[5,2160,1080]],[61,0,-297,[0,"ebyezwQEJPYqsqJTMkLNhF"],[4,2432696320],44],[25,45,100,100,-298,[0,"47QTTY+5NNB6DLxd1oYsFe"]],[96,-299,[0,"b8Cge77C1LdJd8wUDITdZG"]]],[1,"04S97qJx9BkJPnu1jK04bH",1,0]],[20,"GameCountdownClock",1,24,[[2,-300,[0,"cbn45dRONPO6kTzsrE3eR+"],[5,74,74]],[127,17,1077.716,290.35300000000007,1.5219999999999971,-56.453,136,-301,[0,"c4png1uPlIGqPbSzQzM2XJ"]],[15,0,-302,[0,"0emeJWSIlLxKP2sT6bD6zP"],48]],[1,"aaQHQ7miRDpZsuslWpJqEu",1,0],[1,-56.453,-7.322000000000003,0],[1,0.9,0.9,1]],[9,["a7VfsM1EtIErcrLNDR9BwQ"]],[9,["cciZlh/shKt7T+VcHngUXH"]],[34,"blackBg",false,1,1,[[2,-303,[0,"60/pQAV39G+Jl1LMK93jkn"],[5,2160,1080]],[61,0,-304,[0,"ddlrpXXuhFwJ5ZjCNXejew"],[4,2432696320],79],[25,45,100,100,-305,[0,"31XAyU5UdArKO70D8smFhV"]],[96,-306,[0,"5930ljvMFHXbo0G1LD8ea7"]]],[1,"60tNcl60FK4oulcfVnHg04",1,0]],[24,"beij",4,4,[[[8,-307,[0,"a0rNFjWnpBAaUGSK8AokzG"],[5,2611,255],[0,0,0]],-308,[128,12,294.924,804,-10.751000000000005,-309,[0,"cfq3Uw1PBBNp0UVfB4ga7N"]]],4,1,4],[1,"b7GO8+UdBLN6BBp7fbRZri",1,0],[1,294.924,804,0]],[11,"river_layer",8388608,3,[[8,-310,[0,"27NNP/8zNLaJV9+JT3ZQBw"],[5,2508,2508],[0,0,0]],[26,16,346,-311,[0,"b9yZo6GABHDKWgksjvI0ut"]]],[1,"61CUIARfZHIpSAx+jiOXND",1,0]],[11,"under_tank_layer",8388608,3,[[8,-312,[0,"ea1+Kxhi9KHb4lGMWPZp8r"],[5,2508,2508],[0,0,0]],[26,16,346,-313,[0,"1bMEvOi+dDb6kCwuOtEd9A"]]],[1,"f69uIdBmlCUqeokl8llCtA",1,0]],[11,"bullet_layer",8388608,3,[[8,-314,[0,"d4KMTKn2FGTrdjO7OmydEL"],[5,2508,2508],[0,0,0]],[26,16,346,-315,[0,"56zLU2W1BIdYeGbVnAMlSj"]]],[1,"11hg95pUZFUaCfd/gjlL1A",1,0]],[11,"upside_tank_layer",8388608,3,[[8,-316,[0,"e2jpfuX5xCm4zFveZyHKwM"],[5,2508,2508],[0,0,0]],[26,16,346,-317,[0,"27IX7KnCFLMJOjTxIp6Pk9"]]],[1,"886hYlTqJOU77lDxMuLOF7",1,0]],[77,"Extra Score s",false,8388608,3,[[2,-318,[0,"5eiq0VFBpA/49aK/N2975U"],[5,148,107]],[6,-319,[0,"611tWnfv5JhaAGqKHMQpUH"],5]],[1,"d4XdTpldlI2KDZiqNYpPwB",1,0],[1,1258.222,1281.96,0]],[34,"Extra Score shizi",false,8388608,3,[[2,-320,[0,"dc8r4kVEtMMJi9HqtFa7gs"],[5,145,108]],[6,-321,[0,"91Ymq3HzlON4c51XPOK96A"],6]],[1,"18vCWiYHpDFLjHSnzrwljg",1,0]],[24,"bg3",4,4,[[[8,-322,[0,"2e5ifqaCxICK2MVDW2MZPc"],[5,3229,1057],[0,0,0]],-323,[129,20,4201.5,2,1059,-324,[0,"c1pt7cK19BUaHNaIqKXkTT"]]],4,1,4],[1,"cd7SF7i35HY7LswV8bI0Nc",1,0],[1,0,2,0]],[4,"stan",2,4,[[8,-325,[0,"2eJJT8sHlJuqhwGC+Z2gsk"],[5,976,203],[0,0,1]],[153,0,-326,[0,"c4uB8eH+RL14SI48aVXQL6"]]],[1,"b6oVzkXy1NmIv6YDp13Zco",1,0],[1,1210,824.808,0]],[23,"joystickBG",1,14,[-329],[[2,-327,[0,"f7NISe7HdAD68SLfhnddy8"],[5,268,268]],[15,0,-328,[0,"e71ctEmpxFC4KlSYRZNz/a"],13]],[1,"9fp9nA6RNMgYyk8/HjsFqr",1,0]],[11,"joystick",1,14,[[2,-330,[0,"f7NISe7HdAD68SLfhnddy8"],[5,153,154]],[15,0,-331,[0,"e71ctEmpxFC4KlSYRZNz/a"],14]],[1,"c37kn5grJDpal647fjtsem",1,0]],[11,"arrow",1,14,[[8,-332,[0,"05F61W6hRGbL0U8mP8SRU9"],[5,56,23],[0,0.5,-6.5]],[6,-333,[0,"8ceW1B6TVO3IDum/eTTv/r"],15]],[1,"cd1fou0aJO5pbiBHYm/vGe",1,0]],[11,"joystick",1,19,[[2,-334,[0,"8ancPTzmpP+qutQ61Fnl8H"],[5,153,154]],[15,0,-335,[0,"2exRcERWVHIpKrX3Bx3d0q"],18],[31,100,-336,[0,"d01wbG+HlKCoHcsbJV+Lwf"]]],[1,"b6jMN5OyhLRZ9k+v/pyPTk",1,0]],[23,"joystickBG",1,20,[-339],[[2,-337,[0,"b9IUzRHv9LdLDIc+LxiZu/"],[5,268,268]],[15,0,-338,[0,"c8wnA/9mZOo5BkwHxf9uWW"],20]],[1,"64EfpogktK3ZugClpA0LnB",1,0]],[11,"joystick",1,20,[[2,-340,[0,"0e45ECZPBDi4v3OF+xeNxM"],[5,152,153]],[15,0,-341,[0,"3fF8aBD5FOypO5T0u3kH8U"],21]],[1,"c3pI2iv8hAZrzTn1r5wpNp",1,0]],[11,"joystick",1,21,[[2,-342,[0,"b4wVSpCTVLrbqvqP3e5pXH"],[5,152,153]],[15,0,-343,[0,"54MKXdSEJEn4LhI/Txqb5S"],24],[31,100,-344,[0,"8e2lscltZNxqEhZyKxh26p"]]],[1,"5b/rfjKSxJzrQQPVJ1WhHY",1,0]],[4,"emoji0",1,5,[[2,-345,[0,"690hweQKBJEZAj/0WvjFWE"],[5,86,86]],[6,-346,[0,"daBqUhkNxMkLLr5/TJLo1W"],29],[64,3,1.1,-347,[0,"78/OJ8walJs6cIw5TtlwJn"],30]],[1,"d6pYGoj5NOgrs6tThYCbpI",1,0],[1,0,144,0]],[4,"emoji1",1,5,[[2,-348,[0,"f00Rx/kRlG7qy99Gj0waK2"],[5,86,86]],[6,-349,[0,"6dUm/gD3hF2JNIE92Gjcu7"],31],[64,3,1.1,-350,[0,"1aqvd3oDVEsr8kDlyl9BwE"],32]],[1,"35ky6qjj9Mp7vXKHSa99dU",1,0],[1,0,48,0]],[4,"emoji2",1,5,[[2,-351,[0,"6a/Iq/FzlHDLwKUqTakgR+"],[5,86,86]],[6,-352,[0,"559u6hFZdPoLroampoO1Vx"],33],[64,3,1.1,-353,[0,"3cZta9TahNHrwWhNSZopjn"],34]],[1,"9bgV0VF69L47rPUsYPa1P5",1,0],[1,0,-48,0]],[4,"emoji3",1,5,[[2,-354,[0,"62zmjKPtxFv6G3ys7vzoTs"],[5,86,86]],[6,-355,[0,"a9zwQHGvdNzZ49hq9ADDSL"],35],[64,3,1.1,-356,[0,"a0T1bmUfBFhanW1JnHkuCw"],36]],[1,"eb+z08ELpL1I725rxw3eiP",1,0],[1,0,-144,0]],[34,"Node",false,1,11,[[2,-357,[0,"0eljF2oJ1LuLqBBBw1qBAx"],[5,2160,1080]],[61,0,-358,[0,"8bhQ/v/xNOlZAGQwVxUElx"],[4,2348810240],39],[25,45,2,2,-359,[0,"63KXegsOBOnZXUkGSthcfg"]]],[1,"6bGXhAth5EKaRtNtB2VZOW",1,0]],[13,"djs",1,15,[-362],[[2,-360,[0,"13hEyXeANNrp0+t5uPrmGU"],[5,226,232]],[6,-361,[0,"198yQrkIFOJI2YrFE212gz"],47]],[1,"dazMVr7WZOFL9D+jerBRpX",1,0],[1,0,-65.75,0]],[9,["1bbT5FXpFMfJpUcck/eJ2+"]],[20,"LeftFinger",1,8,[[8,-363,[0,"efmtv9fE1C8bxqyOe01rfu"],[5,201,245],[0,0.11,0.96]],[6,-364,[0,"f4VyDCHfZF/b7/3Pu8o1Sm"],56]],[1,"edBKkiFtNH5pM9U54mwDIu",1,0],[1,-725.63,-302.11199999999997,0],[1,-1,1,1]],[4,"RightFinger",1,8,[[8,-365,[0,"f2lDwbTiZOQKCmJ1vHUlwk"],[5,201,245],[0,0.11,0.96]],[6,-366,[0,"16wx0lswZCxbVzHxzt7COu"],57]],[1,"91GTb2wTxDVJUBhizg+z8t",1,0],[1,-725.63,-302.11199999999997,0]],[11,"Node",1,26,[[2,-367,[0,"83C2DLb0xAwYXiH/6WXM04"],[5,0,110]],[32,1,0,-368,[0,"2fu2BuS5lFOZf5uufjGM/g"],58],[18,-369,[0,"ffVwlj671K6YJ5x0YMhZWh"]]],[1,"4eNnl0ngdGZ4nR3Kf6sgKM",1,0]],[4,"tipLabel",1,26,[[2,-370,[0,"eeaTxAS0ZK16NB3cvD9BUp"],[5,0,75.6]],[130,18,3.5,1.685,-371,[0,"b1D5nvX0FKmraEyo0TWqQF"]],[173,60,"",1,1,50,false,-372,[0,"28fbNMNn1F84DdoyoK3svf"],59,60]],[1,"20nFL1oddAoIGmni6k+3Cw",1,0],[1,0,1.685,0]],[34,"quan",false,1,8,[[2,-373,[0,"c9Ih/DdpZPAaR4NqFCA8eY"],[5,76,76]],[6,-374,[0,"cawnKQJttIZJuXcHrqNCos"],67]],[1,"00eq81VBNCwb1HHMr0IRoS",1,0]],[4,"arial_font",1,7,[[2,-375,[0,"e4hMnWaoJH8I6/b6i2Elby"],[5,95.53,52.1]],[73,"Score",35,35,35,false,-376,[0,"71zHwQVJhNZpoZrvYowU5z"],69],[100,4,-377,[0,"d9SFctrhNONLfK3opXMRL2"]]],[1,"56kFsYQ29DSI63SJtHcAaN",1,0],[1,0,-19.745,0]],[4,"Arrows",1,7,[[2,-378,[0,"f4pb4JTnhKxbD1aShTYs+u"],[5,28,13]],[6,-379,[0,"b5DaiXNTNEO4KPlTEklYJ9"],71],[131,4,5,1,-380,[0,"b7u9jgnaJJRpiSn6y26ibY"]]],[1,"e9/abq3MBH9qoY0zU+5ohZ",1,0],[1,0,-58.5,0]],[13,"rank",1,17,[-383],[[2,-381,[0,"6aVq+1rplC2azeWJ/AVH/T"],[5,46,46]],[26,8,8,-382,[0,"21rTcr6itJ3r7OsFnAGCAB"]]],[1,"3fHc0LKIBGh4PWVU4OWZfg",1,0],[1,-99,0,0]],[20,"MultiScoreRank_Graphics",1,1,[[8,-384,[0,"446IC/o6tLe6nrFxA+ebbF"],[5,260,115],[0,0.5,1]],[86,33,1689.864,164,50,-385,[0,"afoaAgzNxABYJgneEFrOj/"]],[174,5,5,-386,[0,"a0j5t3bmtOhbqMxDD76Fyu"],[4,4278255615],[4,16777215]]],[1,"3cZZ0i+AJOxaNWX0uiuxxP",1,0],[1,760,490,0],[1,1.2,1.2,1.2]],[77,"DebugLabel",false,1,1,[[8,-387,[0,"5fmCvRA2dH0roZrTzzaeVZ"],[5,84.51,50.4],[0,0,0.5]],[167,40,-388,[0,"2fadoxv1dL1rJFMlglBrGt"]],[68,9,36.944999999999936,237.41700000000003,-389,[0,"6504pBB9NNiYuc/grySitE"]]],[1,"68dK18OvJM8JS3oZqaQnyp",1,0],[1,-1043.055,277.383,0]],[4,"ground l",4,2,[[2,-390,[0,"f0uontjY1GaIcI2//6dXRK"],[5,512,512]],[5,-391,[0,"83hWt3oHZMcayYZ6C7hBMC"]]],[1,"9cIPaE175Ei7Lucer5jIW6",1,0],[1,-1344,1394,0]],[4,"ground l-001",4,2,[[2,-392,[0,"55Mg9PAcFPTbEoEs+QqZyn"],[5,512,512]],[5,-393,[0,"f0v4Nai6RCrKvciU95VQlJ"]]],[1,"abbctcUfZOlbH2I8o1fDyj",1,0],[1,-834,1394,0]],[4,"ground l-002",4,2,[[2,-394,[0,"88aDZeZ2FFy48JwnNUOvO1"],[5,512,512]],[5,-395,[0,"79ifdSSTFBNarjEhcj6UDN"]]],[1,"53OBF3ijtNcIWm7Lzt+4Qq",1,0],[1,-324,1394,0]],[4,"ground l-003",4,2,[[2,-396,[0,"5ehXBMOkND4KEm7tQ8nT+s"],[5,512,512]],[5,-397,[0,"feGtIuMfxOv6x8ji6DSq6p"]]],[1,"f9ti4MABdHmZzXtwWtaeoV",1,0],[1,186,1394,0]],[4,"ground l-004",4,2,[[2,-398,[0,"703LZrEXxH4YQb76eiWMUM"],[5,512,512]],[5,-399,[0,"17Vmonax1D95eNcXhG3yt2"]]],[1,"bdj0hR3bJFJ4no/Vnpamie",1,0],[1,696,1394,0]],[4,"ground l-005",4,2,[[2,-400,[0,"96DatNL2pEdIN02Q9ZGgE9"],[5,512,512]],[5,-401,[0,"2cbll05CRLo5HB9ZyIwgeF"]]],[1,"8ahRnQNzlKirNq3aJu2WQi",1,0],[1,1206,1394,0]],[4,"ground l-006",4,2,[[2,-402,[0,"b5YBoX7XpOK4PL9dDJgiFc"],[5,512,512]],[5,-403,[0,"fe26OSRtpIDIaiZ5BWmeIt"]]],[1,"480/ae6z5BGq7TBGlz18yx",1,0],[1,-1344,884,0]],[4,"ground l-007",4,2,[[2,-404,[0,"90ysgjET9BpoT7L78POmbP"],[5,512,512]],[5,-405,[0,"a8oNcB7uVNZJeozDXSJjxR"]]],[1,"a81y+aS7lP/7mWXuwnrZqh",1,0],[1,-834,884,0]],[4,"ground l-008",4,2,[[2,-406,[0,"5eKUQGMPhD8bNRdqlFucXL"],[5,512,512]],[5,-407,[0,"d95RMix41KF74Uv8RpZFc0"]]],[1,"abvdlzsCpAnb8H4ej0FTXb",1,0],[1,-324,884,0]],[4,"ground l-009",4,2,[[2,-408,[0,"02lDyDAnhKS6ok6JGaXfOK"],[5,512,512]],[5,-409,[0,"6awVqfLLpOmLi05ZwT8p76"]]],[1,"e6YhORh3FCjKpZ5ZmQ+K6q",1,0],[1,186,884,0]],[4,"ground l-010",4,2,[[2,-410,[0,"d02ZpwDtBFN6hfzzFR99sL"],[5,512,512]],[5,-411,[0,"e3wFgbCndGkYUrMu+p+LpN"]]],[1,"0cNMg4W69Me7lSdiWxLa+1",1,0],[1,696,884,0]],[4,"ground l-011",4,2,[[2,-412,[0,"81KqtRVBJEq5y5un1mQXoK"],[5,512,512]],[5,-413,[0,"7eNoHhTl1NtKvCYWnv9h+X"]]],[1,"a5g8mYBl1Bfob5wAIVq+lf",1,0],[1,1206,884,0]],[4,"ground l-012",4,2,[[2,-414,[0,"fczM/7wPlDPaj6MjAQlSDa"],[5,512,512]],[5,-415,[0,"eaicLiQLFCDIAYg1rF9H6J"]]],[1,"c2CN/PI2dPo5HGxFLrePcu",1,0],[1,-1344,374,0]],[4,"ground l-013",4,2,[[2,-416,[0,"56SCFnZwxJCp24U1E/xBxI"],[5,512,512]],[5,-417,[0,"87Lk1Q+ZRFEKPGwnpGfw+T"]]],[1,"c97WbRsCNNOLIJVgUBw8Gi",1,0],[1,-834,374,0]],[4,"ground l-014",4,2,[[2,-418,[0,"baEOXqGM5P4ribyEcIc9v9"],[5,512,512]],[5,-419,[0,"0bMWrVnnpHRomNWEohgdxz"]]],[1,"a4fVEhsoVKLax71hJ4tDyP",1,0],[1,-324,374,0]],[4,"ground l-015",4,2,[[2,-420,[0,"e63Ua3jLhL3agmCjjW854p"],[5,512,512]],[5,-421,[0,"2c+5zbw2JDmp1jXzmqU9dF"]]],[1,"8ajCVpyQxE2ZT73zCNaxMG",1,0],[1,186,374,0]],[4,"ground l-016",4,2,[[2,-422,[0,"308EyD25tI4InKuqaHjjpi"],[5,512,512]],[5,-423,[0,"d1gqSdjmNFBITLOZcv0INS"]]],[1,"85rzRdg0VOeLjeQWhpu0E4",1,0],[1,696,374,0]],[4,"ground l-017",4,2,[[2,-424,[0,"83U6oAFoFElqnOBnbq2lwy"],[5,512,512]],[5,-425,[0,"21w26xXBxI6q65GMtw1APM"]]],[1,"c08/tIK41LvbK3CucAIrHV",1,0],[1,1206,374,0]],[4,"ground l-018",4,2,[[2,-426,[0,"ebqKwMhQFBJpZSfVLZyXKR"],[5,512,512]],[5,-427,[0,"ddP5uF16JO1qL5XHow+UZ8"]]],[1,"d0/ukBN3RHgLkx7r/Ft3m7",1,0],[1,-1344,-136,0]],[4,"ground l-019",4,2,[[2,-428,[0,"1495U6uoFMOoT379hjcGpL"],[5,512,512]],[5,-429,[0,"b9W2u5LwNA0ItnLKHL0aof"]]],[1,"76iU/5L4BDX4v94VMaw88B",1,0],[1,-834,-136,0]],[4,"ground l-020",4,2,[[2,-430,[0,"193FTLZ19PdLadc2qUQtJ6"],[5,512,512]],[5,-431,[0,"a76KnHRtpPMZWWo9RstIOs"]]],[1,"d78QwU1DNLA6w6DFziS/W2",1,0],[1,-324,-136,0]],[4,"ground l-021",4,2,[[2,-432,[0,"2er9CmLnRO8I+EBcvaA0Wq"],[5,512,512]],[5,-433,[0,"ce/18cBgdENr7Qm6iFH1Qm"]]],[1,"a38lgtfjNCCZme1PG70Bih",1,0],[1,186,-136,0]],[4,"ground l-022",4,2,[[2,-434,[0,"9f8/7DwFVL3qsO6sroONss"],[5,512,512]],[5,-435,[0,"fbG/58BKBHV6PQ9GO9YSZ9"]]],[1,"8bnLQG4wpOqpnAsHJFOtMU",1,0],[1,696,-136,0]],[4,"ground l-023",4,2,[[2,-436,[0,"34sR2OCzlLgLg6hwRAvk4B"],[5,512,512]],[5,-437,[0,"1f2hRc4zJDr6r8/V3z5xRo"]]],[1,"b6/1NVJPxEV4GpFZBUGG2M",1,0],[1,1206,-136,0]],[4,"ground l-024",4,2,[[2,-438,[0,"259kSsyTFBV7g5hYcZ+fg6"],[5,512,512]],[5,-439,[0,"43/wqGVgZPnIMtL3WeugFj"]]],[1,"32xXF2thlCV6rAtgubBAmm",1,0],[1,-1344,-646,0]],[4,"ground l-025",4,2,[[2,-440,[0,"fdcYSpQNJFq4HriEirRH4F"],[5,512,512]],[5,-441,[0,"39V1QAPpBJjaBCmUoUeOjN"]]],[1,"7caLY16KxLk5URpIHWv/yu",1,0],[1,-834,-646,0]],[4,"ground l-026",4,2,[[2,-442,[0,"bb/e1k+ppDPJdccR7wKjJT"],[5,512,512]],[5,-443,[0,"e1UvBGlCNFTIYV+l1TETvo"]]],[1,"f5o4g+e4lD66d2pKRua/aw",1,0],[1,-324,-646,0]],[4,"ground l-027",4,2,[[2,-444,[0,"bfbwwvaF5DrqcQKMiKMgGq"],[5,512,512]],[5,-445,[0,"86trA/DA1GILPRoKg1nNqW"]]],[1,"5dD4U20AdLpZqG5XU1YU01",1,0],[1,186,-646,0]],[4,"ground l-028",4,2,[[2,-446,[0,"4cImtZMO9AiLvSAiuqSJUE"],[5,512,512]],[5,-447,[0,"66zSfLUm5P4IUqGCo09oqF"]]],[1,"a4fhhA2aRNL5LlpJ2cw6E2",1,0],[1,696,-646,0]],[4,"ground l-029",4,2,[[2,-448,[0,"01XaOy0z5Ntb/ZN4r9doBR"],[5,512,512]],[5,-449,[0,"a5i3SPYihBrJMUSa2kWGoW"]]],[1,"753ARJe6BDHocf4rHhGnKN",1,0],[1,1206,-646,0]],[4,"ground l-030",4,2,[[2,-450,[0,"e923VNV8RN35j+2dlewKct"],[5,512,512]],[5,-451,[0,"48PWz5oIFDWbXvVQVBNbyr"]]],[1,"5axQjfr7ROULpi/7UkIutQ",1,0],[1,-1344,-1156,0]],[4,"ground l-031",4,2,[[2,-452,[0,"19eQTphAJAnIr7J3RPm1By"],[5,512,512]],[5,-453,[0,"fcRuqQP6REPKsuWwlQe6pb"]]],[1,"61ugeCWk9K44gyFt2Ae+rr",1,0],[1,-834,-1156,0]],[4,"ground l-032",4,2,[[2,-454,[0,"cch6bZMTpGjY5GtQmOPyZh"],[5,512,512]],[5,-455,[0,"67BUPbdAhCJbmsdyXVoVOw"]]],[1,"92F/ylXSRB1ZbC5m/5l1YC",1,0],[1,-324,-1156,0]],[4,"ground l-033",4,2,[[2,-456,[0,"7dvNFjiABIUKYMPLhG+0fz"],[5,512,512]],[5,-457,[0,"2eJ3qldR9BE46koyxiQaec"]]],[1,"b6v0bBLvpPia7mx345JHxk",1,0],[1,186,-1156,0]],[4,"ground l-034",4,2,[[2,-458,[0,"87J+9PNqVN2b9f5kTgQDXV"],[5,512,512]],[5,-459,[0,"0fGTq1PIRKi5RlQt6hqyFb"]]],[1,"69z8uDxDxFbKnSwfCdDkn/",1,0],[1,696,-1156,0]],[4,"ground l-035",4,2,[[2,-460,[0,"f6xJkZTo1Deb0QwOG1fn6K"],[5,512,512]],[5,-461,[0,"abGDNgP6BHQbrr8MRp7SxG"]]],[1,"90utOFIH9Oq6jc2Pqf/TCZ",1,0],[1,1206,-1156,0]],[24,"bg1",4,4,[[[8,-462,[0,"f7NISe7HdAD68SLfhnddy8"],[5,3229,1640],[0,0,0]],-463],4,1],[1,"eeSfukRYhKDaW4R38lS/yg",1,0],[1,0,3089,0]],[24,"bg2",4,4,[[[8,-464,[0,"f7NISe7HdAD68SLfhnddy8"],[5,3229,2030],[0,0,0]],-465],4,1],[1,"a33+v+yrZEmom1ny/ucRQF",1,0],[1,0,1059,0]],[4,"upWall",8388608,13,[[2,-466,[0,"7ejMf4EWRJKLy4h77qHNKI"],[5,3000,100]],[62,false,0,-467,[0,"32rfA5Ea9C6KXIyOcFDRPf"],0]],[1,"55qnWawrBL3pxEIZI/Slw8",1,0],[1,1254,2560,0]],[4,"bottomWall",8388608,13,[[2,-468,[0,"d47N1oThRGZIjCIvMUzq4x"],[5,3000,100]],[62,false,0,-469,[0,"1cdmNfcq9OrKaXRA3VKMdS"],1]],[1,"80Fbdok/FOXqB8bRPlHY8G",1,0],[1,1254,-60,0]],[78,"leftWall",8388608,13,[[2,-470,[0,"afIj0Lq8xN2qhHUpuc6z25"],[5,3000,100]],[62,false,0,-471,[0,"27lLBBadBP3IC/+kUzlf9W"],2]],[1,"fbUY82Q6tFyqon862kW6ts",1,0],[1,-85,1350,0],[3,0,0,-0.7071067811865475,0.7071067811865476],[1,0,0,-90]],[78,"rightWall",8388608,13,[[2,-472,[0,"69y8LrVRxNC52hLlsrwUq1"],[5,3000,100]],[62,false,0,-473,[0,"78wALZ4xlAUrcmL97TzqkN"],3]],[1,"3bac1kpjZCcokCY9bUbERm",1,0],[1,2570,1350,0],[3,0,0,0.7071067811865475,0.7071067811865476],[1,0,0,90]],[11,"tank_info_layer",8388608,3,[[8,-474,[0,"6eo3lXJt5MH7HmXVQC0CHn"],[5,2508,2508],[0,0,0]],[26,16,346,-475,[0,"4cZLAZaX1CxoXwUVxLnltN"]]],[1,"a1yTS8XSlLpIK04XALtSOf",1,0]],[34,"Cactus",false,2,4,[[8,-476,[0,"96v4W4vSNKJa91CMcpo9Iq"],[5,3227,3796],[0,0,0]],[6,-477,[0,"1ejUDEo/9KLZft0WVi3k6z"],7]],[1,"45g5DrlY5Gnr9CliWLXpSd",1,0]],[4,"01Backgroundy_1",4,18,[[2,-478,[0,"8dRuCK5GZIxZ5QNoPDbYwg"],[5,200,2365]],[91,false,-479,[0,"6dxA1mkH1HHKuCZNXI+Hvs"],8]],[1,"d9J7lJ5KlAV7sydmfVN77G",1,0],[1,3328,3546.5,0]],[4,"01Backgroundy_2",4,18,[[2,-480,[0,"7bbW0ePTBH+pboCknKqzjz"],[5,200,2366]],[91,false,-481,[0,"33Uk1Ev95EOK5/FLYdrMXg"],9]],[1,"2dzWWlYmdJV6jhOP30UP38",1,0],[1,3328,1181,0]],[4,"01Backgroundz_1",4,18,[[2,-482,[0,"64YEOXFyNHropfcl3Oy63G"],[5,200,2365]],[6,-483,[0,"cc38sapxpOlpNodPwsXals"],10]],[1,"2av4LbOFRJy4QHgpcv0O2I",1,0],[1,-100,3546.5,0]],[4,"01Backgroundz_2",4,18,[[2,-484,[0,"5anPBl+WFL+KeI9O8v/wum"],[5,200,2366]],[6,-485,[0,"64TQIXBihNOYd7+fkZ52K8"],11]],[1,"caVcB9qG1DV5EfrO/w8NPi",1,0],[1,-100,1181,0]],[11,"area",1,9,[[8,-486,[0,"3fknMyvftJ+IQJozfb4JdM"],[5,1080,1080],[0,0,0]],[25,45,750,1334,-487,[0,"36HOfm8RdEiZ/Uuho12Abi"]]],[1,"aeatNgZ9VCHZy9sgi+wI1J",1,0]],[11," Direction  Triangle",1,48,[[2,-488,[0,"baQ16K0M5H57PCuKkYtRP5"],[5,218,218]],[6,-489,[0,"8bcDbCJRBISpG7lY7OMgk5"],12]],[1,"a8MMxHhEdMmLQQ1Idu6OjO",1,0]],[11," Direction  Triangle",1,31,[[2,-490,[0,"63UWb9jBlGO7uwFRl8f7R5"],[5,218,218]],[6,-491,[0,"54JrjuV+dG5rgpazuE5Tsb"],16]],[1,"76drj6rqhLiZ51RWoSntL1",1,0]],[175,1,60,9,[0,"d1cY2trlZNDZXp6RfhFjec"],49,14,19,50],[11,"area",1,10,[[8,-492,[0,"4drV14GklEYYEiCURqTUEM"],[5,1080,1080],[0,0,0]],[25,45,750,1334,-493,[0,"33E3Dnzw5CTYWP2aif+LDJ"]]],[1,"a3M9OFWd5LTYWp+se4yPhm",1,0]],[11,"Triangle",1,52,[[2,-494,[0,"83zgYeZ8lLrqMMO/Sya/H+"],[5,217,218]],[6,-495,[0,"9dmN+a7h9OJLhrSi4DQLFE"],19]],[1,"f88IiYs5xJTa360um8+/yU",1,0]],[11,"Triangle",1,32,[[2,-496,[0,"eeM5MiEMBCoY/PtKVsKK5g"],[5,217,218]],[6,-497,[0,"e1CwXDKMdMOZfSAYplhakD"],22]],[1,"7fGk4uwl1KsJRnFmeqC+q2",1,0]],[176,1,134,20,10,[0,"84wxhe2FNM07UQY/mujTNk"],53,20,21],[34,"READY",false,1,11,[[2,-498,[0,"2fD7jaPCVHirTbC865U29Q"],[5,442,131]],[6,-499,[0,"3acF9pL3FAS7JIKX0BkX4H"],40]],[1,"ac9NzrLl9G3owKu/mZEzde",1,0]],[4,"Flags",1,33,[[2,-500,[0,"70bYfBW7RM0qO/FI0VLhQc"],[5,139,112]],[6,-501,[0,"a0dJdjTftKR6cjxATFuu9x"],41]],[1,"b13KGHK/dNZYbneXRvb7Ao",1,0],[1,0,92.34,0]],[4,"go",1,33,[[2,-502,[0,"822ISbvfRPSYlrJ/vO/1Sb"],[5,198,132]],[6,-503,[0,"3eDmF+NotO5KUuBGxAHrNz"],42]],[1,"c5HFw+77xDOJ4Ohl0qLi8v",1,0],[1,0,-4.806,0]],[4,"Revive Time",1,15,[[2,-504,[0,"5byIyaDipKrKC+D80pRd5X"],[5,643,107]],[6,-505,[0,"4as3FzJ0ZClo+YRY0mRkXk"],45]],[1,"b9Y3iaGr1H+J8ipm72nKyE",1,0],[1,0,158.499,0]],[4,"timeDownlabel",1,60,[[2,-506,[0,"8cXUTKFQtPbL3MCpnMcIx8"],[5,0,120]],[73,"",120,120,120,false,-507,[0,"2cDrFp7uxL8Yifk9l1UgWm"],46]],[1,"b6I95dI9ZD/qAucZtUhoJU",1,0],[1,0,14.564,0]],[4,"ping",1,16,[[2,-508,[0,"580bwKma5KVIhOalH/51Ai"],[5,168.75,80]],[168,"ping",80,80,80,false,-509,[0,"a0j3vJL8JFb47DYyLq8jSX"],[4,4278190080],53]],[1,"981z4QVOtItYD/NLiMPREM",1,0],[1,190.648,119,0]],[24,"pingNum",1,16,[[[2,-510,[0,"83zZKqEORDiKOFVPGDEUgT"],[5,59.38,100]],-511],4,1],[1,"1bJbJA2/NN6KluBn/I6uvM",1,0],[1,190.338,0,0]],[9,["980Q9M9ABGEoO/XCAtC7eB"]],[9,["02iAH9OJRHnaRs0DgUX1Xq"]],[4,"Label",1,12,[[2,-512,[0,"e0alCV7rtLYZIVeeT0enik"],[5,200,80]],[169,"SKIP",60,60,60,1,false,false,-513,[0,"27dyoDiKBCTZE6bShE6LQj"],61]],[1,"c6VTazmo5LzaMORR1dWBup",1,0],[1,0,1.022,0]],[4,"Personal Score t",1,7,[[2,-514,[0,"96V6RB07VM2r/E2rZydGCg"],[5,260,1]],[15,0,-515,[0,"0fwuh7AcZJO7veYt48XhL3"],70]],[1,"75MMUaFm1DN613T2nS2Wda",1,0],[1,0,-44.065,0]],[4,"content",1,7,[[8,-516,[0,"1dm4BlBo1LfpBniIUDCaY3"],[5,260,40],[0,0.5,1]],[159,1,2,10,-517,[0,"9d1h4eyplHTatyOXW+zeSX"]]],[1,"f8oL87Qy9DI4/xFGVsKaEq",1,0],[1,0,-50,0]],[24,"rank",1,69,[[[2,-518,[0,"cc8qAxyAJGT7H4W1frt5QZ"],[5,46,46]],-519],4,1],[1,"eeHdaZSEtNQYpuTx9Q7pD7",1,0],[1,1.393000000000029,0,0]],[24,"nickName",1,17,[[[2,-520,[0,"56bTXw2RdCdZWib9G4DRRH"],[5,0,31.5]],-521],4,1],[1,"795Vd8XwBIt5yT4BdVJcgf",1,0],[1,6.372,0,0]],[24,"scoreLabel",1,17,[[[8,-522,[0,"eealDtzBNIPY3T6ftQto8H"],[5,0,40],[0,0,0.5]],-523],4,1],[1,"66KUQKRLRPHaWoa4qiSiKM",1,0],[1,84.21800000000002,0,0]],[79,"Label",512,1,27,[[2,-524,[0,"9cqRztMEtLwYHg8L1zntTT"],[5,200,50]],[97,"Player1",40,1,false,-525,[0,"7frhutYDFNPakfs4n0YF7U"],[4,4278190080]]],[1,"dfaBeaCAdLm4wwCUaD1clu",1,0]],[79,"Label",512,1,28,[[2,-526,[0,"d47S8i+jZMSopAwM/PfbX5"],[5,200,50]],[97,"Player2",40,1,false,-527,[0,"e0dnyR1UNMdbZkfmt8/J/i"],[4,4278190080]]],[1,"36V6vhwltNVLhHBY6dEEry",1,0]],[5,39,[0,"b6MPOrlNZDS7xEkr6vdhtN"]],[154,108],[5,109,[0,"e71ctEmpxFC4KlSYRZNz/a"]],[5,46,[0,"dfbnz6lHNOCY8H/InERvVe"]],[177,4,[0,"41+K6SzhlDc6kzIfm8LSYG"],3,40,30,41,43,2,146,147,148,145,47],[98,"0",100,100,100,false,134,[0,"a0V3tEnUZM9o4H3tyRznq/"],[4,4280427263]],[9,["66WFhxfJJF3K7rck/0maW1"]],[9,["92epLLHlFP+7KJW0Ac2s8D"]],[9,["efYoglfu1B+63jcsGuqT7J"]],[5,140,[0,"d1gZj4Z+dPx6S0zhbig8Vm"]],[178,25,25,25,false,130,141,[0,"95y/DOd9dDea8IabQfglus"],[4,4294761663]],[170,"",30,30,false,true,142,[0,"f24r/HarxKn7aCYm182SSm"]],[105,"Directional Light",512,1,[[179,-528,[0,"8aCkOP9PFLDLqO2Qeb4Up2"],[180]]],[1,"a0GUCDFqxMt5dK7nQEou5Y",1,0]]],0,[0,-1,6,0,15,6,0,16,6,0,15,6,0,16,6,0,15,6,0,16,6,0,15,6,0,16,6,0,4,1,0,24,45,0,25,44,0,41,17,0,42,7,0,43,6,0,44,15,0,26,127,0,27,123,0,45,149,0,46,42,0,47,30,0,48,3,0,0,1,0,0,1,0,0,1,0,28,150,0,49,5,0,50,23,0,0,1,0,-1,4,0,-2,9,0,-3,10,0,-4,22,0,-5,23,0,-6,5,0,-7,11,0,-8,15,0,-9,24,0,-10,16,0,-11,6,0,-12,8,0,-13,157,0,-14,25,0,-15,38,0,-16,70,0,-17,7,0,-18,27,0,-19,28,0,-20,71,0,0,2,0,0,2,0,0,2,0,-1,72,0,-2,73,0,-3,74,0,-4,75,0,-5,76,0,-6,77,0,-7,78,0,-8,79,0,-9,80,0,-10,81,0,-11,82,0,-12,83,0,-13,84,0,-14,85,0,-15,86,0,-16,87,0,-17,88,0,-18,89,0,-19,90,0,-20,91,0,-21,92,0,-22,93,0,-23,94,0,-24,95,0,-25,96,0,-26,97,0,-27,98,0,-28,99,0,-29,100,0,-30,101,0,-31,102,0,-32,103,0,-33,104,0,-34,105,0,-35,106,0,-36,107,0,0,3,0,0,3,0,-1,13,0,-2,29,0,-3,40,0,-4,41,0,-5,30,0,-6,42,0,-7,43,0,-8,114,0,-9,44,0,-10,45,0,-1,149,0,0,4,0,0,4,0,-2,39,0,-3,108,0,-4,109,0,-6,46,0,-7,115,0,-8,47,0,-9,18,0,0,5,0,0,5,0,0,5,0,0,5,0,0,5,0,-1,55,0,-2,56,0,-3,57,0,-4,58,0,2,36,0,2,36,0,2,36,0,2,36,0,2,36,0,2,151,0,2,152,0,2,153,0,2,37,0,2,37,0,2,135,0,2,136,0,2,37,0,2,61,0,2,151,0,2,153,0,2,152,0,2,61,0,2,61,0,2,37,0,2,136,0,2,135,0,2,61,0,2,37,0,2,136,0,2,135,0,4,6,0,0,7,0,0,7,0,0,7,0,-1,67,0,-2,138,0,-3,68,0,-4,139,0,-5,17,0,0,8,0,51,29,0,52,66,0,28,16,0,53,12,0,54,22,0,55,63,0,56,62,0,26,127,0,27,123,0,57,11,0,0,8,0,0,8,0,-1,62,0,-2,63,0,-3,26,0,-4,12,0,-5,66,0,-1,123,0,0,9,0,0,9,0,0,9,0,-1,120,0,-2,14,0,-3,19,0,0,10,0,-2,127,0,0,10,0,0,10,0,-1,124,0,-2,20,0,-3,21,0,0,11,0,0,11,0,0,11,0,-1,59,0,-2,128,0,-3,33,0,0,12,0,0,12,0,18,12,0,0,12,0,0,12,0,-1,137,0,0,13,0,0,13,0,-1,110,0,-2,111,0,-3,112,0,-4,113,0,0,14,0,0,14,0,-1,48,0,-2,49,0,-3,50,0,0,15,0,0,15,0,-1,34,0,-2,131,0,-3,60,0,0,16,0,0,16,0,0,16,0,-1,133,0,-2,134,0,0,17,0,58,156,0,59,155,0,60,154,0,0,17,0,-1,69,0,-2,141,0,-3,142,0,0,18,0,-1,116,0,-2,117,0,-3,118,0,-4,119,0,0,19,0,0,19,0,-1,31,0,-2,51,0,0,20,0,0,20,0,-1,52,0,-2,53,0,0,21,0,0,21,0,-1,32,0,-2,54,0,0,22,0,0,22,0,0,22,0,0,22,0,0,23,0,0,23,0,0,23,0,0,23,0,0,24,0,61,25,0,62,35,0,0,24,0,0,24,0,0,24,0,-1,35,0,0,25,0,0,25,0,0,25,0,0,25,0,0,26,0,0,26,0,0,26,0,-1,64,0,-2,65,0,0,27,0,0,27,0,18,27,0,0,27,0,-1,143,0,0,28,0,0,28,0,18,28,0,0,28,0,-1,144,0,0,29,0,0,29,0,0,29,0,0,30,0,0,30,0,0,31,0,0,31,0,0,31,0,-1,122,0,0,32,0,0,32,0,0,32,0,-1,126,0,0,33,0,0,33,0,-1,129,0,-2,130,0,0,34,0,0,34,0,0,34,0,0,34,0,0,35,0,0,35,0,0,35,0,0,38,0,0,38,0,0,38,0,0,38,0,0,39,0,-2,145,0,0,39,0,0,40,0,0,40,0,0,41,0,0,41,0,0,42,0,0,42,0,0,43,0,0,43,0,0,44,0,0,44,0,0,45,0,0,45,0,0,46,0,-2,148,0,0,46,0,0,47,0,0,47,0,0,48,0,0,48,0,-1,121,0,0,49,0,0,49,0,0,50,0,0,50,0,0,51,0,0,51,0,0,51,0,0,52,0,0,52,0,-1,125,0,0,53,0,0,53,0,0,54,0,0,54,0,0,54,0,0,55,0,0,55,0,0,55,0,0,56,0,0,56,0,0,56,0,0,57,0,0,57,0,0,57,0,0,58,0,0,58,0,0,58,0,0,59,0,0,59,0,0,59,0,0,60,0,0,60,0,-1,132,0,0,62,0,0,62,0,0,63,0,0,63,0,0,64,0,0,64,0,0,64,0,0,65,0,0,65,0,0,65,0,0,66,0,0,66,0,0,67,0,0,67,0,0,67,0,0,68,0,0,68,0,0,68,0,0,69,0,0,69,0,-1,140,0,0,70,0,0,70,0,0,70,0,0,71,0,0,71,0,0,71,0,0,72,0,0,72,0,0,73,0,0,73,0,0,74,0,0,74,0,0,75,0,0,75,0,0,76,0,0,76,0,0,77,0,0,77,0,0,78,0,0,78,0,0,79,0,0,79,0,0,80,0,0,80,0,0,81,0,0,81,0,0,82,0,0,82,0,0,83,0,0,83,0,0,84,0,0,84,0,0,85,0,0,85,0,0,86,0,0,86,0,0,87,0,0,87,0,0,88,0,0,88,0,0,89,0,0,89,0,0,90,0,0,90,0,0,91,0,0,91,0,0,92,0,0,92,0,0,93,0,0,93,0,0,94,0,0,94,0,0,95,0,0,95,0,0,96,0,0,96,0,0,97,0,0,97,0,0,98,0,0,98,0,0,99,0,0,99,0,0,100,0,0,100,0,0,101,0,0,101,0,0,102,0,0,102,0,0,103,0,0,103,0,0,104,0,0,104,0,0,105,0,0,105,0,0,106,0,0,106,0,0,107,0,0,107,0,0,108,0,-2,146,0,0,109,0,-2,147,0,0,110,0,0,110,0,0,111,0,0,111,0,0,112,0,0,112,0,0,113,0,0,113,0,0,114,0,0,114,0,0,115,0,0,115,0,0,116,0,0,116,0,0,117,0,0,117,0,0,118,0,0,118,0,0,119,0,0,119,0,0,120,0,0,120,0,0,121,0,0,121,0,0,122,0,0,122,0,0,124,0,0,124,0,0,125,0,0,125,0,0,126,0,0,126,0,0,128,0,0,128,0,0,129,0,0,129,0,0,130,0,0,130,0,0,131,0,0,131,0,0,132,0,0,132,0,0,133,0,0,133,0,0,134,0,-2,150,0,0,137,0,0,137,0,0,138,0,0,138,0,0,139,0,0,139,0,0,140,0,-2,154,0,0,141,0,-2,155,0,0,142,0,-2,156,0,0,143,0,0,143,0,0,144,0,0,144,0,0,157,0,5,1,2,17,4,3,17,4,528],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,149,150,154,155,156],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,1,1,1,1,1,1,6,1,1,63,64,1,6,6,1,8,1,1,1,6,65,6,1,7,19,20,21,1,29,6,1,1,-1,-2,-3,-4,-5,-6,1,1,1,7,19,20,21,1,7,19,20,21,29,66,67,68,69,70,71,72,73,74,75,76,77,78,79,6,1,6,6],[0,0,0,0,87,31,32,88,89,90,91,92,33,34,35,93,33,34,35,36,37,38,36,37,38,39,39,12,12,7,7,13,13,14,14,15,15,40,40,30,94,95,96,97,0,98,99,100,101,41,102,103,41,8,104,105,42,42,106,9,9,9,43,43,1,16,17,107,44,45,108,46,47,109,110,111,112,113,114,0,1,1,1,16,17,1,1,1,16,17,44,115,116,117,118,119,120,121,122,123,46,124,12,125,126,8,47,45,8]],[[{"name":"default_sprite_splash","rect":{"x":0,"y":0,"width":2,"height":2},"offset":{"x":0,"y":0},"originalSize":{"width":2,"height":2},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[1],0,[0],[3],[127]],[[{"name":"Rocks3","rect":{"x":0,"y":0,"width":77,"height":66},"offset":{"x":0,"y":0},"originalSize":{"width":77,"height":66},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[1],0,[0],[3],[128]],[[[27,"base_explode",".plist"],-1],0,0,[0],[9],[20]],[[{"name":"bullet_sprite_frame","rect":{"x":3,"y":4,"width":15,"height":15},"offset":{"x":0,"y":-1},"originalSize":{"width":21,"height":21},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[1],0,[0],[3],[129]],[[{"name":"Rocks2","rect":{"x":0,"y":0,"width":77,"height":66},"offset":{"x":0,"y":0},"originalSize":{"width":77,"height":66},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[1],0,[0],[3],[130]],[[{"name":"default_btn_disabled","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"packable":true}],[1],0,[0],[3],[131]],[[{"name":"head_other","rect":{"x":0,"y":0,"width":300,"height":300},"offset":{"x":0,"y":0},"originalSize":{"width":300,"height":300},"rotated":false,"capInsets":[0,0,0,0],"packable":false}],[1],0,[0],[3],[132]],[[{"name":"particle_texture","rect":{"x":1,"y":1,"width":29,"height":29},"offset":{"x":-0.5,"y":0.5},"originalSize":{"width":32,"height":32},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[1],0,[0],[3],[133]],[[[16,"Bullet"],[106,"Bullet",8388608,[[2,-2,[0,"f7NISe7HdAD68SLfhnddy8"],[5,64,128]],[142,1,666.6666666666667,0.3,0,0,40,10,2,0,0,0,false,true,800,-3,[0,"cbO4wadUJK+63+QKgDbrCN"],[0,0.05,0.05],[4,4279920120],[4,4281532416],[4,4278779903],[4,4278190080],0,1],[181,-4,[0,"4aNue+D4dI/44YyhcBze0s"]]],[1,"6ekjyJHRVFW5k5QzSKMNd8",-1,0],[1,0.7,1,1]]],0,[0,4,1,0,0,1,0,0,1,0,0,1,0,5,1,4],[0,0],[10,1],[134,19]],[[[16,"shiqu"],[39,"shiqu",33554432,[[14,-2,[0,"cfm3ndb/BN1Llex59bwjpu"]],[89,1,0.05,215,0.4,0.2,76,180,80,10,-1,201,20,0,true,86,-3,[0,"247JYtVetEyLH9mRfjDZji"],[0,0,-742],[4,3795019519],[4,4278190080],0,1]],[1,"3085hAOqhPJbGxiOpe+WC3",-1,0]]],0,[0,4,1,0,0,1,0,0,1,0,5,1,3],[0,0],[10,1],[135,24]],[[[16,"tank_explode"],[33,"tank_explode",33554432,[-3,-4],[[14,-2,[0,"2ejfJWRRpPJoyF5oxPfiz3"]]],[1,"60Gn+OpPVBYZu1ZM3Rmp3T",-1,0]],[11,"Node-001",33554432,1,[[14,-5,[0,"16pDi02KVEhaz5ble+eu2v"]],[143,0.08,1000,0.2,0.5,0,360,40,10,-1,230,20,0,true,100,-6,[0,"1eGceC1DVPiosnzaeCLq51"],[4,4283650899],[4,4282664004],0,1],[31,160,-7,[0,"9ah9LqU05F5rDctOfzf6DE"]]],[1,"b8eTgiA9BOSrTuVb5abtwD",1,0]],[11,"Node",33554432,1,[[14,-8,[0,"05OD2/duFED7OooBc635RK"]],[144,1,1,0.08,1.7976931348623157e+308,0,0.6,0,360,400,213,-61,257,106,0,true,130,-9,[0,"01naMf0RdDHZEFxHSUz/Z1"],[4,4278190080],[4,4278190080],[4,4244635648],2]],[1,"14Us2gx9BCbavQltiAkZT0",1,0]]],0,[0,4,1,0,0,1,0,-1,2,0,-2,3,0,0,2,0,0,2,0,0,2,0,0,3,0,0,3,0,5,1,9],[0,0,0],[10,1,10],[136,6,137]],[[[16,"Prop"],[33,"Prop",33554432,[-5],[[2,-2,[0,"fdiRU9iGhGErDLZNMSrjHr"],[5,114,152]],[182,-4,[0,"b36LahxdpNipXtwd/wGcyY"],-3]],[1,"9d85IeDWdAh6e2+D1yBUJp",-1,0]],[24,"icon",33554432,1,[[[2,-6,[0,"9b86y8ACBCz41gr6F7e64l"],[5,114,152]],-7],4,1],[1,"74MuOvrDdLcLI7LgTqV4rs",1,0],[1,-7.131,-5.211,0]],[5,2,[0,"74vcdF9xJGibENdN1BzqeB"]]],0,[0,4,1,0,0,1,0,80,3,0,0,1,0,-1,2,0,0,2,0,-2,3,0,5,1,7],[],[],[]],[[[27,"Qiangkou",".plist"],-1],0,0,[],[],[]],[[[27,"xiangzi",".plist"],-1],0,0,[0],[9],[6]],[[{"name":"tip","rect":{"x":3,"y":3,"width":157,"height":78},"offset":{"x":1.5,"y":0},"originalSize":{"width":160,"height":84},"rotated":false,"capInsets":[62,26,53,32],"packable":true}],[1],0,[0],[3],[138]],[[[93,"Grandstander-ExtraBold","Grandstander-ExtraBold.ttf"],-1],0,0,[],[],[]],[[[65,"game_time_down_blue_font",33.44,{"commonHeight":38,"fontSize":33,"atlasName":"game_time_down_blue_sp","fontDefDictionary":{"48":{"xOffset":0,"yOffset":0,"xAdvance":23,"rect":{"x":0,"y":0,"width":23,"height":38}},"49":{"xOffset":0,"yOffset":0,"xAdvance":23,"rect":{"x":23,"y":0,"width":23,"height":38}},"50":{"xOffset":0,"yOffset":0,"xAdvance":23,"rect":{"x":46,"y":0,"width":23,"height":38}},"51":{"xOffset":0,"yOffset":0,"xAdvance":23,"rect":{"x":69,"y":0,"width":23,"height":38}},"52":{"xOffset":0,"yOffset":0,"xAdvance":23,"rect":{"x":92,"y":0,"width":23,"height":38}},"53":{"xOffset":0,"yOffset":0,"xAdvance":23,"rect":{"x":115,"y":0,"width":23,"height":38}},"54":{"xOffset":0,"yOffset":0,"xAdvance":23,"rect":{"x":138,"y":0,"width":23,"height":38}},"55":{"xOffset":0,"yOffset":0,"xAdvance":23,"rect":{"x":161,"y":0,"width":23,"height":38}},"56":{"xOffset":0,"yOffset":0,"xAdvance":23,"rect":{"x":184,"y":0,"width":23,"height":38}},"57":{"xOffset":0,"yOffset":0,"xAdvance":23,"rect":{"x":207,"y":0,"width":23,"height":38}}},"kerningDict":{}}]],0,0,[0],[9],[139]],[[[16,"Player_tank"],[107,"Player_tank",8388608,[-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30],[[2,-11,[0,"f4Wjmaf01JL6FzqYmlnQZt"],[5,1,1]],[183,-19,[0,"267J4PduNOg7JK3vZaMS2F"],-18,-17,-16,[44,45],[46,47],[48,49,50,51],-15,-14,-13,-12,42,43,52,53,54,55]],[133,"6fMgD4+KVXoIC2fCoB9423",-10,0,[-1,-2,-3,-4,-5,-6,-7,-8,-9]],[1,0,0,100],[1,100,100,100]],[108,"aidLine",2,1,[-33,-34,-35,-36,-37],[[8,-31,[0,"b0Ak6geA5KAo1VLbOmTYrf"],[5,130,4],[0,0,0.5]],[99,-32,[0,"e03bm2WfJA34SHCH2hOd/A"]]],[1,"e4t+05F4dIvKzJKOodxMpO",1,0],[1,0,1.5,0],[3,0,0,0.7071067811865475,0.7071067811865476],[1,0.02,0.02,0.02],[1,0,0,90]],[13,"tank_info",8388608,1,[-40,-41,-42,-43,-44,-45],[[2,-38,[0,"63Eubhb09HYKYsdpLvvs3P"],[5,3.69615,1]],[160,1,1,0.04,true,-39,[0,"7fSaFBgSRGC6g07fjIu+Wv"]]],[1,"6bASkxVwpGgbwJCaap2r62",1,0],[1,0,1.35,0]],[80,"tank_barrel",8388608,[-46,-47,-48,-49,-50,-51],[1,"8d+ZpvSe9JapA4C7rZ2kQr",1,0],[3,-4.329780281177466e-17,0.7071067811865476,0.7071067811865475,4.329780281177467e-17],[1,-90,180,0]],[80,"tank_body",8388608,[-52,-53,-54,-55,-56],[1,"55EBFOvZdN5o8EOXm1JwJh",1,0],[3,-4.329780281177466e-17,0.7071067811865476,0.7071067811865475,4.329780281177467e-17],[1,-90,180,0]],[66,"tank_body",8388608,1,[-58,-59,5],[[2,-57,[0,"f6SA7B2OJG6Z7i3J1IFeFU"],[5,1.1,1.1]]],[1,"9e7xBH3pRIE70R1/t+SYzy",1,0],[1,0,-0.2,0],[3,-0.3826834323650898,0,0,0.9238795325112867],[1,-45,0,0]],[9,["f6Yz8i6tJUxLfDb+Flllj+"]],[9,["1ek2MyR8xQvq3kv0P3PD6c"]],[9,["c063pQdBVAUJkNat3jiL/e"]],[9,["2cT14DFbZXJonxV0vtBQ5S"]],[67,"avatarBg",8388608,3,[-62,-63],[[2,-60,[0,"6eFbbBy5NO/4SWWM2LA6Eu"],[5,163,163]],[15,0,-61,[0,"c3ZJWu2KJKXZT6TNORfst3"],30]],[1,"6a+49ABzZCXa7gvDGZmbcX",1,0],[1,-1.481325,0,0],[1,0.0045,0.0045,0.0045]],[20,"nickName",8388608,3,[[2,-64,[0,"3a1b1Gy/ZHsoP9c1ua6/KT"],[5,267.31,94.2]],[171,"Trmmm",0,70,70,70,false,false,1,-65,[0,"08yGG922ZKsJcsJy8+Dv8S"],[4,4294425683],31],[100,3,-66,[0,"15q1MHWFlF07LPAq5OH/mq"]],[184,250,-67,[0,"34ZNUGJO1JzptRj/yZKyrP"]]],[1,"91/3VSSH5IcbIBKvebEY9u",1,0],[1,-0.4063,0,0],[1,0.005,0.005,0.005]],[20,"star",8388608,3,[[2,-68,[0,"63O30HwGhPn4j1drK3AHHE"],[5,122,114]],[6,-69,[0,"75spZL74hMyZJyA6p9hfi3"],34],[18,-70,[0,"8azZKg2NZKwoiPE82l5XaZ"]]],[1,"2bWwkFV+5PD6YyvtrprOAP",1,0],[1,1.6345750000000001,0,0],[1,0.0035,0.0035,0.0035]],[13,"pos_arrow",8388608,1,[-73,-74],[[2,-71,[0,"ebWC8tCwFAEKAEG44thpe0"],[5,0.6525000000000001,1]],[5,-72,[0,"df48XtU19AZbfRMInunx4f"]]],[1,"adKI2eyTlJa6FrgjuYHWfr",1,0],[1,0,1.478,0]],[81,"tank_base",8388608,5,[[101,-75,[0,"ccVmDrOXhCTby8SoWrlYrn"],[8],[74],9],[2,-76,[0,"1frEjuoSNK/qk6IH7kbF42"],[5,1,1]],[102,-77,[0,"58TBJUOJJNC4E1C0VB3gau"]]],[1,"12npSlywhK04x6nO+y7RjS",1,0],[3,-0.7071067811865476,-4.329780281177467e-17,4.329780281177466e-17,0.7071067811865475],[1,-90.00000000000003,0,7.016709298534876e-15]],[81,"tank_track",8388608,5,[[101,-78,[0,"58tgsQ+IxHhJQ5W70zAPSY"],[10],[74],11],[2,-79,[0,"98rC6SrwpMk6J97E0hWB75"],[5,1,1]],[102,-80,[0,"1blxeCa2hGEI9E6b54gdai"]]],[1,"84A1dNcP9GGqlteKY6J3Vj",1,0],[3,-0.7071067811865477,-4.3297802811774664e-17,-1.793453714559299e-17,0.7071067811865474],[1,-90.00000000000003,-4.9615627266087134e-15,2.0551465719261637e-15]],[9,["e0mTPsWxdAaIETH+AjZOht"]],[9,["7auQdJEB1XV7qinBaZaMPz"]],[9,["15qgMffZBW6aqk3ShvoZ8x"]],[9,["067EwrlolLjr/EsZ2W8WwQ"]],[9,["benb4bawRXfq1WjObASH3i"]],[35,"collisionNode",false,8388608,1,[-83],[[2,-81,[0,"a2SpAfKhdDcpYSxneUjf41"],[5,1.2,1.2]],[172,1,-82,[0,"b82ZxS4tlDAaE/7zun65kM"]]],[1,"22FlO1JahJ1rNT10vTb3+e",1,0]],[20,"Shooting",8388608,3,[[2,-84,[0,"eaqaBBKn1ILY6yAexsTN2F"],[5,34,36]],[6,-85,[0,"a5U0dFLvhB65luTelGiFYC"],32],[18,-86,[0,"e6WVwNjx9Kw4m8wM6fsKZJ"]]],[1,"a09ikOyhtCLq8ug+XPEbt+",1,0],[1,0.4719750000000001,0,0],[1,0.01,0.01,0.01]],[20,"Shield",8388608,3,[[2,-87,[0,"b5PO0MCkNFaYxREArwB84I"],[5,32,41]],[6,-88,[0,"e0kw+oaTBLFIq+cdSEwGyS"],33]],[1,"48ANX3sSBPwKBPP/yTRize",1,0],[1,0.8419750000000001,0,0],[1,0.01,0.01,1]],[109,"avatarBg",false,8388608,14,[-91],[[2,-89,[0,"2dDSbj9q9OpIf9g8gJ13aJ"],[5,163,163]],[15,0,-90,[0,"f2bC+bnYVOF6U85uFVK2fk"],38]],[1,"cbLItqVVlIz7bBvhYLZM1/",1,0],[1,0,-1.026,0],[1,0.0055,0.0055,0.0045]],[23,"scoreNode",2,1,[-93,-94],[[2,-92,[0,"c4EehgE7pIOqKzYooYudwh"],[5,1,1]]],[1,"a3lR7BB3NHTLid7LEfb8WI",1,0]],[20,"Extra Score s",2,26,[[8,-95,[0,"c7tD0lLAlFHpPEisUhBn4D"],[5,148,107],[0,0.5,0]],[6,-96,[0,"1bkzHA255E7JQVigsmUs1Y"],39]],[1,"10L79OziFOC7v5IvYc66sy",1,0],[1,1.869,1.37,0],[1,0.012,0.012,0.012]],[20,"Extra Score shizi",2,26,[[8,-97,[0,"05yjtLKbhHhZ2JdsiEltsG"],[5,145,108],[0,0.5,0]],[6,-98,[0,"b5ijZKn4RESoMldkzXYWV+"],40]],[1,"c8NGKEbCJPHYsParsREJY7",1,0],[1,1.869,1.36,0],[1,0.012,0.012,0.012]],[4,"ad_line1",2,2,[[2,-99,[0,"c3ljCtnLxDubwLF/3rdIPx"],[5,16,4]],[6,-100,[0,"e0dESuWMdJl5HPAhniakK2"],0]],[1,"cebwhu3BlB+5aS5WGP/jK5",1,0],[1,8,0,0]],[4,"ad_line2",2,2,[[2,-101,[0,"90IMsCKbtJlp684DZgQ9bv"],[5,16,4]],[6,-102,[0,"46chJ4XktGP4jRlvI/xnlL"],1]],[1,"a7IA/8TuhDzolf+ONdvDA8",1,0],[1,46,0,0]],[4,"ad_line3",2,2,[[2,-103,[0,"79I9apNSlB+72+CDh4PK+y"],[5,16,4]],[6,-104,[0,"5b+d7DfC5AE76hS9hQAq3k"],2]],[1,"2bN104ivFAFphu4u2/loHw",1,0],[1,84,0,0]],[4,"ad_line4",2,2,[[2,-105,[0,"92R+I5ZHRNRoTEI8ZjvRn3"],[5,16,4]],[6,-106,[0,"49mP/U/vxMtYnqy4qoLSWY"],3]],[1,"76TAgHSU9AvILt+h19CnlU",1,0],[1,122,0,0]],[4,"ad_line5",2,2,[[2,-107,[0,"292gx3oOZHX4FANvV4wFLp"],[5,16,4]],[6,-108,[0,"cd96cVqslJJKpQ7IvIaTbm"],4]],[1,"dbkK7mQ39DW59JDiwFUzsb",1,0],[1,160,0,0]],[20,"touy",8388608,1,[[2,-109,[0,"12Q8NS3I9Lo4rOGmUgLp9Y"],[5,696,380]],[90,-110,[0,"ef/iSEaoJI/6XSGE0d7Pyw"],[4,2365587455],5]],[1,"7bDDNVsZ9O87+aD+45Go3U",1,0],[1,-0.12,0.025,0],[1,0.0025,0.005,0.003]],[4,"left_motion_streak",8388608,6,[[2,-111,[0,"25pwiq+iVErZ6EtzWpZev0"],[5,0.2,0.2]],[103,0.8,20,-112,[0,"a6dP5rnElB4InciiuZD6CF"],[4,4282071867],6]],[1,"526mfQelBAD4YIr0IkeFRG",1,0],[1,-0.385,0,0.089]],[4,"right_motion_streak",8388608,6,[[2,-113,[0,"04ImvUUuNEOpg7Gp9CPIWz"],[5,0.2,0.2]],[103,0.8,20,-114,[0,"a3F9umgjtHRI63Zj7cvp/Q"],[4,4282071867],7]],[1,"beMRD6KGtArLSFn6RO0ouE",1,0],[1,0.385,0,0.089]],[19,0,{},5,[21,"e0mTPsWxdAaIETH+AjZOht",-115,[22,"5dMFBYTDtHC5PaIFqf71dm",1,[[10,"tank_player_youxiang",["_name"],17],[7,["_lpos"],17,[1,-3.0279352358775213e-9,0,0]],[7,["_lrot"],17,[3,-0.7071067811865476,0,0,0.7071067811865475]],[7,["_euler"],17,[1,-90.00000000000003,0,0]]]],12]],[19,0,{},5,[21,"f6Yz8i6tJUxLfDb+Flllj+",-116,[22,"58Bozjd11Os7OYK3i5p1n9",1,[[10,"tank_playerH_02",["_name"],7],[7,["_lpos"],7,[1,0,0,0]],[7,["_lrot"],7,[3,-0.7071067811865475,0,0,0.7071067811865476]],[7,["_euler"],7,[1,-90,0,0]],[10,true,["_active"],7]]],13]],[19,0,{},5,[21,"1ek2MyR8xQvq3kv0P3PD6c",-117,[22,"2axeM1y1RGI5UOLvJcFDRj",1,[[10,"tank_playerL_01",["_name"],8],[7,["_lpos"],8,[1,0,0,0]],[7,["_lrot"],8,[3,-0.7071067811865475,0,0,0.7071067811865476]],[7,["_euler"],8,[1,-90,0,0]],[10,true,["_active"],8]]],14]],[19,0,{},4,[21,"7auQdJEB1XV7qinBaZaMPz",-118,[22,"c5GpLHDfdPyopcC3fbLdnR",1,[[10,"tank_player_barrel_3",["_name"],18],[7,["_lpos"],18,[1,-1.7763568394002505e-15,1.7763568394002505e-15,8.881784197001252e-16]],[7,["_lrot"],18,[3,0,0,0,1]],[7,["_euler"],18,[1,0,0,0]],[72,["_materials","0"],[9,["45BSnqtMJafI0wxLNuFAht"]],16]]],15]],[19,0,{},4,[21,"15qgMffZBW6aqk3ShvoZ8x",-119,[22,"23EDjNXP1D1oAotaToBosZ",1,[[10,"tank_player_barrel_2",["_name"],19],[7,["_lpos"],19,[1,0,0,0]],[7,["_lrot"],19,[3,0,0,0,1]],[7,["_euler"],19,[1,0,0,0]],[72,["_materials","0"],[9,["28gVm6QHFXI4+mcLDPV9FN"]],18]]],17]],[19,0,{},4,[21,"067EwrlolLjr/EsZ2W8WwQ",-120,[22,"cdQFnjwPpKWJbCuRtq2IUB",1,[[10,"tank_player_barrel_1",["_name"],20],[7,["_lpos"],20,[1,0,0,0]],[7,["_lrot"],20,[3,0,0,0,1]],[7,["_euler"],20,[1,0,0,0]],[72,["_materials","0"],[9,["c2awSKWh5JzY59OVJ1zSD+"]],20]]],19]],[19,0,{},4,[21,"c063pQdBVAUJkNat3jiL/e",-121,[22,"9evaFx5AFIgKMySvRQ3U2s",1,[[10,"tank_player_fort_1",["_name"],9],[7,["_lpos"],9,[1,-3.552713678800501e-15,-8.881784197001252e-16,-0.030999999999999694]],[7,["_lrot"],9,[3,-0.7071067811865476,0,8.715763992105246e-33,0.7071067811865475]],[7,["_euler"],9,[1,-90.00000000000003,7.062250076880254e-31,7.062250076880252e-31]],[10,true,["_active"],9]]],21]],[19,0,{},4,[21,"benb4bawRXfq1WjObASH3i",-122,[22,"241pDklcRN+YkrUC7YTF00",1,[[10,"tank_player_fort_2",["_name"],21],[7,["_lpos"],21,[1,-3.552713678800501e-15,0,8.881784197001252e-16]],[7,["_lrot"],21,[3,-0.7071067811865474,-4.357881996052623e-33,-8.715763992105245e-33,0.7071067811865477]],[7,["_euler"],21,[1,-89.99999999999997,-1.0593375115320377e-30,-3.5311250384401286e-31]]]],22]],[19,0,{},4,[21,"2cT14DFbZXJonxV0vtBQ5S",-123,[22,"75199x211ICJ+ZFCQLe4Iw",1,[[10,"tank_playerH_01",["_name"],10],[7,["_lpos"],10,[1,0,-8.881784197001252e-16,1.7763568394002505e-15]],[7,["_lrot"],10,[3,-0.7071067811865475,8.715763992105246e-33,8.715763992105245e-33,0.7071067811865476]],[7,["_euler"],10,[1,-89.99999999999999,1.4124500153760504e-30,0]],[10,true,["_active"],10]]],23]],[11,"SpriteSplash",8388608,22,[[2,-124,[0,"52DghbR1RAyKc9IjwFRdUV"],[5,1.2,1.2]],[61,0,-125,[0,"e7h9uoBGFCeZ9+yLW2BTR/"],[4,4278190335],24]],[1,"a45ZcnogFBgqVbPQmR21bL",1,0]],[82,"Hudun",8388608,1,[[2,-126,[0,"29wHprHKZHwrsZRZJHmgwI"],[5,1920,1080]],[186,0,"default","animation",-127,[0,"76tG0iuf9Gap/cWS1W6Jzi"],25]],[1,"94eXc0LjtIiqcllZ51z+Zu",1,0],[1,0.002,0.002,0.002]],[76,"fireNode",false,8388608,1,[-129],[[2,-128,[0,"79PF+MnMpB8rTjtTqlyWxa"],[5,1,1]]],[1,"dbEMeZ9ntC1KeXe1kBj/S6",1,0],[1,0,-0.2,0]],[23,"fireNode",8388608,48,[-131],[[2,-130,[0,"69KtYtEupPnaKiDABCx8fD"],[5,1,1]]],[1,"b9O7DleSpAWLkZ94anjoDA",1,0]],[115,"emoji",false,8388608,11,[[[2,-132,[0,"42MG+0Bo1JDpEdgrG91Zhy"],[5,86,86]],-133],4,1],[1,"c30ZsMh2tHeKzMG8h50mo+",1,0],[1,0,220,2.842170943040401e-14],[1,2,2,2]],[11,"avatar",8388608,11,[[2,-134,[0,"f5QGNLmQ9A65X+Onk5laut"],[5,145,145]],[92,0,-135,[0,"78Bku2NARIT7uF6Ot0h9u5"],28,29]],[1,"c6P0QTDVdAtq78O2i6w/wc",1,0]],[116,"armoLabel",8388608,3,[[[8,-136,[0,"51cnQYZUVKuLjqqOTrIF9X"],[5,33.91,35],[0,0,0.5]],-137],4,1],[1,"8b7QFk0fhOZ5UILZJfNnh4",1,0],[1,1.041975,0,0],[1,0.01,0.01,1]],[82,"playerPosTipArrow",8388608,14,[[2,-138,[0,"b9uEa6LHdHaLdfaSZiGa7M"],[5,370,409]],[15,0,-139,[0,"62PSzf9LVKGb2fc2jVHe0F"],35]],[1,"f5bRvU+LdBbZsVWTTqmh5k",1,0],[1,0.003,0.003,0.01]],[11,"avatar",8388608,25,[[2,-140,[0,"aaPrJP6RBI26jHQDz6kIWO"],[5,145,145]],[92,0,-141,[0,"a1fVuHijtNk74pUhR4FHJP"],36,37]],[1,"54wd5+2XtNxagU9ku0fgHs",1,0]],[110,"SpriteSplash",false,8388608,1,[[8,-142,[0,"4bamC7TU5LzbpeEx3Pgl3M"],[5,500,2],[0,0,0.5]],[15,0,-143,[0,"3dC1D7IcpKpb7VpzF+3YYR"],41]],[1,"6b+Ti8LmJEK5VzQPyU8h2q",1,0],[3,5.456071293926119e-17,5.4560712939261184e-17,0.7071067811865475,0.7071067811865476],[1,0.010000000000000002,0.01,1],[1,8.841942014468577e-15,3.485597470661856e-31,90]],[111,"tank_barrel",8388608,1,[4],[1,"ef7z28vc5OUJUPUvDfkZ21",1,0],[1,1.7763568394002505e-15,-0.2,0],[3,-0.3826834323650898,0,0,0.9238795325112867],[1,-45,0,0]],[112,"Capsule",8388608,49,[[185,"Capsule<ModelComponent>",-144,[0,"d8Y+pYqF5J14rt7TS4AmCw"],[26],[74],27]],[1,"17OmoXUMVJTbm/Xu2tcfw0",1,0],[1,0,0.7804,0.40941],[3,-0.788799113621497,0,0,0.6146510866743349],[1,0.1,1,0.1],[1,-104.146856,0,0]],[5,50,[0,"a6A60QVMpCNqPNNUYZXLYk"]],[98,"x1",35,35,35,false,52,[0,"e84uSnmGRBUbBd0ZIQ4ciF"],[4,4283585279]]],0,[0,-1,37,0,-2,38,0,-3,39,0,-4,40,0,-5,41,0,-6,42,0,-7,43,0,-8,44,0,-9,45,0,4,1,0,0,1,0,24,28,0,25,27,0,81,13,0,82,58,0,83,59,0,84,24,0,85,2,0,0,1,0,-1,2,0,-2,34,0,-3,6,0,-4,56,0,-5,22,0,-6,47,0,-7,48,0,-8,3,0,-9,14,0,-10,26,0,-11,55,0,0,2,0,0,2,0,-1,29,0,-2,30,0,-3,31,0,-4,32,0,-5,33,0,0,3,0,0,3,0,-1,11,0,-2,12,0,-3,23,0,-4,24,0,-5,52,0,-6,13,0,-1,40,0,-2,41,0,-3,42,0,-4,43,0,-5,44,0,-6,45,0,-1,15,0,-2,16,0,-3,37,0,-4,38,0,-5,39,0,0,6,0,-1,35,0,-2,36,0,0,11,0,0,11,0,-1,50,0,-2,51,0,0,12,0,0,12,0,0,12,0,0,12,0,0,13,0,0,13,0,0,13,0,0,14,0,0,14,0,-1,53,0,-2,25,0,0,15,0,0,15,0,0,15,0,0,16,0,0,16,0,0,16,0,0,22,0,0,22,0,-1,46,0,0,23,0,0,23,0,0,23,0,0,24,0,0,24,0,0,25,0,0,25,0,-1,54,0,0,26,0,-1,27,0,-2,28,0,0,27,0,0,27,0,0,28,0,0,28,0,0,29,0,0,29,0,0,30,0,0,30,0,0,31,0,0,31,0,0,32,0,0,32,0,0,33,0,0,33,0,0,34,0,0,34,0,0,35,0,0,35,0,0,36,0,0,36,0,4,37,0,4,38,0,4,39,0,4,40,0,4,41,0,4,42,0,4,43,0,4,44,0,4,45,0,0,46,0,0,46,0,0,47,0,0,47,0,0,48,0,-1,49,0,0,49,0,-1,57,0,0,50,0,-2,58,0,0,51,0,0,51,0,0,52,0,-2,59,0,0,53,0,0,53,0,0,54,0,0,54,0,0,55,0,0,55,0,0,57,0,5,1,4,17,56,5,17,6,144],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,58,59],[1,1,1,1,1,1,30,30,-1,22,-1,22,8,8,8,8,23,8,23,8,23,8,8,8,1,86,-1,22,31,1,1,6,1,1,1,1,31,1,1,1,1,1,87,88,-1,-2,-1,-2,-1,-2,-3,-4,89,90,91,92,1,6],[3,3,3,3,3,140,10,10,4,141,48,142,143,144,145,146,4,147,4,148,4,149,150,151,0,152,153,154,49,18,50,9,155,156,25,157,49,18,51,31,32,0,48,158,4,159,160,161,7,13,14,15,50,51,162,18,7,8]],[[[71,"builtin-particle",[{"hash":585841727,"name":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add","blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1},{"name":"nodeRotation","type":16,"count":1}],"defines":[]},{"name":"FragConstants","stageFlags":16,"binding":1,"members":[{"name":"tintColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":2,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":32,"location":1,"defines":[]},{"name":"a_texCoord1","format":32,"location":2,"defines":[]},{"name":"a_texCoord2","format":32,"location":3,"defines":[]},{"name":"a_color","format":44,"location":4,"defines":[]},{"name":"a_color1","format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 2) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 1) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\n   uniform vec4 nodeRotation;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\n  uniform vec4 tintColor;\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":53,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":40}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"ROTATION_OVER_TIME_MODULE_ENABLE","type":"boolean","defines":[]}]},{"hash":1223598056,"name":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:multiply","blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1},{"name":"nodeRotation","type":16,"count":1}],"defines":[]},{"name":"FragConstants","stageFlags":16,"binding":1,"members":[{"name":"tintColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":2,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":32,"location":1,"defines":[]},{"name":"a_texCoord1","format":32,"location":2,"defines":[]},{"name":"a_texCoord2","format":32,"location":3,"defines":[]},{"name":"a_color","format":44,"location":4,"defines":[]},{"name":"a_color1","format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 2) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 1) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = multiply(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = multiply(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\n   uniform vec4 nodeRotation;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\n  uniform vec4 tintColor;\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture2D(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = multiply(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":53,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":40}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"ROTATION_OVER_TIME_MODULE_ENABLE","type":"boolean","defines":[]}]},{"hash":3735404623,"name":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:addSmooth","blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1},{"name":"nodeRotation","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":1,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":32,"location":1,"defines":[]},{"name":"a_texCoord1","format":32,"location":2,"defines":[]},{"name":"a_texCoord2","format":32,"location":3,"defines":[]},{"name":"a_color","format":44,"location":4,"defines":[]},{"name":"a_color1","format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 1) uniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = addSmooth(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = addSmooth(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\n   uniform vec4 nodeRotation;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture2D(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = addSmooth(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":53,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":39}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"ROTATION_OVER_TIME_MODULE_ENABLE","type":"boolean","defines":[]}]},{"hash":2524517876,"name":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:premultiplied","blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1},{"name":"nodeRotation","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":1,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":32,"location":1,"defines":[]},{"name":"a_texCoord1","format":32,"location":2,"defines":[]},{"name":"a_texCoord2","format":32,"location":3,"defines":[]},{"name":"a_color","format":44,"location":4,"defines":[]},{"name":"a_color1","format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 1) uniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = premultiplied(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = premultiplied(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\n   uniform vec4 nodeRotation;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture2D(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = premultiplied(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":53,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":39}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"ROTATION_OVER_TIME_MODULE_ENABLE","type":"boolean","defines":[]}]}],[{"name":"add","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":1,"blendSrcAlpha":2,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"alpha-blend","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"add-multiply","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:multiply","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":7,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":3}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"add-smooth","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:addSmooth","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":1,"blendSrcAlpha":2,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]}}}]},{"name":"premultiply-blend","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:premultiplied","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]}}}]}]]],0,0,[],[],[]],[[[187,"Hudun","\nHudun.png\nsize: 1580,1580\nformat: RGBA8888\nfilter: Linear,Linear\nrepeat: none\n10\n  rotate: false\n  xy: 791, 178\n  size: 787, 699\n  orig: 1920, 1080\n  offset: 560, 229\n  index: -1\n4\n  rotate: false\n  xy: 2, 879\n  size: 787, 699\n  orig: 1920, 1080\n  offset: 560, 229\n  index: -1\n5\n  rotate: false\n  xy: 791, 879\n  size: 787, 699\n  orig: 1920, 1080\n  offset: 560, 229\n  index: -1\n6\n  rotate: false\n  xy: 2, 178\n  size: 787, 699\n  orig: 1920, 1080\n  offset: 560, 229\n  index: -1\n\nHudun2.png\nsize: 1580,1580\nformat: RGBA8888\nfilter: Linear,Linear\nrepeat: none\n1\n  rotate: false\n  xy: 2, 878\n  size: 787, 700\n  orig: 1920, 1080\n  offset: 560, 228\n  index: -1\n2\n  rotate: false\n  xy: 2, 176\n  size: 787, 700\n  orig: 1920, 1080\n  offset: 560, 228\n  index: -1\n3\n  rotate: false\n  xy: 791, 878\n  size: 787, 700\n  orig: 1920, 1080\n  offset: 560, 228\n  index: -1\n7\n  rotate: false\n  xy: 791, 176\n  size: 787, 700\n  orig: 1920, 1080\n  offset: 560, 228\n  index: -1\n\nHudun3.png\nsize: 1493,1493\nformat: RGBA8888\nfilter: Linear,Linear\nrepeat: none\n11\n  rotate: false\n  xy: 2, 792\n  size: 787, 699\n  orig: 1920, 1080\n  offset: 560, 229\n  index: -1\n8\n  rotate: true\n  xy: 791, 704\n  size: 787, 700\n  orig: 1920, 1080\n  offset: 560, 228\n  index: -1\n9\n  rotate: false\n  xy: 2, 90\n  size: 787, 700\n  orig: 1920, 1080\n  offset: 560, 228\n  index: -1\n",["Hudun.png","Hudun2.png","Hudun3.png"],{"skeleton":{"hash":"kBr5vNBmwyekxLFwiimHhtmz5/o","spine":"3.8.99","x":-960,"y":-540,"width":1920,"height":1080,"images":"../../All New Game/MX Tank Battle/hudun/","audio":""},"bones":[{"name":"root"}],"slots":[{"name":"1","bone":"root","attachment":"1","blend":"additive"}],"skins":[{"name":"default","attachments":{"1":{"1":{"width":1920,"height":1080},"2":{"width":1920,"height":1080},"3":{"width":1920,"height":1080},"4":{"width":1920,"height":1080},"5":{"width":1920,"height":1080},"6":{"width":1920,"height":1080},"7":{"width":1920,"height":1080},"8":{"width":1920,"height":1080},"9":{"width":1920,"height":1080},"10":{"width":1920,"height":1080},"11":{"width":1920,"height":1080}}}}],"animations":{"animation":{"slots":{"1":{"attachment":[{"name":"1"},{"time":0.0667,"name":"2"},{"time":0.1333,"name":"3"},{"time":0.2,"name":"4"},{"time":0.2667,"name":"5"},{"time":0.3333,"name":"6"},{"time":0.4,"name":"7"},{"time":0.4667,"name":"8"},{"time":0.5333,"name":"9"},{"time":0.6,"name":"10"},{"time":0.6667,"name":"11"}]}}}}},[0,1,2]]],0,0,[0,0,0],[-1,-2,-3],[163,164,165]],[[[148,[{}],[{}]]],0,0,[0],[11],[23]],[[{"name":"01Backgroundz_1","rect":{"x":0,"y":0,"width":200,"height":2365},"offset":{"x":0,"y":0},"originalSize":{"width":200,"height":2365},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[1],0,[0],[3],[166]],[[[36,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_OUTLINE_PASS":true},{"USE_RIM_LIGHT":true,"USE_BASE_COLOR_MAP":true,"USE_EMISSIVE":true,"USE_GRAYCOLOR":true},{}],[[{"lineWidth":0},[{},"rimLightColor",8,[4,4060086272],"mainTexture",6,0],{}],0,11,0]]],0,0,[0,0],[12,11],[167,11]],[[{"name":"01Backgroundz_2","rect":{"x":0,"y":0,"width":200,"height":2366},"offset":{"x":0,"y":0},"originalSize":{"width":200,"height":2366},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[1],0,[0],[3],[168]],[[{"name":"Cactus","rect":{"x":0,"y":0,"width":3227,"height":3796},"offset":{"x":0,"y":0.5},"originalSize":{"width":3227,"height":3797},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[1],0,[0],[3],[169]],[[{"name":"01Backgroundy_1","rect":{"x":0,"y":0,"width":200,"height":2365},"offset":{"x":0,"y":0},"originalSize":{"width":200,"height":2365},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[1],0,[0],[3],[170]],[[[16,"Qiangkou"],[39,"Qiangkou",33554432,[[14,-2,[0,"fb61kam2xFM4WeWmZMNX8f"]],[145,1,0.07,50,0.2,30,120,24,720,-1440,300,100,0,-604,true,11,-3,[0,"9ecwaJTHxE8ah4EVlst0NL"],[0,0,2000],[4,4281584895],[4,2137417318],[4,4284914175],0]],[1,"4azWKtT1BD1JUUywHV2EiM",-1,0]]],0,[0,4,1,0,0,1,0,0,1,0,5,1,3],[0],[10],[171]],[[[36,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_OUTLINE_PASS":true},{"USE_RIM_LIGHT":true,"USE_BASE_COLOR_MAP":true,"USE_EMISSIVE":true,"USE_GRAYCOLOR":true},{}],[[{"lineWidth":0},[{},"rimLightColor",8,[4,4060086272],"mainTexture",6,0],{}],0,11,0]]],0,0,[0,0],[12,11],[172,11]]]]
