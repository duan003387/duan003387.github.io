[1,["f6SJZOjTJB/JrJeh5xTdF7","d1NGQ2rJZCcbhjH0/erZWw","28zxfPiaNFK61+pebo6Su0@f7c6e","735+xGNfJFW5bQaJ8OEH6E@6c48a","12Y9dMgWdJKJGmTiZyQR9H@a804a","8f0xzmwL9DCbs/OTVgVeWE","d3x4IMKphEKYvHuEU7yaxB","1eQvtox8FD8YlEugIVHdqp@6c48a","e0cq/O8xtGcJI8vVd2hpQQ@6c48a","eadHiwQI1AUrcD8NI1Xglf","3ad0p6aX1Kta9uIdOs9gUL@6c48a","0f5pQTcK5KXZQQ8EfFNWTk@fb329","91cw2ECUROSY61JSDyV+Kk","07UHJFsExIGaiV3kL642vp","dba7i7izNGMqMVzfy9MKyn","f7AxumMgBAV4j0d2XPiBs9","91bfHp5TBH55j2kzA+oYhL","20g1ukYUVPvKWKBRznAKo+@f9941","9e1hCDfaZJK6gX/uSST4fU@6c48a","5bfWgUkKZNn7f9QQ3KnelX","b5snqx50BDmLQHhI/CssiX@6c48a","46aeW4d1dOFZnPQc8U9FXx@6c48a","2cwDvTF7hORasLzb49pbA0@6c48a","621kUmJ1JNZp4teC/Fzby1@6c48a","12Y9dMgWdJKJGmTiZyQR9H@2e76e","48rj3g2LdEOYtKkd7JGuzR","56gvY8HrtMZrJWpGNbjmxX","1brw/JvvpFnIvdrxpFCgMZ","34SKZpLlhMuKx58RSiAfdw@1f97b","34SKZpLlhMuKx58RSiAfdw@3fdbc","a3zQCfCrBCDZJ4uf2rk5u8","9eaZfVy9hLK4p6PqXbWde9@1f586","e0nzfUzDxHkajeNry9oBk+","04G5VO3EdGL6hfdHu3KZzR","7bXh6xLNpPzLDrlnny3GfA","64Zsu6Oa5J3KUYHXdVXT+j","34neUoDbZCPJYdXWH1rbrV","b5gi4I3L9IhKnjCoaCpjQJ@f9941","f8pTfkVMVJaov5Ln8NSBfn","40mMdELjxDAaLjig/Nh4sO@6c48a","75v/oZ/CdPh5vJxWllfB/5@6c48a","9dKKGHrFVJ/5CA8+rykkrA@3fdbc","27Su2f1TBAXLMWkVmHhEIk@6c48a","cfYwYGmiRB06rv2wmeqaqv","c2fECzjWpNjoYjDgVrOwZm","a7dmC2yJdDAppCyPB68/PM","c7XMXR8mZAzoDyJz5rJKzQ","24l9MDIF5AiLUR6Fn6mtab","9a691681BHBbBK82Qp37Ab","25YxWVUDVFPo2TDrHLNPo5","9e1hCDfaZJK6gX/uSST4fU@f9941","03NoM7j/1Ber/xJ1iy0MfQ@17464","03NoM7j/1Ber/xJ1iy0MfQ@620a4","0eAJFuLcZCQo2xBJhpfrZy","67mEf0yYpPUK6sVf1g8Dwe","fcNNvb82FH4YN+PJ+8ckeu@770b3","edbhttI/hC7JVH2ruUWXxZ@1c3f5","9aPHUwQblOZ63WXSKN2+2v@c8923","13Ny5XlYVIxLuq0boRpfoR@d50f8","7562yoMXpKZ6ECjhWS08He@3cf4b","8am6aJDAZIzpjJPn9Bd2U4@c3bc7","24HdfJ5hdD87H2dH7VbIPv@23831","ddm+zu0qhEU4GW4WfIW3Sp@47f98","bavdlyd1hOnaH35YubGpgH@4f7eb","8aa40AO29CX6RLUVZ8HiGK@111ab","b6N2z7RvpPfps2Noz3NEzP@00469","80DQ1riyFAs4HUT9MB2lkO@7582a","77OZKErzZFO52sQgucvLc2@8dddd","73H43agBhNqJ6loVh/NJY6@7582c","6cLlV0vOpKA56bUHPSwIUC@14192","59UVJZ9AZCxY50LeSX5fje@87aed","dfQaG1Uh1IfoWY+fnNKw6+@89c73","d1NkdddJpENINhOM+wexUd@d55ed","34SKZpLlhMuKx58RSiAfdw@89a32","a8byOteplBcZm1xDI2RfXP@77560","db7iA+q6ZIN49K+QwDlEoB@d65f3","03NoM7j/1Ber/xJ1iy0MfQ@7d3f8","e1HI1OdQBOoaQP9X5W4jjf@fea5e","5c49cvNc9BboODa3Z++oM7@32871","d5hR083o1H0b57BIZMxD7H@f0370","35Ub6UJilDb7OdBO7xiWbB@c2800","342ArufVNMNa6IZHEEWhxI@2edc6","9dKKGHrFVJ/5CA8+rykkrA@55248","a31Ym8r7NHWr6+rk8N6q0+@efa39","e2f8GyIHNOcZkqGKc5xWgx@f9941","394V4hrZpBZat+KCzJyPGH","3aHuvPvN9A6Llz2+RIiwcI","d5azmNwtlO+qeH+A+/TiLG","54TknWPwVPqJqeCR+Y/Czo@f9941","95EkngnxZFbYuFpsqVTaFr@f9941","75Xhc3jCxHhp4UhhE8dDiO","e8PHh1S15D6qIhgHp57S8K","f1wxdlNdxKRI3e5dFO0k5a@f9941","e03Utj4RhLub9FDzhxvFuG@f9941","72nKm13BpPPqQWJCB8o69G","eaWQ0TXllHQKeySFN80Djy","a0YXJioEZBApLwOYyzbxsD","00TqPdCChGa6QCL0ovZ9Dr","6fAc9/gb9Kfr1dCvwZaWSA@b47c0","5fjfR273lB7o/XVW56r+Nb","09rkVPLQdE8LJaM1lQ5FSw","95h61OnNRGzImFWxijWw63","9ddVNxKY1EMKFpOBMiZUdI@6c48a","7dSr4oVBNHTbWhmUanTaPR@d90a4","12Y9dMgWdJKJGmTiZyQR9H@17020","70vyfvQUFI8K6hfHWkn4kd","13Ny5XlYVIxLuq0boRpfoR@17464","13Ny5XlYVIxLuq0boRpfoR@1f97b","13Ny5XlYVIxLuq0boRpfoR@3fdbc","13Ny5XlYVIxLuq0boRpfoR@8b24c","24HdfJ5hdD87H2dH7VbIPv@d8c69","24HdfJ5hdD87H2dH7VbIPv@3fdbc","24HdfJ5hdD87H2dH7VbIPv@17464","24HdfJ5hdD87H2dH7VbIPv@42e9f","28zxfPiaNFK61+pebo6Su0@17464","28zxfPiaNFK61+pebo6Su0@162a2","34SKZpLlhMuKx58RSiAfdw@9afc3","34SKZpLlhMuKx58RSiAfdw@00773","34SKZpLlhMuKx58RSiAfdw@935df","34SKZpLlhMuKx58RSiAfdw@17464","34SKZpLlhMuKx58RSiAfdw@446db","342ArufVNMNa6IZHEEWhxI@17464","342ArufVNMNa6IZHEEWhxI@3fdbc","342ArufVNMNa6IZHEEWhxI@9e51f","342ArufVNMNa6IZHEEWhxI@00773","342ArufVNMNa6IZHEEWhxI@e40c3","35Ub6UJilDb7OdBO7xiWbB@17464","35Ub6UJilDb7OdBO7xiWbB@73a66","f1Nx5roMlECLMmYZ+AlSzn@6c48a","30zaks7NJAf6uKVvtDK0+E@6c48a","1fSmMXTXZNUaEuY2ezK8rx@703ab","1fSmMXTXZNUaEuY2ezK8rx@71f79","1fSmMXTXZNUaEuY2ezK8rx@9fb16","1fSmMXTXZNUaEuY2ezK8rx@0cf63","1fSmMXTXZNUaEuY2ezK8rx@0b26b","b6mvr5eXVKVZBwwCOnzGHS@cf5ee","02E/5SZw9Ifq/kDoT7SMAj@989ed","9fZ+NLhIREDr/wasJWsTBU@600a0","963gMSRaVB1alsW5Q/nxoK@6c48a","59UVJZ9AZCxY50LeSX5fje@00773","59UVJZ9AZCxY50LeSX5fje@17464","59UVJZ9AZCxY50LeSX5fje@935df","59UVJZ9AZCxY50LeSX5fje@3fdbc","59UVJZ9AZCxY50LeSX5fje@1f97b","59UVJZ9AZCxY50LeSX5fje@172cf","5c49cvNc9BboODa3Z++oM7@17464","5c49cvNc9BboODa3Z++oM7@9e51f","5c49cvNc9BboODa3Z++oM7@3fdbc","5c49cvNc9BboODa3Z++oM7@c6103","5aGSB1YbZLloal1aqeGhFT@ef09c","3020arX8RF74+vuAOz+UUB@6c48a","6cLlV0vOpKA56bUHPSwIUC@3fdbc","6cLlV0vOpKA56bUHPSwIUC@d8c69","6cLlV0vOpKA56bUHPSwIUC@22c88","73H43agBhNqJ6loVh/NJY6@82deb","73H43agBhNqJ6loVh/NJY6@62b43","73H43agBhNqJ6loVh/NJY6@1f97b","73H43agBhNqJ6loVh/NJY6@00773","73H43agBhNqJ6loVh/NJY6@3fdbc","73H43agBhNqJ6loVh/NJY6@856ad","9cpIkNF49Inrfw2/ynU5PL","7562yoMXpKZ6ECjhWS08He@17464","7562yoMXpKZ6ECjhWS08He@9e51f","7562yoMXpKZ6ECjhWS08He@3fdbc","7562yoMXpKZ6ECjhWS08He@1f97b","7562yoMXpKZ6ECjhWS08He@935df","7562yoMXpKZ6ECjhWS08He@ad1ed","77OZKErzZFO52sQgucvLc2@3fdbc","77OZKErzZFO52sQgucvLc2@d8c69","77OZKErzZFO52sQgucvLc2@5dd53","80DQ1riyFAs4HUT9MB2lkO@3fdbc","80DQ1riyFAs4HUT9MB2lkO@d8c69","80DQ1riyFAs4HUT9MB2lkO@62444","8aa40AO29CX6RLUVZ8HiGK@17464","8aa40AO29CX6RLUVZ8HiGK@1db57","8am6aJDAZIzpjJPn9Bd2U4@d8c69","8am6aJDAZIzpjJPn9Bd2U4@3fdbc","8am6aJDAZIzpjJPn9Bd2U4@17464","8am6aJDAZIzpjJPn9Bd2U4@55060","609xlc7CpF67qUiVX2DoHQ","12Y9dMgWdJKJGmTiZyQR9H@fc873","caTGrZ4ShFVbHh2m3FC7go","9aPHUwQblOZ63WXSKN2+2v@17464","9aPHUwQblOZ63WXSKN2+2v@bc948","97G9sjP/ZD67QiHDAWWjZj","9dKKGHrFVJ/5CA8+rykkrA@7d639","9dKKGHrFVJ/5CA8+rykkrA@17464","9dKKGHrFVJ/5CA8+rykkrA@935df","9dKKGHrFVJ/5CA8+rykkrA@1f97b","9dKKGHrFVJ/5CA8+rykkrA@ce677","08h2vKK69DJrt+kghpKytR","6670/grwJKr6FTLMj+OSuB@e0d2f","a31Ym8r7NHWr6+rk8N6q0+@17464","a31Ym8r7NHWr6+rk8N6q0+@9e51f","a31Ym8r7NHWr6+rk8N6q0+@3fdbc","a31Ym8r7NHWr6+rk8N6q0+@1f97b","a31Ym8r7NHWr6+rk8N6q0+@dfbe1","a31Ym8r7NHWr6+rk8N6q0+@00773","a31Ym8r7NHWr6+rk8N6q0+@572e9","a8byOteplBcZm1xDI2RfXP@17464","a8byOteplBcZm1xDI2RfXP@3fdbc","a8byOteplBcZm1xDI2RfXP@8f8aa","a8byOteplBcZm1xDI2RfXP@710bf","a8byOteplBcZm1xDI2RfXP@cef83","a8byOteplBcZm1xDI2RfXP@00773","a8byOteplBcZm1xDI2RfXP@303bf","b5gi4I3L9IhKnjCoaCpjQJ@6c48a","b6N2z7RvpPfps2Noz3NEzP@3fdbc","b6N2z7RvpPfps2Noz3NEzP@d8c69","b6N2z7RvpPfps2Noz3NEzP@e6be7","bavdlyd1hOnaH35YubGpgH@17464","bavdlyd1hOnaH35YubGpgH@89988","d1NkdddJpENINhOM+wexUd@00773","d1NkdddJpENINhOM+wexUd@17464","d1NkdddJpENINhOM+wexUd@935df","d1NkdddJpENINhOM+wexUd@3fdbc","d1NkdddJpENINhOM+wexUd@1f97b","d1NkdddJpENINhOM+wexUd@7cc3a","98vfoCWXBHm4LiSnkYPV7r@6c48a","d5hR083o1H0b57BIZMxD7H@17464","d5hR083o1H0b57BIZMxD7H@2ad1e","db7iA+q6ZIN49K+QwDlEoB@17464","db7iA+q6ZIN49K+QwDlEoB@7fb43","ddm+zu0qhEU4GW4WfIW3Sp@9f269","ddm+zu0qhEU4GW4WfIW3Sp@3fdbc","ddm+zu0qhEU4GW4WfIW3Sp@d8c69","ddm+zu0qhEU4GW4WfIW3Sp@17464","ddm+zu0qhEU4GW4WfIW3Sp@80fdf","dfQaG1Uh1IfoWY+fnNKw6+@1f97b","dfQaG1Uh1IfoWY+fnNKw6+@17464","dfQaG1Uh1IfoWY+fnNKw6+@935df","dfQaG1Uh1IfoWY+fnNKw6+@3fdbc","dfQaG1Uh1IfoWY+fnNKw6+@710bf","dfQaG1Uh1IfoWY+fnNKw6+@87f79","ddBGluriNLO7ioLrY3vD7e@6c48a","173rzDCmtLirAL3Fi4hVge","e03Utj4RhLub9FDzhxvFuG@6c48a","e1HI1OdQBOoaQP9X5W4jjf@17464","e1HI1OdQBOoaQP9X5W4jjf@9e51f","e1HI1OdQBOoaQP9X5W4jjf@a28b2","e2f8GyIHNOcZkqGKc5xWgx@6c48a","edbhttI/hC7JVH2ruUWXxZ@1f97b","edbhttI/hC7JVH2ruUWXxZ@17464","edbhttI/hC7JVH2ruUWXxZ@935df","edbhttI/hC7JVH2ruUWXxZ@3fdbc","edbhttI/hC7JVH2ruUWXxZ@00773","edbhttI/hC7JVH2ruUWXxZ@9e51f","edbhttI/hC7JVH2ruUWXxZ@4a968","f1wxdlNdxKRI3e5dFO0k5a@6c48a","fcNNvb82FH4YN+PJ+8ckeu@1f97b","fcNNvb82FH4YN+PJ+8ckeu@17464","fcNNvb82FH4YN+PJ+8ckeu@935df","fcNNvb82FH4YN+PJ+8ckeu@3fdbc","fcNNvb82FH4YN+PJ+8ckeu@00773","fcNNvb82FH4YN+PJ+8ckeu@5fd32","fcNNvb82FH4YN+PJ+8ckeu@8a4cd"],["_effectAsset","node","root","_mesh","asset","data","mainTexture","_cpuMaterial","_mainTexture","_parent","targetInfo","_customMaterial","_spriteFrame","_particleSystem","target","_textureSource","head","_cameraComponent","GameWorld","playerFormationMgr","battleArrow","countLabel","projectileEmitter","_target","guideCamera","scene","projectileContainer","missText","text_3dpower","formationContainer","guidePrefab","archerLeaderPrefab","playerMaterial","_normalSprite","_hoverSprite","_pressedSprite","_disabledSprite","HitBluePrefab","ExplosionBluePrefab","TombstonePrefab","shadowPrefab","_envmapLDR","ArrowPrefab","MagicBallPrefab","gridPrefab","soldierPrefab","source","_skeleton","_defaultClip","_gpuMaterial","AddgridEffect","LevelUpEffect","MergeEffect","dropPointEffect"],[["cc.Node",["_name","_id","_layer","_active","_objFlags","__editorExtras__","_parent","_components","_prefab","_lpos","_children","_lscale","_lrot","_euler"],-3,1,9,4,5,2,5,5,5],["cc.ParticleSystemRenderer",["_renderMode","_alignSpace","_lengthScale","_velocityScale","_cpuMaterial","_mainTexture","_mesh","_gpuMaterial"],-1,6,6,6,6],["cc.ParticleSystem",["loop","playOnAwake","duration","_capacity","_dataCulling","scaleSpace","_prewarm","startSize3D","_aabbHalfX","_aabbHalfY","_aabbHalfZ","node","__prefab","_materials","startColor","startSizeX","startSizeY","startSizeZ","startSpeed","startRotationX","startRotationY","startRotationZ","startDelay","startLifetime","gravityModifier","rateOverTime","rateOverDistance","bursts","_sizeOvertimeModule","renderer","_shapeModule","_colorOverLifetimeModule","_rotationOvertimeModule","_trailModule","_velocityOvertimeModule","_forceOvertimeModule","_limitVelocityOvertimeModule","_textureAnimationModule","_noiseModule"],-8,1,4,12,4,4,4,4,4,4,4,4,4,4,4,4,4,9,4,4,4,4,4,4,4,4,4,4,4],["cc.RealKeyframeValue",["interpolationMode","rightTangent","leftTangent","value","rightTangentWeight","leftTangentWeight"],-3],["cc.Node",["_name","_layer","_active","_parent","_components","_lpos","_prefab","_lrot","_euler","_children","_lscale"],0,1,2,5,4,5,5,12,5],["cc.CurveRange",["mode","constant","multiplier","constantMin","constantMax","spline","splineMin","splineMax"],-2,4,4,4],"cc.ImageAsset",["cc.Node",["_name","_id","_active","_layer","_parent","_components","_lpos","_lrot","_euler","_children","_lscale"],-1,1,12,5,5,5,2,5],["cc.ShapeModule",["_enable","radius","emitFrom","_angle","_shapeType","length","radiusThickness","arcSpeed","_scale"],-4,4,5],"cc.SpriteFrame",["cc.Sprite",["_sizeMode","_type","_isTrimmedMode","node","_spriteFrame","_customMaterial","__prefab","_color"],0,1,6,6,4,5],["cc.Label",["_actualFontSize","_string","_fontSize","_horizontalAlign","_lineHeight","_isBold","_overflow","_enableWrapText","node","_color"],-5,1,5],["cc.TrailModule",["_enable","widthFromParticle","colorFromParticle","lifeTime","widthRatio","colorOverTrail","colorOvertime","_particleSystem"],0,4,4,4,4,1],["cc.UITransform",["node","_contentSize","__prefab","_anchorPoint"],3,1,5,4,5],["cc.MeshRenderer",["_name","node","bakeSettings","_mesh","__prefab","_materials"],2,1,4,6,4,3],["cc.ParticleSystem",["duration","_capacity","playOnAwake","scaleSpace","loop","node","__prefab","_materials","startColor","startSizeX","startSizeY","startSizeZ","startSpeed","startRotationX","startRotationY","startRotationZ","startDelay","startLifetime","gravityModifier","rateOverTime","rateOverDistance","bursts","_colorOverLifetimeModule","_shapeModule","_sizeOvertimeModule","_velocityOvertimeModule","_forceOvertimeModule","_limitVelocityOvertimeModule","_rotationOvertimeModule","_textureAnimationModule","_noiseModule","_trailModule","renderer"],-2,1,4,3,4,4,4,4,4,4,4,4,4,4,4,4,4,9,4,4,4,4,4,4,4,4,4,4,4],["cc.ColorKey",["time","color"],2,5],["cc.Prefab",["_name","persistent"],1],["cc.Material",["_name","_defines","_states","_techIdx","_props"],-1,12],["cc.Widget",["_alignFlags","_top","_bottom","_right","_originalWidth","_originalHeight","node"],-3,1],["cc.LabelOutline",["_width","node","_color"],2,1,5],["cc.Camera",["_far","_clearFlags","_visibility","_fov","_stencil","_priority","_projection","_orthoHeight","node","_color"],-5,1,5],["cc.GradientRange",["_mode","gradient","color"],2,4,5],["cc.AlphaKey",["alpha","time"],1],["cc.RotationOvertimeModule",["_enable","_separateAxes","x","y","z"],1,4,4,4],["cc.Node",["_name","_children","_prefab","_lpos","_lrot","_euler","_parent"],2,9,4,5,5,5,1],["cc.PrefabInfo",["fileId","instance","targetOverrides","nestedPrefabInstanceRoots","root","asset"],-1,1,1],["cc.Material",["_name","_props","_defines","_states"],-1],["cc.Mesh",["_native","_hash","_struct"],1,11],["cc.ModelBakeSettings",["_receiveShadow"],2],["cc.Gradient",["colorKeys","alphaKeys"],3,9,9],["cc.Burst",["repeatInterval","count"],2,4],["cc.ColorOvertimeModule",["_enable","color"],2,4],["cc.SizeOvertimeModule",["_enable","size","x","y","z"],2,4,4,4,4],["cc.LimitVelocityOvertimeModule",["_enable","dampen","limitX","limitY","limitZ","limit"],1,4,4,4,4],"cc.TextureCube",["cc.CompPrefabInfo",["fileId"],2],["cc.PrefabInfo",["root","asset","fileId","instance","targetOverrides","nestedPrefabInstanceRoots"],-2,2],["cc.PrefabInfo",["fileId","targetOverrides","nestedPrefabInstanceRoots","root","instance","asset"],0,1,4,6],["cc.PrefabInfo",["fileId","instance","root","asset","targetOverrides","nestedPrefabInstanceRoots"],1,1,1,9,2],["cc.PrefabInfo",["fileId","instance","targetOverrides","root","asset","nestedPrefabInstanceRoots"],0,1,1,2],["cc.SceneAsset",["_name"],2],["cc.Scene",["_name","autoReleaseAssets","_children","_prefab","_globals"],1,12,4,4],["cc.SceneGlobals",["ambient","shadows","_skybox","fog","octree","lightProbeInfo"],3,4,4,4,4,4,4],["cc.AmbientInfo",["_skyIllumHDR","_skyIllumLDR","_skyColorHDR","_groundAlbedoHDR","_skyColorLDR","_groundAlbedoLDR"],1,5,5,5,5],["cc.ShadowsInfo",["_distance","_shadowColor"],2,5],["cc.SkyboxInfo",["_envmapLDR"],3,6],["cc.FogInfo",[],3],["cc.OctreeInfo",[],3],["cc.LightProbeInfo",[],3],["cc.Canvas",["node","_cameraComponent"],3,1,1],["cc.RenderRoot2D",["node"],3,1],["26bc05K+ltI5oxBDdOpjIie",["node"],3,1],["be236EAEm9ISamzb+7OVBh1",["node","enemyMaterials","projectileEmitter","countLabel","battleArrow","playerFormationMgr","GameWorld","archerLeaderPrefab","playerMaterial","HitBluePrefab","ExplosionBluePrefab","TombstonePrefab"],3,1,3,1,1,1,1,1,6,6,6,6,6],["d909c6PLa9LWbJvnXhAu+qo",["node","shadowPrefab"],3,1,6],["cc.Button",["_transition","node","clickEvents","_normalColor","_target","_normalSprite","_hoverSprite","_pressedSprite","_disabledSprite"],2,1,9,5,1,6,6,6,6],["cc.ClickEvent",["_componentId","handler","target"],1,1],["cc.TargetInfo",["localID"],2],["cc.LabelShadow",["_blur","node","_color","_offset"],2,1,5,5],["8fb459LvFhNg7QABi11v9St",["node","guidePrefab"],3,1,6],["cc.PrefabInstance",["fileId","prefabRootNode","propertyOverrides"],1,9],["cc.PrefabInstance",["fileId","prefabRootNode","propertyOverrides"],2,1,9],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,1],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,8],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,4],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,8],["8636bqJMbRESohMLxyjHJAi",["node","guideCamera"],3,1,1],["cc.BoxCollider",["node","_size"],3,1,5],["cc.DirectionalLight",["_useColorTemperature","_colorTemperature","_illuminanceHDR","_shadowEnabled","node","_color","_staticSettings"],-1,1,5,4],["cc.StaticLightSettings",["_castShadow"],2],["a8772E3HVNBgL1hs+IbjLvp",["node"],3,1],["9167dgFhuVNhrOPo5tQ/fQw",["maxAngle","node","arrow","MagicBuffBlue","StarExplosionBlue","turntable"],2,1,1,1,1,1],["ff56eHxjSRFA59evq/7EIm0",["node","mainCamera"],3,1,1],["b4ff2+1BCVC35AKHTpOF5Xc",["node"],3,1],["49b22+/MvZCYLV3ERm0iEBk",["enableSquadRushTest","s_unitAngularSpeed","isSetArrowBuff","isAir_DropAward","isOpen_BossDes","isAltarModeOpen","enableGuide","width","height","isMapBoundarySquare","arrowAngles","arrowBuffs","assaultDuration","rushMaxSpeed","rushAcceleration","node"],-12,1],["c9c22o8nMZPS551t7atV1o2",["speed","node","__prefab","head"],2,1,4,1],["cc.TargetOverrideInfo",["propertyPath","source","sourceInfo","target","targetInfo"],2,1,4,1,4],["263d3NMUEhPjIE32BtmMAGo",["unitCat","radius","arrivalThreshold","wanderAngle","avoidDistance","avoidBuffer","isGeneral","node","__prefab"],-4,1,4],["cc.SkeletalAnimation",["playOnLoad","node","__prefab","_clips","_sockets","_defaultClip"],2,1,4,3,9,6],["cc.SkeletalAnimation.Socket",["path","target"],2,1],["cc.SkinnedMeshRenderer",["node","__prefab","bakeSettings","_skinningRoot","_mesh","_skeleton"],3,1,4,4,1,6,6],["cc.EffectAsset",["_name","shaders","techniques"],0],["cc.VelocityOvertimeModule",["x","y","z","speedModifier"],3,4,4,4,4],["cc.ForceOvertimeModule",["x","y","z"],3,4,4,4],["cc.TextureAnimationModule",["frameOverTime","startFrame"],3,4,4],["cc.RealCurve",["_times","_values"],2,9],["cc.NoiseModule",[],3],["5149e4AZlBE3YyC0kb+7yoQ",["node","__prefab","dropPointEffect","MergeEffect","LevelUpEffect","AddgridEffect"],3,1,4,1,1,1,1]],[[5,1],[26,0,1,2,3,4,5,5],[63,0,1,2,2],[5,1,2],[18,0,2,1,4,4],[62,0,1,2,3],[36,0,2],[57,0,2],[22,1],[29,1],[3,0,3,3],[0,4,5,6,8,3],[38,0,1,2,3,4,5,4],[60,0,1,2,3],[28,0,1,2,3],[0,0,6,7,8,2],[14,1,4,5,2,3,1],[0,0,10,8,2],[85,0,1,2],[17,1],[5,0,3,4,4],[5,0,5,2],[82,0,1,2,3,1],[83,0,1,2,1],[84,0,1,1],[86,1],[33,0,1,2,3,4,2],[22,0,1,2],[22,2,1],[16,1],[23,0,1,3],[32,0,1,2],[24,2,3,4,1],[0,0,6,10,8,9,12,13,2],[31,0,1,2],[12,3,4,5,6,1],[34,0,1,2,3,4,5,3],[30,0,1],[17,0,2],[16,1,1],[31,1,1],[13,0,1,1],[1,4,5,1],[0,0,6,8,9,12,13,2],[14,0,1,5,2,3,2],[34,2,3,4,5,1],[16,0,1,2],[8,2,7,2],[8,0,4,1,6,7,5],[33,1,2,3,4,1],[4,0,3,4,6,10,2],[13,0,1],[64,0,1,2,3],[79,0,1,2],[15,3,0,4,1,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,5],[30,0,1,1],[32,1,1],[24,0,2,3,4,2],[3,0,3,1,4,2,5,7],[3,3,1,4,2,5,6],[0,0,6,10,7,8,2],[0,0,6,7,8,11,2],[13,0,2,1,1],[28,0,2,2],[51,0,1],[15,3,0,4,2,1,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,6],[2,2,6,3,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,31,30,28,34,35,36,32,37,38,33,29,4],[8,7,1],[3,0,3,1,2,5],[3,1,4,2,5,5],[12,1,3,4,5,6,7,2],[0,0,1,6,3],[0,0,1,6,7,3],[0,0,6,7,9,12,11,13,2],[0,0,6,7,8,12,13,2],[25,0,6,1,2,3,4,5,2],[13,0,1,3,1],[18,0,3,2,1,4,5],[14,1,4,2,3,1],[16,0,2],[5,0,6,7,2],[8,0,4,1,7,4],[17,0,1,3],[0,0,2,6,7,3],[0,0,6,7,9,11,2],[0,0,3,6,7,8,11,3],[0,0,6,7,8,9,2],[0,0,10,8,12,13,2],[0,0,6,8,9,2],[0,0,6,8,9,12,11,13,2],[0,0,10,7,8,9,12,13,2],[0,0,10,7,8,12,13,2],[25,0,1,2,3,4,5,2],[10,3,6,7,5,4,1],[10,0,2,3,5,4,3],[27,0,1,3,2,5],[61,0,1,2,2],[65,0,1,2,2],[75,0,1,2,3,2],[2,5,2,0,1,3,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,31,30,28,34,35,36,32,37,38,33,29,6],[2,5,7,2,1,8,9,10,3,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,31,30,28,34,35,36,32,37,38,33,29,9],[23,1],[23,0,2],[8,0,2,1,3,7,5],[3,0,2],[1,6,4,5,1],[1,0,6,4,5,2],[1,0,3,2,4,5,4],[1,0,1,6,4,5,3],[1,0,3,4,5,3],[0,0,7,8,9,12,11,13,2],[0,0,4,3,10,9,4],[0,0,1,6,9,3],[0,0,2,1,6,10,7,9,4],[0,0,4,1,6,10,7,11,4],[0,0,2,6,10,7,9,11,3],[0,0,6,10,7,2],[0,0,3,1,6,10,4],[0,0,2,1,6,10,7,4],[0,0,2,6,7,9,3],[0,0,6,7,9,2],[0,0,1,6,10,7,9,3],[0,0,4,6,7,9,11,3],[0,0,3,2,6,7,9,12,11,13,4],[0,0,1,6,7,9,12,13,3],[0,0,6,9,2],[0,0,1,6,7,9,3],[0,0,10,7,8,9,2],[0,0,10,7,8,11,2],[0,0,6,10,8,9,12,11,13,2],[0,0,6,10,8,9,2],[0,0,6,7,8,9,12,13,2],[0,0,7,8,9,11,2],[0,0,3,6,7,8,3],[0,0,6,10,8,2],[0,0,6,10,8,11,2],[0,0,6,7,8,9,12,11,13,2],[0,0,6,7,8,12,11,13,2],[0,0,10,8,12,11,13,2],[0,0,10,7,8,9,11,2],[7,0,1,4,5,3],[7,0,1,4,9,5,6,7,10,8,3],[7,0,4,9,5,6,7,8,2],[7,0,4,5,6,2],[7,0,2,3,4,5,6,4],[7,0,1,4,5,6,7,8,3],[4,0,1,3,4,5,7,8,3],[4,0,1,3,4,5,3],[4,0,9,6,5,7,8,2],[4,0,3,9,6,5,7,8,2],[4,0,3,4,6,5,2],[4,0,2,3,4,6,10,3],[10,1,0,3,4,3],[10,3,5,4,1],[10,0,3,6,7,5,4,2],[26,0,1,3,2,4,5,5],[37,0,1,2,3,4,5,6],[39,0,1,2,3,4,5,3],[40,0,1,2,3,4,5,4],[18,0,1,4,3],[27,0,1,2,4],[14,0,1,4,5,2,3,2],[29,0,2],[41,0,2],[42,0,1,2,3,4,3],[43,0,1,2,3,4,5,1],[44,0,1,2,3,4,5,3],[45,0,1,2],[46,0,1],[47,1],[48,1],[49,1],[50,0,1,1],[19,0,1,2,6,4],[19,0,3,1,6,4],[19,0,4,5,6,4],[52,0,1],[53,0,1,2,3,4,5,6,7,8,9,10,11,1],[54,0,1,1],[55,0,1,2,3,4,5,6,7,8,2],[56,0,1,2,3],[20,0,1,2],[20,0,1,2,2],[20,1,2,1],[58,0,1,2,3,2],[59,0,1,1],[11,1,0,5,8,4],[11,1,0,2,6,7,8,9,6],[11,3,0,2,8,9,4],[11,1,3,0,2,4,8,6],[11,1,0,2,4,8,5],[66,0,1,1],[67,0,1,1],[68,0,1,2,3,4,5,6,5],[69,0,2],[21,3,0,4,1,2,8,6],[21,5,3,0,4,1,2,7],[21,6,5,7,0,1,2,8,9,7],[70,0,1],[71,0,1,2,3,4,5,2],[72,0,1,1],[73,0,1],[74,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],[76,0,1,2,3,4,2],[77,0,1,2,3,4,5,6,7,8,8],[78,0,1,2,3,4,5,2],[80,0,1,2,3,4,5,1],[81,0,1,2,4],[15,0,2,1,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,4],[15,0,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,2],[2,5,2,0,3,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,31,30,28,34,35,36,32,37,38,33,29,5],[2,0,1,4,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,30,28,32,29,4],[2,0,1,4,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,4],[2,0,1,4,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,30,28,29,4],[2,0,1,4,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,31,28,33,29,4],[5,1,2,3],[5,0,2,5,3],[8,0,1,5,3,7,8,5],[24,0,1,2,3,4,3],[3,0,4,5,4],[3,0,1,2,4],[12,0,1,3,4,5,6,7,3],[12,0,1,2,3,4,5,6,7,4],[12,0,3,4,5,6,7,2],[1,0,1,4,5,3],[1,0,4,5,2],[1,0,2,4,5,3],[1,0,3,2,4,7,5,4],[1,0,3,2,1,6,4,5,5],[1,0,1,6,4,3],[87,0,1,2,3,4,5,1]],[[[[38,"shadow"],[110,"shadow",[[62,-2,[6,"b8n1dHcs5LnogNLD53UBdu"],[5,441,440]],[93,-3,[6,"8fF4KHDRFCZJWoUrjtnAIB"],[4,4278190080],0,1]],[1,"1a33fxVQxC8qORn942qdev",null,null,null,-1,0],[1,0.822,0.02,10.425],[3,-0.7071067811865475,0,0,0.7071067811865476],[1,0.006,0.006,0.006],[1,-90,0,0]]],0,[0,2,1,0,1,1,0,1,1,0,5,1,3],[0,0],[11,12],[5,50]],[[[4,"Stone",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4287136633],"emissive",8,[4,4287136633]]],11]]],0,0,[0],[0],[0]],[[[14,".bin",3060236400,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":38064,"length":5472,"count":1368,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":38064,"count":793,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.9999993443489075,2.2713838632171246e-7,-0.9999992251396179],"maxPosition",8,[1,0.37781617045402527,1.152435064315796,0.37781545519828796]]],-1],0,0,[],[],[]],[[[19],[17,"wall_corner",[-2],[1,"606dsP52ta/bVgrqFzmia+",null,null,null,-1,0]],[15,"wall_corner",1,[[16,-3,[6,"bfPHw8UQZUyoAb6K0odb+G"],[0],[9],1]],[1,"65J2934C9ad4YMK41hPd6c",null,null,null,1,0]]],0,[0,2,1,0,-1,2,0,1,2,0,5,1,3],[0,0],[-1,3],[51,52]],[[[77,"material-012",1,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"tintColor",8,[4,2130706648],"mainTexture",6,0]],11]]],0,0,[0,0],[6,0],[3,1]],[[[163,"game"],[111,"node",512,false,[-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39],[1,5,0,8]],[164,"game",true,[[-81,-82,-83,-84,-85,[112,"EnemySoldierContainer","8bI5hs73JEAYhujTX6K8Bl",-86,[1,0,0,13]],-87,[71,"TombstoneContainer","ddEAszo0xGs5V8Vk1BCtbo",-88],-89,-90,-91,-92,-93,-94,-95,-96,-97],1,1,1,1,1,4,1,4,1,1,1,1,1,1,1,1,1],[156,null,null,"0701bc47-1aa5-4fde-a839-c9564fcf880b",null,null,[-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]],[165,[166,70000,0.8,[2,0.402431,0.624883,0.99878,1.8229159375],[2,0.501042,0.443853,0.408004,0],[2,0.452588,0.607642,0.755699,0],[2,0.618555,0.577848,0.544564,0]],[167,0.01,[4,4280887593]],[168,75],[169],[170],[171]]],[113,"Canvas",33554432,"38UkEK83JNDJLtw+kKi/5J",2,[-102,-103,-104,-105,-106],[[41,-98,[5,1080,1920]],[172,-100,-99],[173,45,-1.1368683772161603e-13,-1.1368683772161603e-13,-101]],[1,540,959.9999999999999,0]],[114,"Environment",512,"2eUmjCWnRLdIC221Du7Zmo",2,[-109,1,-110,-111],[[51,-107],[64,-108]],[1,10,10,10]],[140,"GameCtrl","7bLqfqyXFC9bZ5SkGwqwzN",2,[[[176,-112],[177,-118,[48,49],-117,-116,-115,-114,-113,46,47,55,56,63],-119,-120,[178,-121,64]],4,4,1,1,4]],[141,"BattleArrow","3dfpQmc8pK0YJRQYXAnQ8I",2,[-125,-126,-127],[[[51,-122],[64,-123],-124],4,4,1],[1,0,0.05,1.6],[3,-0.7071067811865475,0,0,0.7071067811865476],[1,0.015,0.015,0.015],[1,-90,0,0]],[115,"Button",33554432,3,[-132],[[41,-128,[5,100,40]],[152,1,0,-129,50],[179,2,-131,[[180,"26bc05K+ltI5oxBDdOpjIie","openCheaterUI",5]],[4,4292269782],-130,51,52,53,54]],[1,457.708,0,0],[1,1.3,1.3,1]],[142,"Miss",6,[-136,-137],[[[41,-133,[5,192,87.6]],-134,[181,6,-135]],4,1,4],[1,0,300,250],[3,0.7071067811865475,0,0,0.7071067811865476],[1,90,0,0]],[7,["59DC7Jl6FSGbnmh7R6CKSw"]],[7,["c4LJ9jiRVSPLe9zSJfp4ep"]],[7,["3bOkID8IdRIpPtzTsDa0zJ"]],[7,["bey5PBKlJYwKzK2U8WWbFk"]],[7,["06q8bXbxtaFL5Lb+Tp3u8p"]],[7,["7b+UM53ahYJ75Pl0xQ772k"]],[7,["1cFZRQtIxYBY33Rt1gllrr"]],[7,["c6nN0Zi/FfTa0pFPzCfQDP"]],[7,["5eAuWkKMRejop04tjMb5q/"]],[7,["a0vP15IIpfAKdgSklTl1lQ"]],[7,["44gpMHLDdZBJSLZ/87jJX2"]],[7,["026DiC+npYBqhs90Rl7PXo"]],[7,["a4K9bi/XBTr4e3gZlzYVtr"]],[7,["75THaENV1fgYQv5nw/oO5m"]],[7,["24Ys2U9jpV+qVYrD2vvkNf"]],[7,["00knp1gOxWX7tvjA9HJdYE"]],[7,["f16fPRMOlZE75uC/M+GpMx"]],[7,["1049DupJpQf5UnBb4YUKhX"]],[7,["dbiC/T3S5cFKURapLrUyWC"]],[7,["91NVVIJM5ZJL8o4UPyILuR"]],[7,["83SeZfoXpYxqDSeafSTC8H"]],[7,["606dsP52ta/bVgrqFzmia+"]],[7,["66FDFaqbFb2LUhzGHgFhmQ"]],[7,["1dWTsuPdVe0aFp0lKbQRVO"]],[7,["48IKuE6LFQsakdro5S/Lru"]],[7,["b9LeX+yddS4KlmZCJ+LzYx"]],[7,["43CjQ1wAtXNqJKb6tJjYAi"]],[7,["28/ZOZhUBWpIZ5IHsZ/JcR"]],[7,["a6s/76YylUDath8HJKWyRJ"]],[7,["b9LeX+yddS4KlmZCJ+LzYx"]],[7,["b9LeX+yddS4KlmZCJ+LzYx"]],[7,["b9LeX+yddS4KlmZCJ+LzYx"]],[7,["b9LeX+yddS4KlmZCJ+LzYx"]],[7,["b9LeX+yddS4KlmZCJ+LzYx"]],[7,["b9LeX+yddS4KlmZCJ+LzYx"]],[7,["b9LeX+yddS4KlmZCJ+LzYx"]],[7,["b9LeX+yddS4KlmZCJ+LzYx"]],[7,["b9LeX+yddS4KlmZCJ+LzYx"]],[116,"turntable",6,[-140],[[41,-138,[5,512,512]],[94,0,false,-139,59,60]]],[143,"3dpower",6,[[[76,-141,[5,265.06,128.4],[0,0,0.5]],-142,[182,5,-143,[4,4279247135]],[184,0,-144,[4,4279247135],[0,0,-5]]],4,1,4,4],[1,239.733,125.867,0]],[7,["8a/WkRPe9ALpn4wJuqyitk"]],[7,["7988Dy/L9KXqtFQ+QIditz"]],[117,"walls",false,"dcvMtsfa1CobHIUrKc9yq8",2,[-145,-146,-147,-148]],[118,"GuideManager",524288,"c3wRv0fTpMuaXXw+PH+eLA",2,[-151],[[51,-149],[185,-150,0]]],[7,["f09whsSkpY+LhHmv+P0e4F"]],[144,"countLabel",false,33554432,3,[[[76,-152,[5,42.26,50.4],[0,1,0.5]],-153,[174,33,30,30,-154]],4,1,4],[1,510,904.8,0]],[119,"initTipLabel",33554432,3,[[41,-155,[5,277.34,54.4]],[186,"战场初始化中...",40,true,-156],[183,-157,[4,4294911003]]],[1,0,-102.436,0]],[120,"arrow",47,[[76,-158,[5,512,512],[0,0.5,0.47]],[94,0,false,-159,57,58]],[1,0,-24.999999999999986,-4.440892098500626e-16]],[11,0,{},8,[12,"8a/WkRPe9ALpn4wJuqyitk",null,null,-160,[13,"72L2Og5PdATIA/b8i83258",null,[[5,"MagicBuffBlue",["_name"],49],[2,["_lpos"],49,[1,0,-150,0]],[2,["_lrot"],49,[3,0,0,0,1]],[2,["_euler"],49,[1,0,0,0]],[2,["_lscale"],49,[1,20,20,20]],[52,false,["playOnAwake"],[7,["0eiEi3TnNHH6XG/kt1Opp5"]]]]],61]],[11,0,{},8,[12,"7988Dy/L9KXqtFQ+QIditz",null,null,-161,[13,"c00XM6MABHS4C/FIzATb2Y",null,[[5,"StarExplosionBlue",["_name"],50],[2,["_lpos"],50,[1,0,-150,0]],[2,["_lrot"],50,[3,0,0,0,1]],[2,["_euler"],50,[1,0,0,0]],[2,["_lscale"],50,[1,20,20,20]],[52,false,["playOnAwake"],[7,["caF56kmatNaJ3527GOvbWs"]]],[52,false,["playOnAwake"],[7,["13Kc22DFZD1pxG9mZkcQq9"]]],[52,false,["playOnAwake"],[7,["e7i8mXCfRClZ/NzzP5ref/"]]],[52,false,["playOnAwake"],[7,["84YW3gpU9Bd4ye82ahmtcI"]]]]],62]],[121,"MySoldierContainer","d0fOnLCudLYJ/KHvfU1vTy",2,[-164],[[51,-162],[64,-163]],[1,0,0,13]],[145,"Main Camera","c9DMICJLFO5IeO07EPon7U",2,[[-165,[191,-167,-166]],1,4],[1,14.084,50.871,39.74],[3,-0.4106109794497304,0.13213110165659778,0.06027132252493235,0.9001707411438357],[1,-49.04,16.701,0]],[122,"Plane",512,4,[[44,"Plane<ModelComponent>",-168,[1],[162,true],2],[192,-169,[1,10,0.001,10]]],[1,4.694,-0.01,2.968],[1,2,2,2]],[11,512,null,1,[12,"59DC7Jl6FSGbnmh7R6CKSw",null,null,-170,[13,"e1JIUoaC1O24jAq9++hqKD",null,[[5,"archeryrange",["_name"],9],[2,["_lpos"],9,[1,8,0,-8]],[2,["_lrot"],9,[3,0,0,0,1]],[2,["_euler"],9,[1,0,0,0]],[5,false,["_active"],9]]],3]],[11,512,null,1,[12,"c4LJ9jiRVSPLe9zSJfp4ep",null,null,-171,[13,"211mKIFG5LLIZxPGCYZtyy",null,[[5,"barracks",["_name"],10],[2,["_lpos"],10,[1,4.8,0,-8]],[2,["_lrot"],10,[3,0,0,0,1]],[2,["_euler"],10,[1,0,0,0]],[5,false,["_active"],10]]],4]],[11,512,null,1,[12,"3bOkID8IdRIpPtzTsDa0zJ",null,null,-172,[13,"26SQw4ws5BUbO+Mh0a0det",null,[[5,"bridge",["_name"],11],[2,["_lpos"],11,[1,1.5999999999999996,0,-8]],[2,["_lrot"],11,[3,0,0,0,1]],[2,["_euler"],11,[1,0,0,0]],[5,false,["_active"],11]]],5]],[11,512,null,1,[12,"bey5PBKlJYwKzK2U8WWbFk",null,null,-173,[13,"e0znq17F1Kmp8fVeSywXZJ",null,[[5,"bridge_roofed",["_name"],12],[2,["_lpos"],12,[1,-1.6000000000000014,0,-8]],[2,["_lrot"],12,[3,0,0,0,1]],[2,["_euler"],12,[1,0,0,0]],[5,false,["_active"],12]]],6]],[11,512,null,1,[12,"06q8bXbxtaFL5Lb+Tp3u8p",null,null,-174,[13,"a9tFmQd/5B/pZnPjj6qJKp",null,[[5,"castle",["_name"],13],[2,["_lpos"],13,[1,-4.800000000000001,0,-8]],[2,["_lrot"],13,[3,0,0,0,1]],[2,["_euler"],13,[1,0,0,0]],[5,false,["_active"],13]]],7]],[11,512,null,1,[12,"7b+UM53ahYJ75Pl0xQ772k",null,null,-175,[13,"8bqsrSI1VKOaQ0IHVWQCmh",null,[[5,"detail_forestA",["_name"],14],[2,["_lpos"],14,[1,-6.196,0,-18.872]],[2,["_lrot"],14,[3,0,0,0,1]],[2,["_euler"],14,[1,0,0,0]],[5,true,["_active"],14]]],8]],[11,512,null,1,[12,"1cFZRQtIxYBY33Rt1gllrr",null,null,-176,[13,"4fz/rV2kJKz4qKoLYhdY59",null,[[5,"detail_forestB",["_name"],15],[2,["_lpos"],15,[1,-9.475,0,-13.684]],[2,["_lrot"],15,[3,0,0,0,1]],[2,["_euler"],15,[1,0,0,0]],[5,true,["_active"],15]]],9]],[11,512,null,1,[12,"c6nN0Zi/FfTa0pFPzCfQDP",null,null,-177,[13,"e8iDvSMhhDcpH2PXqYR7p5",null,[[5,"detail_hill",["_name"],16],[2,["_lpos"],16,[1,1.5999999999999996,0,-4.8]],[2,["_lrot"],16,[3,0,0,0,1]],[2,["_euler"],16,[1,0,0,0]],[5,false,["_active"],16]]],10]],[11,512,null,1,[12,"5eAuWkKMRejop04tjMb5q/",null,null,-178,[13,"9e2JRWz3xEj4GdW8aFfPfF",null,[[5,"detail_rocks",["_name"],17],[2,["_lpos"],17,[1,-3.607,0,-19.068]],[2,["_lrot"],17,[3,0,0,0,1]],[2,["_euler"],17,[1,0,0,0]],[5,true,["_active"],17]]],11]],[11,512,null,1,[12,"a0vP15IIpfAKdgSklTl1lQ",null,null,-179,[13,"1aS0RUIc5NqYetqwZjjgvA",null,[[5,"detail_rocks_small",["_name"],18],[2,["_lpos"],18,[1,-4.800000000000001,0,-4.8]],[2,["_lrot"],18,[3,0,0,0,1]],[2,["_euler"],18,[1,0,0,0]],[5,false,["_active"],18]]],12]],[11,512,null,1,[12,"44gpMHLDdZBJSLZ/87jJX2",null,null,-180,[13,"64McK6TY1DOKRIEW0dutbq",null,[[5,"detail_treeA",["_name"],19],[2,["_lpos"],19,[1,8,0,-1.5999999999999996]],[2,["_lrot"],19,[3,0,0,0,1]],[2,["_euler"],19,[1,0,0,0]],[5,false,["_active"],19]]],13]],[11,512,null,1,[12,"026DiC+npYBqhs90Rl7PXo",null,null,-181,[13,"63xiSeZl1KBrsG/GnPtQQJ",null,[[5,"detail_treeB",["_name"],20],[2,["_lpos"],20,[1,4.8,0,-1.5999999999999996]],[2,["_lrot"],20,[3,0,0,0,1]],[2,["_euler"],20,[1,0,0,0]],[5,false,["_active"],20]]],14]],[11,512,null,1,[12,"a4K9bi/XBTr4e3gZlzYVtr",null,null,-182,[13,"2eOvKNmeNKabbA6WNoTGAu",null,[[5,"detail_treeC",["_name"],21],[2,["_lpos"],21,[1,1.5999999999999996,0,-1.5999999999999996]],[2,["_lrot"],21,[3,0,0,0,1]],[2,["_euler"],21,[1,0,0,0]],[5,false,["_active"],21]]],15]],[11,512,null,1,[12,"75THaENV1fgYQv5nw/oO5m",null,null,-183,[13,"6fsvyhUtlIEoiWyWbF5WeA",null,[[5,"farm_plot",["_name"],22],[2,["_lpos"],22,[1,-1.6000000000000014,0,-1.5999999999999996]],[2,["_lrot"],22,[3,0,0,0,1]],[2,["_euler"],22,[1,0,0,0]],[5,false,["_active"],22]]],16]],[11,512,null,1,[12,"24Ys2U9jpV+qVYrD2vvkNf",null,null,-184,[13,"5f0YFb+qNF64KP3PhZ9brl",null,[[5,"forest",["_name"],23],[2,["_lpos"],23,[1,-4.800000000000001,0,-1.5999999999999996]],[2,["_lrot"],23,[3,0,0,0,1]],[2,["_euler"],23,[1,0,0,0]],[5,false,["_active"],23]]],17]],[11,512,null,1,[12,"00knp1gOxWX7tvjA9HJdYE",null,null,-185,[13,"0cMw8915RELJ/Late2kcr8",null,[[5,"house",["_name"],24],[2,["_lpos"],24,[1,-9.654,0,-18]],[2,["_lrot"],24,[3,0,0,0,1]],[2,["_euler"],24,[1,0,0,0]],[5,true,["_active"],24]]],18]],[11,512,null,1,[12,"f16fPRMOlZE75uC/M+GpMx",null,null,-186,[13,"db5yghsHpL9L7fiRM47aDp",null,[[5,"lumbermill",["_name"],25],[2,["_lpos"],25,[1,4.8,0,1.6000000000000014]],[2,["_lrot"],25,[3,0,0,0,1]],[2,["_euler"],25,[1,0,0,0]],[5,false,["_active"],25]]],19]],[11,512,null,1,[12,"1049DupJpQf5UnBb4YUKhX",null,null,-187,[13,"bbONPmRmZLuJvQmqMio5BZ",null,[[5,"market",["_name"],26],[2,["_lpos"],26,[1,1.5999999999999996,0,1.6000000000000014]],[2,["_lrot"],26,[3,0,0,0,1]],[2,["_euler"],26,[1,0,0,0]],[5,false,["_active"],26]]],20]],[11,512,null,1,[12,"dbiC/T3S5cFKURapLrUyWC",null,null,-188,[13,"44WgQ33X1MNZvntgA6VnGS",null,[[5,"mill",["_name"],27],[2,["_lpos"],27,[1,-1.6000000000000014,0,-20]],[2,["_lrot"],27,[3,0,0,0,1]],[2,["_euler"],27,[1,0,0,0]],[5,true,["_active"],27]]],21]],[11,512,null,1,[12,"91NVVIJM5ZJL8o4UPyILuR",null,null,-189,[13,"f7GZbGpW9CxrHeDZ9HP6gt",null,[[5,"mine",["_name"],28],[2,["_lpos"],28,[1,-4.800000000000001,0,1.6000000000000014]],[2,["_lrot"],28,[3,0,0,0,1]],[2,["_euler"],28,[1,0,0,0]],[5,false,["_active"],28]]],22]],[11,512,null,1,[12,"83SeZfoXpYxqDSeafSTC8H",null,null,-190,[13,"53hLrrd/xHiaaqh9it9D2M",null,[[5,"mountain",["_name"],29],[2,["_lpos"],29,[1,8,0,4.800000000000001]],[2,["_lrot"],29,[3,0,0,0,1]],[2,["_euler"],29,[1,0,0,0]],[5,false,["_active"],29]]],23]],[11,512,null,1,[12,"606dsP52ta/bVgrqFzmia+",null,null,-191,[13,"15Y7jY/oNBnbX7xjuM5524",null,[[5,"wall_corner",["_name"],30],[2,["_lpos"],30,[1,-12,0,-15]],[2,["_lrot"],30,[3,0,1,0,6.123233995736766e-17]],[2,["_euler"],30,[1,0,180,0]],[5,true,["_active"],30]]],24]],[11,512,null,1,[12,"66FDFaqbFb2LUhzGHgFhmQ",null,null,-192,[13,"30M0NG4lxPnKNcHvveqT5F",null,[[5,"wall_gate",["_name"],31],[2,["_lpos"],31,[1,1.5999999999999996,0,4.800000000000001]],[2,["_lrot"],31,[3,0,0,0,1]],[2,["_euler"],31,[1,0,0,0]],[5,false,["_active"],31]]],25]],[11,512,null,1,[12,"f09whsSkpY+LhHmv+P0e4F",null,null,-193,[13,"8e+FRry+pITZ+mLmhhe7tv",null,[[5,"wall_gate_closed",["_name"],53],[2,["_lpos"],53,[1,-6,0,-15]],[2,["_lrot"],53,[3,0,0,0,1]],[2,["_euler"],53,[1,0,0,0]]]],26]],[11,512,null,1,[12,"1dWTsuPdVe0aFp0lKbQRVO",null,null,-194,[13,"31fsxnPgZKu5f2xW2jovpP",null,[[5,"wall_hexCornerA",["_name"],32],[2,["_lpos"],32,[1,-4.800000000000001,0,4.800000000000001]],[2,["_lrot"],32,[3,0,0,0,1]],[2,["_euler"],32,[1,0,0,0]],[5,false,["_active"],32]]],27]],[11,512,null,1,[12,"48IKuE6LFQsakdro5S/Lru",null,null,-195,[13,"b3W1pSgdlK+YjB0tfNsIoW",null,[[5,"wall_hexCornerB",["_name"],33],[2,["_lpos"],33,[1,8,0,8]],[2,["_lrot"],33,[3,0,0,0,1]],[2,["_euler"],33,[1,0,0,0]],[5,false,["_active"],33]]],28]],[11,512,null,1,[12,"b9LeX+yddS4KlmZCJ+LzYx",null,null,-196,[13,"5fpyAuArpK0IUIXfkdVT0X",null,[[5,"wall_straight",["_name"],34],[2,["_lpos"],34,[1,-2,0,-15]],[2,["_lrot"],34,[3,0,0,0,1]],[2,["_euler"],34,[1,0,0,0]],[5,true,["_active"],34]]],29]],[11,512,null,1,[12,"43CjQ1wAtXNqJKb6tJjYAi",null,null,-197,[13,"8daJfboRNKsIg0UjlY/k2H",null,[[5,"watchtower",["_name"],35],[2,["_lpos"],35,[1,-13.772,0,-18]],[2,["_lrot"],35,[3,0,0,0,1]],[2,["_euler"],35,[1,0,0,0]],[5,true,["_active"],35]]],30]],[11,512,null,1,[12,"28/ZOZhUBWpIZ5IHsZ/JcR",null,null,-198,[13,"5bxvezFB1GpJ919mYoy18S",null,[[5,"watermill",["_name"],36],[2,["_lpos"],36,[1,-1.6000000000000014,0,8]],[2,["_lrot"],36,[3,0,0,0,1]],[2,["_euler"],36,[1,0,0,0]],[5,false,["_active"],36]]],31]],[11,512,null,1,[12,"a6s/76YylUDath8HJKWyRJ",null,null,-199,[13,"9eBzA0Y+JBmLzWfJMXl5Oj",null,[[5,"well",["_name"],37],[2,["_lpos"],37,[1,-4.800000000000001,0,8]],[2,["_lrot"],37,[3,0,0,0,1]],[2,["_euler"],37,[1,0,0,0]],[5,false,["_active"],37]]],32]],[11,512,null,1,[12,"b9LeX+yddS4KlmZCJ+LzYx",null,null,-200,[13,"39O4rAukdCuI+2LOoB4QJa",null,[[5,"wall_straight-001",["_name"],38],[2,["_lpos"],38,[1,-4,0,-15]],[2,["_lrot"],38,[3,0,0,0,1]],[2,["_euler"],38,[1,0,0,0]],[5,true,["_active"],38]]],33]],[11,512,null,1,[12,"b9LeX+yddS4KlmZCJ+LzYx",null,null,-201,[13,"03+uPX7hVFFIxhnU2poLw5",null,[[5,"wall_straight-002",["_name"],39],[2,["_lpos"],39,[1,0,0,-15]],[2,["_lrot"],39,[3,0,0,0,1]],[2,["_euler"],39,[1,0,0,0]],[5,true,["_active"],39]]],34]],[11,512,null,1,[12,"b9LeX+yddS4KlmZCJ+LzYx",null,null,-202,[13,"bcGEmAIcdETJJiSCPVSeeL",null,[[5,"wall_straight-003",["_name"],40],[2,["_lpos"],40,[1,-8,0,-15]],[2,["_lrot"],40,[3,0,0,0,1]],[2,["_euler"],40,[1,0,0,0]],[5,true,["_active"],40]]],35]],[11,512,null,1,[12,"b9LeX+yddS4KlmZCJ+LzYx",null,null,-203,[13,"c4f7KpjFhFUoIk23hAd1oD",null,[[5,"wall_straight-004",["_name"],41],[2,["_lpos"],41,[1,-10,0,-15]],[2,["_lrot"],41,[3,0,0,0,1]],[2,["_euler"],41,[1,0,0,0]],[5,true,["_active"],41]]],36]],[11,512,null,1,[12,"b9LeX+yddS4KlmZCJ+LzYx",null,null,-204,[13,"e98flbMIRCYY/Qefo7qIGR",null,[[5,"wall_straight-005",["_name"],42],[2,["_lpos"],42,[1,-12,0,-13]],[2,["_lrot"],42,[3,0,0.7071067811865475,0,0.7071067811865476]],[2,["_euler"],42,[1,0,90,0]],[5,true,["_active"],42]]],37]],[11,512,null,1,[12,"b9LeX+yddS4KlmZCJ+LzYx",null,null,-205,[13,"17hfKJ371PnILHd2oPVq63",null,[[5,"wall_straight-006",["_name"],43],[2,["_lpos"],43,[1,-12,0,-11]],[2,["_lrot"],43,[3,0,0.7071067811865475,0,0.7071067811865476]],[2,["_euler"],43,[1,0,90,0]],[5,true,["_active"],43]]],38]],[11,512,null,1,[12,"b9LeX+yddS4KlmZCJ+LzYx",null,null,-206,[13,"4cxE/Sk+JOTKPx/dGa6fso",null,[[5,"wall_straight-007",["_name"],44],[2,["_lpos"],44,[1,-12,0,-9]],[2,["_lrot"],44,[3,0,0.7071067811865475,0,0.7071067811865476]],[2,["_euler"],44,[1,0,90,0]],[5,true,["_active"],44]]],39]],[11,512,null,1,[12,"b9LeX+yddS4KlmZCJ+LzYx",null,null,-207,[13,"256ap9lAlFE4vN5/K1q7nU",null,[[5,"wall_straight-008",["_name"],45],[2,["_lpos"],45,[1,-12,0,-7]],[2,["_lrot"],45,[3,0,0.7071067811865475,0,0.7071067811865476]],[2,["_euler"],45,[1,0,90,0]],[5,true,["_active"],45]]],40]],[11,512,null,1,[12,"b9LeX+yddS4KlmZCJ+LzYx",null,null,-208,[13,"6d/DQtkXNF742ABjWmPH2M",null,[[5,"wall_straight-009",["_name"],46],[2,["_lpos"],46,[1,-12,0,-5]],[2,["_lrot"],46,[3,0,0.7071067811865475,0,0.7071067811865476]],[2,["_euler"],46,[1,0,90,0]],[5,true,["_active"],46]]],41]],[123,"plane",false,8388608,4,[[41,-209,[5,2160,2340]],[153,-210,42,43]],[1,-0.152,-3.242,-0.772],[3,-0.6129413156246744,0.09436508870766472,0.0830413811227996,0.7800655758682766],[1,0.01,0.010000000000000004,0.01],[1,-76.418,14.421,0.795]],[83,"uiContainer",33554432,3,[[41,-211,[5,1080,1920]],[175,45,100,100,-212]]],[83,"Label",33554432,7,[[41,-213,[5,100,40]],[187,"button",20,20,1,false,-214,[4,4278190080]]]],[72,"SoldierShadowContainer","8eVNjHg6hBBoXlQVrVumNW",2,[[51,-215],[64,-216]]],[124,"Main Light","c0y6F5f+pAvI805TdmxIjx",2,[[193,true,15000,105000,true,-217,[4,4293982975],[194,true]]],[1,-43.009,48.058,71.085],[3,-0.43825314196857557,-0.31490280134751825,-0.16726058246354933,0.82510260380883],[1,-55.95,-41.779,0]],[195,55,500,-25,6,1083179008,60],[196,10737418245,55,500,-25,6,524288],[146,"Guide Camera",524288,52,[107],[1,14.084,50.871,39.74],[3,-0.4106109794497304,0.13213110165659778,0.06027132252493235,0.9001707411438357],[1,-49.04,16.701,0]],[73,"Plane-001",4,[[44,"Plane<ModelComponent>",-218,[44],[9],45]],[1,-0.148,-1.748,-0.572],[3,0.1611117932850571,0.12384891588907508,-0.020383149876253295,0.9789223479411919],[1,2,2,2],[1,18.692,14.421,0]],[198,5],[71,"ProjectileContainer","4bwXjAme5EtaTvZhN39zhe",2],[188,2,20,20,54,[4,4278190335]],[147,"UI Camera",33554432,3,[-219],[1,0,0,1000]],[197,0,1073741824,960,2000,6,33554432,113,[4,4278190080]],[199,60,6,56,57,58,47],[189,"战力:0",0,90,90,90,48],[190,"失误！",60,60,60,8],[200,5,106],[125,"Formation",59,[1,0,0.05,0]],[71,"GameWorld","e4QyNxVSRGpq62SdApAIbF",2],[72,"root","82sIDcJBhHXbS3FqmS7tmT",2,[[201,-220]]],[126,"Cube","146h2HpiVPpZoDTOwfi/f3",2,[[44,"Cube<ModelComponent>",-221,[65],[9],66]],[1,3,-220,0]],[72,"GameSettings","a2abjrOSVHDbYObrYbi6xb",2,[[202,true,300,false,false,false,false,false,60,60,false,[-1,30,20,8],[1,1.1,1.3,2],[3,2.8,2.6,2.3],[4,6,7,12],[5,10,18,99999],-222]]],[73,"Cube",51,[[44,"Cube<ModelComponent>",-223,[67],[9],68]],[1,35,0,0],[3,0,0.7071067811865475,0,0.7071067811865476],[1,70,1,0.1],[1,0,90,0]],[73,"Cube-001",51,[[44,"Cube<ModelComponent>",-224,[69],[9],70]],[1,-35,0,0],[3,0,0.7071067811865475,0,0.7071067811865476],[1,70,1,0.1],[1,0,90,0]],[84,"Cube-002",51,[[44,"Cube<ModelComponent>",-225,[71],[9],72]],[1,0,0,-35],[1,70,1,0.1]],[84,"Cube-003",51,[[44,"Cube<ModelComponent>",-226,[73],[9],74]],[1,0,0,35],[1,70,1,0.1]]],0,[0,-1,62,0,-2,63,0,-3,64,0,-4,65,0,-5,66,0,-6,67,0,-7,68,0,-8,69,0,-9,70,0,-10,71,0,-11,72,0,-12,73,0,-13,74,0,-14,75,0,-15,76,0,-16,77,0,-17,78,0,-18,79,0,-19,80,0,-20,81,0,-21,82,0,-22,83,0,-23,84,0,-24,85,0,-25,86,0,-26,87,0,-27,88,0,-28,89,0,-29,90,0,-30,91,0,-31,92,0,-32,93,0,-33,94,0,-34,95,0,-35,96,0,-36,97,0,-37,98,0,-38,99,0,-39,100,0,-1,62,0,-2,63,0,-3,64,0,-4,65,0,-5,66,0,-6,67,0,-7,68,0,-8,69,0,-9,70,0,-10,71,0,-11,72,0,-12,73,0,-13,74,0,-14,75,0,-15,76,0,-16,77,0,-17,78,0,-18,79,0,-19,80,0,-20,81,0,-21,82,0,-22,83,0,-23,84,0,-24,85,0,-25,86,0,-26,87,0,-27,88,0,-28,89,0,-29,90,0,-30,91,0,-31,92,0,-32,93,0,-33,94,0,-34,95,0,-35,96,0,-36,97,0,-37,98,0,-38,99,0,-39,100,0,-40,57,0,-41,58,0,-1,105,0,-2,60,0,-3,4,0,-4,5,0,-5,59,0,9,2,0,-7,104,0,9,2,0,-9,111,0,-10,120,0,-11,52,0,-12,6,0,-13,3,0,-14,121,0,-15,122,0,-16,123,0,-17,51,0,1,3,0,17,114,0,1,3,0,1,3,0,-1,113,0,-2,102,0,-3,54,0,-4,7,0,-5,55,0,1,4,0,1,4,0,-1,61,0,-3,101,0,-4,109,0,1,5,0,18,120,0,19,118,0,20,115,0,21,112,0,22,110,0,1,5,0,-3,110,0,-4,118,0,1,5,0,1,6,0,1,6,0,-3,115,0,-1,47,0,-2,48,0,-3,8,0,1,7,0,1,7,0,23,7,0,1,7,0,-1,103,0,1,8,0,-2,117,0,1,8,0,-1,57,0,-2,58,0,1,47,0,1,47,0,-1,56,0,1,48,0,-2,116,0,1,48,0,1,48,0,-1,124,0,-2,125,0,-3,126,0,-4,127,0,1,52,0,1,52,0,-1,108,0,1,54,0,-2,112,0,1,54,0,1,55,0,1,55,0,1,55,0,1,56,0,1,56,0,2,57,0,2,58,0,1,59,0,1,59,0,-1,119,0,-1,106,0,24,107,0,1,60,0,1,61,0,1,61,0,2,62,0,2,63,0,2,64,0,2,65,0,2,66,0,2,67,0,2,68,0,2,69,0,2,70,0,2,71,0,2,72,0,2,73,0,2,74,0,2,75,0,2,76,0,2,77,0,2,78,0,2,79,0,2,80,0,2,81,0,2,82,0,2,83,0,2,84,0,2,85,0,2,86,0,2,87,0,2,88,0,2,89,0,2,90,0,2,91,0,2,92,0,2,93,0,2,94,0,2,95,0,2,96,0,2,97,0,2,98,0,2,99,0,2,100,0,1,101,0,1,101,0,1,102,0,1,102,0,1,103,0,1,103,0,1,104,0,1,104,0,1,105,0,1,109,0,-1,114,0,1,121,0,1,122,0,1,123,0,1,124,0,1,125,0,1,126,0,1,127,0,25,2,1,9,4,107,1,108,110,26,111,115,27,117,115,28,116,118,29,119,226],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,110,110,117,118,118],[30,-1,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,11,12,-1,3,31,32,-1,-2,12,33,34,35,36,37,38,11,12,11,12,4,4,39,40,-1,3,-1,3,-1,3,-1,3,-1,3,41,42,43,11,44,45],[53,54,24,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,2,81,82,83,2,2,2,2,2,2,2,2,2,5,84,85,24,25,26,86,87,17,17,17,88,89,90,91,5,92,5,93,94,95,96,97,6,4,6,4,6,4,6,4,6,4,98,99,100,5,101,25]],[[[4,"wave3",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[6,0],[8,1]],[[[4,"Tombstone 01",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_ALBEDO_MAP":true},{},{}],[[[{},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[6,0],[102,27]],[[[38,"MagicBall"],[127,"MagicBall",[-7,-8],[[98,8,-6,[6,"ccZ2oG3BNHjL6WJh3o2PVy"],-5]],[157,"d7laBUGOdIhqK9jNuW0FVd",null,-4,0,[[203,["_trailModule","_particleSystem"],-3,[7,["dbYU4tHfZCl5TY/bj6k3dM"]],-2,[7,["dbYU4tHfZCl5TY/bj6k3dM"]]]],[-1]],[1,0,0,-0.074]],[11,0,{},1,[12,"2eko6nV9xBCJJnflwlX0bx",null,null,-15,[96,"aaiX+ZvlBFIrfgVXTyEh1a",1,[[5,"mofaqiu",["_name"],-9],[2,["_lpos"],-10,[1,0,0,0]],[2,["_lrot"],-11,[3,0.4999999999999999,0.5,0.5000000000000001,0.5000000000000001]],[2,["_euler"],-12,[1,0,89.99999999999999,90]],[97,["_lpos"],[7,["cayNBaVSRPsrCjhAOtnBIP"]],[1,0,0,0]],[97,["_lpos"],[7,["f0e603xmlIhrQ+YOHm9ZE8"]],[1,0,0,0]],[2,["_trailModule","colorOverTrail","color"],-13,[4,2191291903]],[2,["_trailModule","colorOvertime","color"],-14,[4,2331574104]]]],2]],[7,["2eko6nV9xBCJJnflwlX0bx"]],[85,"Sphere",false,1,[[161,"Sphere<ModelComponent>",-16,[6,"13L4Yw0jNHmrNxkf976Ixt"],[0],[9],1]],[1,"8d5+xgnDpAQ5Zcgk6Qs5jD",null,null,null,1,0],[1,0.3,0.3,0.3]],[7,["dbYU4tHfZCl5TY/bj6k3dM"]]],0,[0,-1,2,0,14,2,0,46,2,0,2,1,0,16,2,0,1,1,0,-1,4,0,-2,2,0,10,3,0,10,3,0,10,3,0,10,3,0,10,5,0,10,5,0,2,2,0,1,4,0,5,1,16],[0,0,0],[-1,3,4],[103,104,105]],[[[14,".bin",2672153415,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":13152,"length":5280,"count":1320,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":13152,"count":274,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.28876131772994995,-0.29173070192337036,-0.29473066329956055],"maxPosition",8,[1,0.2887614071369171,0.29173070192337036,0.29473066329956055]]],-1],0,0,[],[],[]],[[[14,".bin",3429205708,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":72464,"length":28560,"count":7140,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":72464,"count":1294,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.49748557806015015,-0.5,-0.4989933371543884],"maxPosition",8,[1,0.49949654936790466,0.5,0.49899348616600037]]],-1],0,0,[],[],[]],[[[14,".bin",3219909449,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":6776,"length":2400,"count":600,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":6776,"count":121,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-5,0,-5],"maxPosition",8,[1,5,0,5]]],-1],0,0,[],[],[]],[[[14,".bin",3434579268,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1344,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1344,"count":24,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.5,-0.5,-0.5],"maxPosition",8,[1,0.5,0.5,0.5]]],-1],0,0,[],[],[]],[[[14,".bin",3383603168,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":224,"length":24,"count":6,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":224,"count":4,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.5,-0.5,0],"maxPosition",8,[1,0.5,0.5,0]]],-1],0,0,[],[],[]],[[[4,"Stone",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4287136633],"emissive",8,[4,4287136633]]],11]]],0,0,[0],[0],[0]],[[[4,"Brown",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":25,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4284450248],"emissive",8,[4,4284450248]]],11]]],0,0,[0],[0],[0]],[[[4,"BrownDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4282735259],"emissive",8,[4,4282735259]]],11]]],0,0,[0],[0],[0]],[[[14,".bin",4193627268,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":17568,"length":3024,"count":756,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":30192,"length":2352,"count":588,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[2],"indexView":{"offset":35616,"length":384,"count":96,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":17568,"count":366,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":20592,"length":9600,"count":200,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":32544,"length":3072,"count":64,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.0452947616577148,-0.5000000596046448,-0.37191569805145264],"maxPosition",8,[1,1.0452946424484253,0.8258441090583801,0.3719162344932556]]],-1],0,0,[],[],[]],[[[19],[17,"bridge_roofed",[-2],[1,"bey5PBKlJYwKzK2U8WWbFk",null,null,null,-1,0]],[15,"bridge_roofed",1,[[16,-3,[6,"dd7UeBPh1aZJhbR3td0yHT"],[0,1,2],[9],3]],[1,"9e0dy67hFXGanDltnQfHC7",null,null,null,1,0]]],0,[0,2,1,0,-1,2,0,1,2,0,5,1,3],[0,0,0,0],[-1,-2,-3,3],[106,107,108,109]],[[[63,".bin",[{"vertexBundles":[{"attributes":[{"name":"a_position","format":32,"isNormalized":false,"stream":0,"isInstanced":false,"location":0},{"name":"a_normal","format":32,"isNormalized":false,"stream":0,"isInstanced":false,"location":0},{"name":"a_texCoord","format":21,"isNormalized":false,"stream":0,"isInstanced":false,"location":0},{"name":"a_tangent","format":44,"isNormalized":false,"stream":0,"isInstanced":false,"location":0}],"view":{"offset":0,"length":8064,"count":168,"stride":48}}],"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":8064,"length":768,"count":384,"stride":2}}]},"minPosition",8,[1,-0.3027045726776123,-0.35090845823287964,-0.2635333836078644],"maxPosition",8,[1,0.30270469188690186,0.40354102849960327,0.4854987561702728]]],-1],0,0,[],[],[]],[[[63,".bin",[{"vertexBundles":[{"attributes":[{"name":"a_position","format":32,"isNormalized":false,"stream":0,"isInstanced":false,"location":0},{"name":"a_normal","format":32,"isNormalized":false,"stream":0,"isInstanced":false,"location":0},{"name":"a_texCoord","format":21,"isNormalized":false,"stream":0,"isInstanced":false,"location":0},{"name":"a_tangent","format":44,"isNormalized":false,"stream":0,"isInstanced":false,"location":0}],"view":{"offset":0,"length":8112,"count":169,"stride":48}}],"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":8112,"length":948,"count":474,"stride":2}}]},"minPosition",8,[1,-0.42847713828086853,-0.2218802571296692,-0.535829484462738],"maxPosition",8,[1,0.4282876253128052,-0.01640426740050316,0.34047508239746094]]],-1],0,0,[],[],[]],[[[4,"Stone",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4287136633],"emissive",8,[4,4287136633]]],11]]],0,0,[0],[0],[0]],[[[19],[17,"detail_forestB",[-2],[1,"1cFZRQtIxYBY33Rt1gllrr",null,null,null,-1,0]],[15,"detail_forestB",1,[[16,-3,[6,"f7oGwwFKNe0J865VGnUA0+"],[0,1,2],[9],3]],[1,"281UMGthtYeLF5DeBX6sJf",null,null,null,1,0]]],0,[0,2,1,0,-1,2,0,1,2,0,5,1,3],[0,0,0,0],[-1,-2,-3,3],[110,111,112,113]],[[[4,"BrownDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4282735259],"emissive",8,[4,4282735259]]],11]]],0,0,[0],[0],[0]],[[[14,".bin",4134915350,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":42048,"length":13464,"count":3366,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":67032,"length":2448,"count":612,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[2],"indexView":{"offset":91512,"length":6624,"count":1656,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":42048,"count":876,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":55512,"length":11520,"count":240,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":69480,"length":22032,"count":459,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.9625611305236816,-0.00638415664434433,-0.6439129114151001],"maxPosition",8,[1,0.8908387422561646,0.7324153184890747,0.7154113054275513]]],-1],0,0,[],[],[]],[[[4,"GreenDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4287466280],"emissive",8,[4,4287466280]]],11]]],0,0,[0],[0],[0]],[[[4,"material-002",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"tintColor",8,[4,4294958189],"mainTexture",6,0]],11]]],0,0,[0,0],[6,0],[7,1]],[[[4,"glow",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[6,0],[18,1]],[[[14,".bin",4287624196,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":36912,"length":5736,"count":1434,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":36912,"count":769,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.9999998211860657,0,-0.2671569585800171],"maxPosition",8,[1,0.9999998211860657,1.152435064315796,0.2671569585800171]]],-1],0,0,[],[],[]],[[[4,"Stone",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4287136633],"emissive",8,[4,4287136633]]],11]]],0,0,[0],[0],[0]],[[[19],[17,"wall_straight",[-2],[1,"b9LeX+yddS4KlmZCJ+LzYx",null,null,null,-1,0]],[15,"wall_straight",1,[[16,-3,[6,"17ru2H+91Tsb6OgCyv5Rlt"],[0],[9],1]],[1,"f6Wo+iOm5Zir0817sz4vbm",null,null,null,1,0]]],0,[0,2,1,0,-1,2,0,1,2,0,5,1,3],[0,0],[-1,3],[114,115]],[[[4,"Beige",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":25,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4286492378],"emissive",8,[4,4286492378]]],11]]],0,0,[0],[0],[0]],[[[4,"Stone",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4287136633],"emissive",8,[4,4287136633]]],11]]],0,0,[0],[0],[0]],[[[4,"Brown",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":25,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4284450248],"emissive",8,[4,4284450248]]],11]]],0,0,[0],[0],[0]],[[[4,"BrownDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4282735259],"emissive",8,[4,4282735259]]],11]]],0,0,[0],[0],[0]],[[[14,".bin",394268512,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":2880,"length":384,"count":96,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":19296,"length":4896,"count":1224,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[2],"indexView":{"offset":99888,"length":15144,"count":3786,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[3],"indexView":{"offset":117144,"length":360,"count":90,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[4],"indexView":{"offset":124368,"length":2088,"count":522,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":2880,"count":60,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":3264,"length":16032,"count":334,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":24192,"length":75696,"count":1577,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":115032,"length":2112,"count":44,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":117504,"length":6864,"count":143,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.8436155319213867,-0.025585612282156944,-0.8081799745559692],"maxPosition",8,[1,0.8436161279678345,1.6066254377365112,0.8601409196853638]]],-1],0,0,[],[],[]],[[[19],[17,"mill",[-2],[1,"dbiC/T3S5cFKURapLrUyWC",null,null,null,-1,0]],[60,"mill",1,[-4],[[16,-3,[6,"1dLgTY6rhVaq1pi1bPq5mL"],[3,4,5,6,7],[9],8]],[1,"78pRGK07tazrm0PO/uVPkq",null,null,null,1,0]],[86,"mill_blades",2,[[16,-5,[6,"544/HxV/lSSZcFpErALKzn"],[0,1],[9],2]],[1,"0aeOsRRi5UYLgwPfUUhiGb",null,null,null,1,0],[1,0,1.2678406238555908,0.16987207531929016]]],0,[0,2,1,0,-1,2,0,1,2,0,-1,3,0,1,3,0,5,1,5],[0,0,0,0,0,0,0,0,0],[-1,-2,3,-1,-2,-3,-4,-5,3],[28,29,116,28,117,29,118,119,120]],[[[4,"White",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4293388263],"emissive",8,[4,4293388263]]],11]]],0,0,[0],[0],[0]],[[[14,".bin",4167302210,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":8448,"length":1104,"count":276,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":35664,"length":3264,"count":816,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":8448,"count":176,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":9552,"length":26112,"count":544,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.6885064244270325,-0.688506543636322,-0.09218446165323257],"maxPosition",8,[1,0.6885063052177429,0.6885061860084534,0.07097838073968887]]],-1],0,0,[],[],[]],[[[4,"material-011",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"tintColor",8,[4,2130706648],"mainTexture",6,0]],11]]],0,0,[0,0],[6,0],[3,1]],[[[4,"Beige",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":25,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4286492378],"emissive",8,[4,4286492378]]],11]]],0,0,[0],[0],[0]],[[[4,"Stone",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4287136633],"emissive",8,[4,4287136633]]],11]]],0,0,[0],[0],[0]],[[[19],[17,"watchtower",[-2],[1,"43CjQ1wAtXNqJKb6tJjYAi",null,null,null,-1,0]],[15,"watchtower",1,[[16,-3,[6,"44dc+qmJ1ZAIomMnjP/wWO"],[0,1,2,3],[9],4]],[1,"beb9YUDZNdHouawOGSerut",null,null,null,1,0]]],0,[0,2,1,0,-1,2,0,1,2,0,5,1,3],[0,0,0,0,0],[-1,-2,-3,-4,3],[121,122,123,124,125]],[[[4,"BrownDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4282735259],"emissive",8,[4,4282735259]]],11]]],0,0,[0],[0],[0]],[[[4,"StoneDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4284768345],"emissive",8,[4,4284768345]]],11]]],0,0,[0],[0],[0]],[[[14,".bin",189272502,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":29040,"length":6984,"count":1746,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":60504,"length":5088,"count":1272,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[2],"indexView":{"offset":106968,"length":9612,"count":2403,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[3],"indexView":{"offset":118596,"length":768,"count":192,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":29040,"count":605,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":36024,"length":24480,"count":510,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":65592,"length":41376,"count":862,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":116580,"length":2016,"count":42,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.4769618511199951,-0.025685006752610207,-0.8799824714660645],"maxPosition",8,[1,0.4937245547771454,1.9528006315231323,0.833111584186554]]],-1],0,0,[],[],[]],[[[4,"Stone",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4287136633],"emissive",8,[4,4287136633]]],11]]],0,0,[0],[0],[0]],[[[14,".bin",3002026539,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":32736,"length":4200,"count":1050,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":32736,"count":682,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.9999993443489075,-5.640098610371069e-9,-0.9128249883651733],"maxPosition",8,[1,0.36494180560112,1.1524349451065063,0.3649422526359558]]],-1],0,0,[],[],[]],[[[19],[17,"wall_hexCornerB",[-2],[1,"48IKuE6LFQsakdro5S/Lru",null,null,null,-1,0]],[15,"wall_hexCornerB",1,[[16,-3,[6,"fbhqWwF9RaTpQbTe1TFmHQ"],[0],[9],1]],[1,"36kqCgojtb/6SiZkS0iRju",null,null,null,1,0]]],0,[0,2,1,0,-1,2,0,1,2,0,5,1,3],[0,0],[-1,3],[126,127]],[[[4,"material-001",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_TEXTURE":true}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[6,0],[128,30]],[[[4,"Red",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_ALBEDO_MAP":true},{},{}],[[[{},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[6,0],[129,19]],[[[38,"ArcherLeader"],[128,"ArcherLeader",[-9,-10,-11,-12,-13,-14,-15],[[204,3,0.8,5,0.1,4,4,true,-2,[6,"c5ZGUv5xhC24oyBnObrrev"]],[205,true,-8,[6,"59vVeH2hZKJ6BSiLB4lGWq"],[5,6,7,8],[[53,"Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/L_hand_container",-3],[53,"Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/L_shield_container",-4],[53,"Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/R_hand_container",-5],[53,"Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 Head/HEAD_CONTAINER",-6],[53,"Bip001/Bip001 Pelvis/Bip001 Spine/Backpack_container",-7]],9]],[1,"0dl8QpJuNMjID/0h1OkOub",null,null,null,-1,0],[1,2,2,2]],[148,"Bip001 Spine",[[-16,-17,-18,[43,"Backpack_container",-19,[1,"00OALxki1L1pdGxXwZ7SJ5",null,null,null,1,0],[1,0.2635248005390167,-0.22322838008403778,-3.391265863683657e-7],[3,-0.49980058283437406,0.5001994273070469,-0.50019865244668,0.4998011788808101],[1,0,89.99993167089839,-90]]],1,1,1,4],[1,"dbNslb1NFIq698B45BxdFa",null,null,null,1,0],[1,0.08668395131826401,-0.00037782941944897175,1.2073722643890505e-7],[3,-0.0000020804759106073234,-6.936759723456755e-7,0.0003981589901667566,0.9999999207323014],[1,-0.00023837338537102524,-0.00007939450691674307,0.045625660794268615]],[87,"Bip001 Pelvis",[2,-20,-21],[1,"71AiPyY/JOp51OnpqyjS7g",null,null,null,1,0],[3,-0.49999999254917427,-0.49999999254917427,-0.49999930709576956,0.5000007078049009],[1,-89.99991974527727,-89.99991974527727,-0.0000017074910602964197]],[149,"Bip001",1,[[[43,"Bip001 Footsteps",-22,[1,"7ctBvUWEhPs7h5frcYgVBI",null,null,null,1,0],[1,0,-1.0757318300125337e-23,-0.4399206340312958],[3,-6.921397640638599e-34,6.9214068241883725e-34,0.7071063043492204,0.7071072580235531],[1,0,-1.12165974437555e-31,90]],3],4,1],[1,"cdjfPtyWxMYZPyBFCN4mRY",null,null,null,1,0],[1,0,0.4510890245437622,-0.03612518683075905],[3,-0.5000003576277408,-0.49999964237200345,-0.49999964237200345,0.5000003576277408],[1,-90,-89.99991803772996,0]],[92,"Bip001 L Hand",[[43,"L_hand_container",-23,[1,"8ddwhIKcFN1aU2+3hTpSbk",null,null,null,1,0],[1,0.07401365041732788,0.009859087876975536,-0.09225296974182129],[3,-0.03802912959822119,0.6707643698973259,-0.02341115229952282,0.740324836356483],[1,-1.4321421462297923,84.29424138148022,-4.91517956636398]],[43,"L_shield_container",-24,[1,"f312v0jSNBcL8Rn4G+elMg",null,null,null,1,0],[1,0.1378527730703354,-0.05289037525653839,-0.05471507087349892],[3,-0.5448302136475874,0.835974411526079,-0.06306927028712654,0.0181408025125544],[1,12.138401061635323,-174.59338486412415,-65.95370115244106]]],[1,"453jWdZCxOKocUWmD1riN0",null,null,null,1,0],[1,0.13800707459449768,2.255973158774445e-17,-9.689330937590057e-8],[3,-0.7068252124052276,1.0540906159464295e-8,1.0532516425925904e-8,0.7073882378922517],[1,-89.95437890588065,0.0000017075472925031882,0]],[92,"Bip001 Head",[[88,"Bip001 HeadNub",-25,[1,"86uXM6h3BAPaPJTOQpEzOO",null,null,null,1,0],[1,0.5598670840263367,3.027915917996893e-9,-7.74526911298137e-22]],[89,"HEAD_CONTAINER",-26,[1,"9fJk8NhqtIe4jW9VSdz5Nj",null,null,null,1,0],[1,0.15077103674411774,0.062292683869600296,2.9067993523312907e-7],[3,0.7071072282210418,5.170000333874006e-7,0.7071063341513926,-5.170006586649924e-7],[1,0.8299999833106995,0.8299999833106995,0.8299999833106995],[1,-179.99991621650756,-89.99992755490563,2.3028655092847967e-12]]],[1,"70Q67avMdG2LQdp8O9K+gN",null,null,null,1,0],[1,0.08924581110477448,0,8.60585464010027e-23],[3,-7.265599787883253e-14,1.1042733174299356e-9,-0.0003988305609355657,0.9999999204670887],[1,4.21424291253915e-11,1.265404279071084e-7,-0.04570261697650697]],[33,"L_shield_container Socket",1,[-27],[1,"f1VDwmVjBNK5DFQngyp6Jd",null,null,null,1,0],[1,0.686385956186695,0.5717299839143128,0.07549827371050849],[3,0.045884959191219356,0.0165473441050637,-0.5731862178466609,-0.8179720750696379],[1,-9.40389962425611,4.264716060945798,69.92084004916677]],[33,"R_hand_container Socket",1,[-28],[1,"c9KN9mEGhE0oAlOOieJVzK",null,null,null,1,0],[1,-0.5908516339966307,0.5720172044253349,0.09348267212413455],[3,0.26247726139173266,-0.6189493969042874,0.27760609966886896,0.6862522748601664],[1,44.83031865956649,-85.42300807826737,3.215714760670647]],[129,"HEAD_CONTAINER Socket",1,[-29],[1,"f97H1FqBBPwoag6zuJXkYz",null,null,null,1,0],[1,0.0000012514373676497659,1.22000006617169,0.028108354848459582],[3,-0.7071062438336231,-4.371976470851635e-7,-5.026729771086241e-7,0.7071073185387502],[1,0.8299999338388453,0.8299998348951458,0.8299998843669941],[1,-89.99991291829308,-0.00007615627319172928,-0.000005305423586865127]],[33,"Bip001 L Clavicle",2,[-30],[1,"9exx0bOLdJY6tsb6IszViD",null,null,null,1,0],[1,0.3317789137363434,0.0001128897929447703,0.21894682943820953],[3,0.6404203882672894,-0.000256057076368399,0.7680244577871878,0.00030490497535081],[1,179.9550886454819,-100.35364139346413,0.008043216631396885]],[33,"Bip001 L UpperArm",10,[-31],[1,"02faqV8pdOZYePMukm1uDU",null,null,null,1,0],[1,0.10956235229969025,3.027915917996893e-9,9.689330937590057e-8],[3,0.04786509721597892,0.28080511525111435,-0.012259087713893729,0.9584921149836009],[1,5.66097786034494,32.647949568146835,0.19372029071740474]],[33,"Bip001 L Forearm",11,[5],[1,"3a5GNCDTpME6B9yXrhe/Dr",null,null,null,1,0],[1,0.1928595006465912,-1.2111663671987571e-8,1.804778527019556e-16],[3,-1.5343994988728212e-17,5.558597383544229e-17,-0.09983344969326956,0.9950041619623214],[1,-1.1362500635924634e-15,6.2876597680655815e-15,-11.459159708473143]],[33,"Bip001 R Clavicle",2,[-32],[1,"22iFi6wOxIe4KLFirDJ/+/",null,null,null,1,0],[1,0.3317789137363434,0.0001141009561251849,-0.21894682943820953],[3,-0.6404203882672924,0.0002539268796691491,0.7680244577871913,0.0003066812694656228],[1,-179.95514576571293,100.35364127509047,0.008355874973247818]],[33,"Bip001 R UpperArm",13,[-33],[1,"4eAVZjRIxIdY5vtDCZF0Zl",null,null,null,1,0],[1,0.10956235229969025,0,-9.689330937590057e-8],[3,-0.04786509721597892,-0.28080511525111435,-0.012259087713893729,0.9584921149836009],[1,-5.66097786034494,-32.647949568146835,0.19372029071740474]],[33,"Bip001 R Forearm",14,[-34],[1,"df+7orB85C94hsOeQYy8J7",null,null,null,1,0],[1,0.1928595006465912,-1.2111663671987571e-8,9.689330937590057e-8],[3,-9.998422274586866e-18,3.935872541605616e-17,-0.09983342756430151,0.9950041641826246],[1,-7.037730013375637e-16,4.4622101048241964e-15,-11.45915715994818]],[75,"Bip001 R Hand",15,[[43,"R_hand_container",-35,[1,"80GUfI245NPbuA5l85WV4x",null,null,null,1,0],[1,0.07390939444303513,0.009959372691810131,0.09228209406137466],[3,0.740325438383703,-0.02341178020005665,0.6707636600604323,-0.03802954341265915],[1,-178.5678663369977,-84.29413398903185,-4.915263471995578]]],[1,"26P9qWbc9FuaVagiHsYhsO",null,null,null,1,0],[1,0.13800710439682007,0,9.689330937590057e-8],[3,0.7068252124052276,5.266258212962952e-9,5.270453523821367e-9,0.7073882378922517],[1,89.95437890588065,-3.596954062703228e-14,8.537736822497861e-7]],[130,"Bip001 Neck",2,[6],[1,"cd0oyCa2hGmJBaAQl1uyWC",null,null,null,1,0],[1,0.44221192598342896,0.0018946154741570354,2.5954158822116824e-9]],[33,"Bip001 L Thigh",3,[-36],[1,"41igu10VdMuYOSoWTnZk6U",null,null,null,1,0],[1,-2.4223328409789247e-7,2.6645659545465605e-7,0.17689882218837738],[3,0.021307006777814542,0.9997729799614988,-6.767446715997591e-7,7.85150643546192e-7],[1,0.00007952085112741467,179.99990831319764,2.4417879058463106]],[33,"Bip001 L Calf",18,[-37],[1,"adJHeNHn9D7oC/q8X9rwPD",null,null,null,1,0],[1,0.21324628591537476,-4.541873988017642e-9,0],[3,1.9448409807367765e-22,-2.0334527780265243e-22,-0.08872141532804828,0.9960564795543414],[1,2.045298511261704e-20,-2.1572104652894185e-20,-10.18011064768223]],[33,"Bip001 L Foot",19,[-38],[1,"bfeDZ6XuFK9672JaMET3ch",null,null,null,1,0],[1,0.10479825735092163,0,0],[3,-5.126469166222739e-9,7.698253266216382e-8,0.06747824881860726,0.9977207454675722],[1,-0.0000011922309903371195,0.000008922334365998732,7.738317824969377]],[75,"Bip001 L Toe0",20,[[89,"Bip001 L Toe0Nub",-39,[1,"2dC+SAlZ1BLql5heFztVwC",null,null,null,1,0],[1,0.0069003538228571415,0,2.255973158774445e-17],[3,-9.553443207691286e-16,1.844023658300749e-19,1,1.8375892746737375e-15],[1,-0.9999999403953552,-1,-0.9999999403953552],[1,-180,179.9999999999999,2.1057221983462265e-13]]],[1,"4bmafIS8pOU7tbg1KeOIPC",null,null,null,1,0],[1,0.12302407622337341,0.27322590351104736,-2.255973158774445e-17],[3,1.5454310096341944e-8,1.5454310096341944e-8,0.7071067811865474,0.7071067811865474],[1,0,0.0000025044781562438674,90]],[33,"Bip001 R Thigh",3,[-40],[1,"25AskCx6pHBZwzunVlbEQE",null,null,null,1,0],[1,2.4223328409789247e-7,-2.2406578636946506e-7,-0.17689882218837738],[3,0.021307006777815593,0.9997729799615481,-6.78329409296489e-7,7.182860132174613e-7],[1,0.00007953916720467456,179.99991597666937,2.4417879058516108]],[33,"Bip001 R Calf",22,[-41],[1,"32ialzH5dFKZ3MNztFbDqz",null,null,null,1,0],[1,0.21324631571769714,-1.5139579589984464e-9,-1.2111663671987571e-8],[3,2.0857471869279507e-22,-4.5152885962117915e-23,-0.08872141532804828,0.9960564795543414],[1,2.3721031201717633e-20,-3.081728996980104e-21,-10.18011064768223]],[33,"Bip001 R Foot",23,[-42],[1,"4eMqANHcVJP53PVAUnhVb/",null,null,null,1,0],[1,0.10479822754859924,0,0],[3,-7.726712812820042e-10,1.0240999437803812e-8,0.06747824881860746,0.9977207454675753],[1,-1.6906732157562304e-7,0.000001187647409096496,7.738317824969467]],[75,"Bip001 R Toe0",24,[[88,"Bip001 R Toe0Nub",-43,[1,"58biULSYJPEYXWV42T6anq",null,null,null,1,0],[1,0.0069003538228571415,1.4099832242340282e-18,-2.255973158774445e-17]]],[1,"acOB4GYfdLDZiHA/2xonT8",null,null,null,1,0],[1,0.12302407622337341,0.27322590351104736,2.255973158774445e-17],[3,-1.5454308319985075e-8,-1.5454308319985075e-8,0.7071067811865474,0.7071067811865474],[1,0,-0.0000025044778683729144,90]],[74,"Body_10c",1,[[206,-44,[6,"382hMwnLFIWqBQRzmHuMgd"],[9],1,0,1]],[1,"f925/47vxIvqqtgGFx9WRC",null,null,null,1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[43,"L_hand_container Socket",1,[1,"12WZeXuDlCP4DIMeM7i8uG",null,null,null,1,0],[1,0.5909999210072392,0.5720156274136237,0.09348280315710653],[3,-0.6189491377933944,0.2624780257506074,-0.6862517529709825,-0.2776072448030326],[1,135.16951404418168,-94.57695576987548,3.215741833403463]],[15,"shield_02",7,[[78,-45,[6,"45fMHG0x5E9YAagKgo0Dw7"],[9],2]],[1,"6fyAyjYRlD4I/7V0wpbygf",null,null,null,1,0]],[15,"w_sword",8,[[78,-46,[6,"6brBKM9E5IxpWFbA4usz3q"],[9],3]],[1,"c4ghuoHWNJQ7Nqms3gt5VI",null,null,null,1,0]],[74,"Head_12d",9,[[78,-47,[6,"7cr4mjNC5O9bIQoqzEfrxD"],[9],4]],[1,"edFMP+VHZLLYfTPVkSd3YS",null,null,null,1,0],[3,-0.000001188412511509378,1.3744714699715953e-8,2.3674358828867193e-7,0.9999999999992657],[1,-0.00013618204283298078,0.000001575060526034706,0.000027128814999645142]],[43,"Backpack_container Socket",1,[1,"66UaJ1M/hO6Y1bfuD1UWRa",null,null,null,1,0],[1,4.328159231431483e-7,0.8014757665081004,-0.2595209453117281],[3,0.4999993444605072,-0.4999999552141469,-0.5000000656143568,-0.5000006347101504],[1,-89.99993239960871,90.00000238677144,0.00008025132656728998]]],0,[0,2,1,0,1,1,0,14,27,0,14,7,0,14,8,0,14,9,0,14,31,0,1,1,0,-1,4,0,-2,26,0,-3,27,0,-4,7,0,-5,8,0,-6,9,0,-7,31,0,-1,10,0,-2,13,0,-3,17,0,9,2,0,-2,18,0,-3,22,0,9,4,0,9,5,0,9,5,0,9,6,0,9,6,0,-1,28,0,-1,29,0,-1,30,0,-1,11,0,-1,12,0,-1,14,0,-1,15,0,-1,16,0,9,16,0,-1,19,0,-1,20,0,-1,21,0,9,21,0,-1,23,0,-1,24,0,-1,25,0,9,25,0,1,26,0,1,28,0,1,29,0,1,30,0,5,1,2,9,3,3,9,4,5,9,12,6,9,17,47],[0,0,0,0,0,0,0,0,0,0],[3,47,3,3,3,-1,-2,-3,-4,48],[130,131,132,133,134,31,135,136,137,31]],[[[4,"Blue",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_ALBEDO_MAP":true},{},{}],[[[{},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[6,0],[138,19]],[[[4,"Beige",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":25,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4286492378],"emissive",8,[4,4286492378]]],11]]],0,0,[0],[0],[0]],[[[14,".bin",1630495324,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":2016,"length":768,"count":192,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":28608,"length":6648,"count":1662,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[2],"indexView":{"offset":36600,"length":192,"count":48,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[3],"indexView":{"offset":85512,"length":9600,"count":2400,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[4],"indexView":{"offset":105576,"length":2784,"count":696,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":2016,"count":42,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2784,"length":25824,"count":538,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":35256,"length":1344,"count":28,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":36792,"length":48720,"count":1015,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":95112,"length":10464,"count":218,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.8436157703399658,-0.008920181542634964,-0.8190275430679321],"maxPosition",8,[1,0.8436156511306763,0.9049292206764221,0.83721923828125]]],-1],0,0,[],[],[]],[[[4,"Stone",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4287136633],"emissive",8,[4,4287136633]]],11]]],0,0,[0],[0],[0]],[[[4,"Brown",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":25,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4284450248],"emissive",8,[4,4284450248]]],11]]],0,0,[0],[0],[0]],[[[4,"BrownDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4282735259],"emissive",8,[4,4282735259]]],11]]],0,0,[0],[0],[0]],[[[19],[17,"house",[-2],[1,"00knp1gOxWX7tvjA9HJdYE",null,null,null,-1,0]],[15,"house",1,[[16,-3,[6,"03JNRfV3pdO4WQAQx3ykTH"],[0,1,2,3,4],[9],5]],[1,"c7M3TvagJRzLnoObDlAJ6o",null,null,null,1,0]]],0,[0,2,1,0,-1,2,0,1,2,0,5,1,3],[0,0,0,0,0,0],[-1,-2,-3,-4,-5,3],[139,140,141,142,143,144]],[[[4,"White",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4293388263],"emissive",8,[4,4293388263]]],11]]],0,0,[0],[0],[0]],[[[63,".bin",[{"vertexBundles":[{"attributes":[{"name":"a_position","format":32,"isNormalized":false,"stream":0,"isInstanced":false,"location":0},{"name":"a_normal","format":32,"isNormalized":false,"stream":0,"isInstanced":false,"location":0},{"name":"a_texCoord","format":21,"isNormalized":false,"stream":0,"isInstanced":false,"location":0},{"name":"a_tangent","format":44,"isNormalized":false,"stream":0,"isInstanced":false,"location":0}],"view":{"offset":0,"length":2160,"count":45,"stride":48}}],"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":2160,"length":120,"count":60,"stride":2}}]},"minPosition",8,[1,-0.08569555729627609,-0.5020095705986023,-0.04437597468495369],"maxPosition",8,[1,0.08443552255630493,0.4434165358543396,0.04590494930744171]]],-1],0,0,[],[],[]],[[[207,"dcc/surfaces-imported-specular-glossiness",[{"hash":3347565921,"name":"dcc/surfaces-imported-specular-glossiness|standard-vs|standard-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"diffuseColor","type":16,"count":1},{"name":"specularColor","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScale","type":13,"count":1},{"name":"alphaThreshold","type":13,"count":1},{"name":"shininessExponent","type":13,"count":1},{"name":"glossiness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalScale","type":13,"count":1},{"name":"transparencyFactor","type":13,"count":1},{"name":"diffuseFactor","type":13,"count":1},{"name":"specularFactor","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"shininessExponentMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_SHININESS_MAP"]},{"name":"specularGlossinessMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_SPECULAR_GLOSSINESS_MAP"]},{"name":"specularMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_SPECULAR_MAP"]},{"name":"metallicMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_MAP"]},{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_ALBEDO_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_TRANSPARENCY_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["USE_EMISSIVE_MAP"]},{"name":"emissiveScaleMap","type":28,"count":1,"stageFlags":16,"binding":8,"defines":["USE_EMISSIVESCALE_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":9,"defines":["USE_NORMAL_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":10,"defines":["USE_OCCLUSION_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_color","format":44,"location":6,"defines":["CC_SURFACES_USE_VERTEX_COLOR"]},{"name":"a_texCoord1","format":21,"location":7,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":13,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":15,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":16,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":17,"defines":["CC_USE_MORPH"]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"tags":[],"defines":[]},{"name":"fragColor0","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":1,"tags":["CC_PIPELINE_TYPE"],"defines":["CC_PIPELINE_TYPE"]},{"name":"fragColor1","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":2,"defines":["CC_PIPELINE_TYPE"]},{"name":"fragColor2","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":3,"defines":["CC_PIPELINE_TYPE"]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCLocal","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]},{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_lightPos","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true},{"name":"cc_lightColor","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightSizeRangeAngle","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightDir","typename":"vec4","type":16,"count":0,"isArray":true}],"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_sh_linear_const_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_a","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"diffuseColor","type":16,"count":1},{"name":"specularColor","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScale","type":13,"count":1},{"name":"alphaThreshold","type":13,"count":1},{"name":"shininessExponent","type":13,"count":1},{"name":"glossiness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalScale","type":13,"count":1},{"name":"transparencyFactor","type":13,"count":1},{"name":"diffuseFactor","type":13,"count":1},{"name":"specularFactor","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"shininessExponentMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_SHININESS_MAP"]},{"name":"specularGlossinessMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_SPECULAR_GLOSSINESS_MAP"]},{"name":"specularMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_SPECULAR_MAP"]},{"name":"metallicMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_MAP"]},{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_ALBEDO_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_TRANSPARENCY_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["USE_EMISSIVE_MAP"]},{"name":"emissiveScaleMap","type":28,"count":1,"stageFlags":16,"binding":8,"defines":["USE_EMISSIVESCALE_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":9,"defines":["USE_NORMAL_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":10,"defines":["USE_OCCLUSION_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_composite_pack_1","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_composite_pack_2","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_composite_pack_3","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCShadow","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matLightView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matLightViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_shadowInvProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowNFLSInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowWHPBInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowLPNNInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowColor","typename":"vec4","type":16,"count":1,"precision":"lowp "},{"name":"cc_planarNDInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCSM","stageFlags":16,"tags":{"builtin":"global"},"members":[{"name":"cc_csmViewDir0","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir1","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir2","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmAtlas","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_matCSMViewProj","typename":"mat4","type":25,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjDepthInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmSplitsInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_USE_IBL"]},{"name":"cc_diffuseMap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE USE_REFLECTION_DENOISE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING USE_COMPATIBLE_LIGHTING\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMITTENCE\n  #define CC_SURFACES_LIGHTING_TRANSMITTENCE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    in vec4 a_sh_linear_const_r;\n    in vec4 a_sh_linear_const_g;\n    in vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n#endif\nout highp vec3 v_worldPos;\nout mediump vec4 v_normal;\nout vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  out lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  out mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  out mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  out mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW\n  out mediump vec2 v_shadowBias;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  out mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  out highp vec4 v_localPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    out mediump vec4 v_sh_linear_const_r;\n    out mediump vec4 v_sh_linear_const_g;\n    out mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBias\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW\n  vec2 shadowBias;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_debug_view_mode;\n  mediump vec4 cc_debug_view_composite_pack_1;\n  mediump vec4 cc_debug_view_composite_pack_2;\n  mediump vec4 cc_debug_view_composite_pack_3;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n  };\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n    float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n        vec4 wPos = pos;\n        float cam_dis = distance(cameraPos, wPos.xyz);\n        return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n    }\n    float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * fogDensity);\n        return f;\n    }\n    float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n        return f;\n    }\n    float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n        vec4 wPos = pos;\n        vec3 camWorldProj = cameraPos.xyz;\n        camWorldProj.y = 0.;\n        vec3 worldPosProj = wPos.xyz;\n        worldPosProj.y = 0.;\n        float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n        float fDeltaY, fDensityIntegral;\n        if (cameraPos.y > fogTop) {\n            if (wPos.y < fogTop) {\n                fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n                fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n            }\n            else {\n                fDeltaY = 0.;\n                fDensityIntegral = 0.;\n            }\n        }\n        else {\n            if (wPos.y < fogTop) {\n                float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n                float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n                fDeltaY = abs(fDeltaA - fDeltaB);\n                fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n            }\n            else {\n                fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n                fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n            }\n        }\n        float fDensity;\n        if (fDeltaY != 0.) {\n            fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n        }\n        else {\n            fDensity = 0.;\n        }\n        float f = exp(-fDensity);\n        return f;\n    }\n  #endif\n  void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n  {\n  #if CC_USE_FOG == 0\n  \tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n  #elif CC_USE_FOG == 1\n  \tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 2\n  \tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 3\n  \tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n  #else\n  \tfactor = 1.0;\n  #endif\n  }\n#endif\nlayout(std140) uniform Constants {\n  vec4  tilingOffset;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float emissiveScale;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.position.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\nvec3 SurfacesVertexModifyLocalNormal(in SurfacesStandardVertexIntermediate In)\n{\n  return In.normal.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 SurfacesVertexModifyLocalTangent(in SurfacesStandardVertexIntermediate In)\n    {\n      return In.tangent;\n    }\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\nvec3 SurfacesVertexModifyWorldNormal(in SurfacesStandardVertexIntermediate In)\n{\n    vec3 worldNormal = In.worldNormal.xyz;\n  #if CC_SURFACES_USE_TWO_SIDED\n      worldNormal.xyz *= In.worldNormal.w;\n  #endif\n  return worldNormal;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBias;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferFog(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(vec4(In.worldPos, 1.0), In.fogFactor);\n#endif\n}\nvoid CCSurfacesVertexTransferShadow(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_RECEIVE_SHADOW\n    In.shadowBias = vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n    #if USE_INSTANCING\n      In.shadowBias += a_localShadowBias.xy;\n    #else\n      In.shadowBias += cc_localShadowBias.xy;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferLightMapUV(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #if USE_INSTANCING\n    In.lightmapUV.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    In.lightmapUV.z = a_lightingMapUVParam.w;\n  #else\n    In.lightmapUV.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    In.lightmapUV.z = cc_lightingMapUVParam.w;\n  #endif\n#endif\n}\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  In.normal.xyz = SurfacesVertexModifyLocalNormal(In);\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    In.tangent = SurfacesVertexModifyLocalTangent(In);\n  #endif\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matProj * cc_matView * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  vec3 viewDirect = normalize(cc_cameraPos.xyz - In.worldPos);\n  In.worldNormal.w = dot(In.worldNormal.xyz, viewDirect) < 0.0 ? -1.0 : 1.0;\n  In.worldNormal.xyz = SurfacesVertexModifyWorldNormal(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexTransferFog(In);\n  CCSurfacesVertexTransferShadow(In);\n  CCSurfacesVertexTransferLightMapUV(In);\n  CCSurfacesVertexOutput(In);\n}","frag":"\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE USE_REFLECTION_DENOISE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING USE_COMPATIBLE_LIGHTING\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMITTENCE\n  #define CC_SURFACES_LIGHTING_TRANSMITTENCE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nin highp vec3 v_worldPos;\nin mediump vec4 v_normal;\nin vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  in mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  in mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW\n  in mediump vec2 v_shadowBias;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  in mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  in highp vec4 v_localPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    in mediump vec4 v_sh_linear_const_r;\n    in mediump vec4 v_sh_linear_const_g;\n    in mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBias\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_debug_view_mode;\n  mediump vec4 cc_debug_view_composite_pack_1;\n  mediump vec4 cc_debug_view_composite_pack_2;\n  mediump vec4 cc_debug_view_composite_pack_3;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO ((cc_debug_view_mode.y > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION ((cc_debug_view_mode.z > 0.0) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE ((cc_debug_view_composite_pack_1.x > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR ((cc_debug_view_composite_pack_1.y > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE ((cc_debug_view_composite_pack_1.z > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR ((cc_debug_view_composite_pack_1.w > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE ((cc_debug_view_composite_pack_2.x > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP ((cc_debug_view_composite_pack_2.y > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW ((cc_debug_view_composite_pack_2.z > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO ((cc_debug_view_composite_pack_2.w > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP ((cc_debug_view_composite_pack_3.x > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG ((cc_debug_view_composite_pack_3.y > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING ((cc_debug_view_composite_pack_3.z > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION ((cc_debug_view_composite_pack_3.w > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    layout(std140) uniform CCForwardLight {\n      highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n      vec4 cc_lightColor[LIGHTS_PER_PASS];\n      vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n      vec4 cc_lightDir[LIGHTS_PER_PASS];\n    };\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    layout(std140) uniform CCSH {\n      vec4 cc_sh_linear_const_r;\n      vec4 cc_sh_linear_const_g;\n      vec4 cc_sh_linear_const_b;\n      vec4 cc_sh_quadratic_r;\n      vec4 cc_sh_quadratic_g;\n      vec4 cc_sh_quadratic_b;\n      vec4 cc_sh_quadratic_a;\n    };\n  #endif\n#endif\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON)\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\nvec3 LinearToSRGB(vec3 linear) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return linear;\n    }\n  #endif\n#endif\n  return sqrt(linear);\n}\nbool isnans(vec2 val) {\n    return isnan(val.x) || isnan(val.y);\n}\nbool isnans(vec3 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z);\n}\nbool isnans(vec4 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z) || isnan(val.w);\n}\nbool isinfs(vec2 val) {\n    return isinf(val.x) || isinf(val.y);\n}\nbool isinfs(vec3 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z);\n}\nbool isinfs(vec4 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z) || isinf(val.w);\n}\nfloat saturate(float value)\n{\n    return min(max(value, 0.0), 1.0);\n}\nvec2 saturate(vec2 value) { return vec2(saturate(value.x), saturate(value.y)); }\nvec3 saturate(vec3 value) { return vec3(saturate(value.x), saturate(value.y), saturate(value.z)); }\nvec4 saturate(vec4 value) { return vec4(saturate(value.x), saturate(value.y), saturate(value.z), saturate(value.w)); }\nvec2 GetPlanarReflectScreenUV(vec3 worldPos, mat4 matVirtualCameraViewProj, float flipNDCSign, vec3 viewDir, vec3 reflectDir)\n{\n  vec4 clipPos = matVirtualCameraViewProj * vec4(worldPos, 1.0);\n  vec2 screenUV = clipPos.xy / clipPos.w * 0.5 + 0.5;\n  screenUV = vec2(1.0 - screenUV.x, screenUV.y);\n  screenUV = flipNDCSign == 1.0 ? vec2(screenUV.x, 1.0 - screenUV.y) : screenUV;\n  return screenUV;\n}\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nvec3 CalculateBinormal(vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    return cross(normal.xyz, tangent) * mirrorNormal;\n}\nvec3 CalculateNormalFromTangentSpace(vec3 normalFromTangentSpace, float normalStrength, vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    vec3 binormal = CalculateBinormal(normal, tangent, mirrorNormal);\n    return (normalFromTangentSpace.x * normalStrength) * normalize(tangent) +\n           (normalFromTangentSpace.y * normalStrength) * normalize(binormal) +\n            normalFromTangentSpace.z * normalize(normal);\n}\nvec3 RotationVecFromAxisY(vec3 v, float cosTheta, float sinTheta)\n{\n    vec3 result;\n    result.x = dot(v, vec3(cosTheta, 0.0, -sinTheta));\n    result.y = v.y;\n    result.z = dot(v, vec3(sinTheta, 0.0,  cosTheta));\n    return result;\n}\nvoid RotateTangentAndBinormal(inout vec3 tangent, inout vec3 binormal, vec3 normal, float rotationAngle)\n{\n    float cosTheta = cos(rotationAngle), sinTheta = sin(rotationAngle);\n    vec3 B = RotationVecFromAxisY(vec3(1.0, 0.0, 0.0), cosTheta, sinTheta);\n    vec3 T = RotationVecFromAxisY(vec3(0.0, 0.0, 1.0), cosTheta, sinTheta);\n    vec3 tangentNew, binormalNew;\n    binormalNew = B.x * binormal + B.y * normal + B.z * tangent;\n    binormal = normalize(binormalNew);\n    tangentNew = T.x * binormal + T.y * normal + T.z * tangent;\n    tangent = normalize(tangentNew);\n}\nvec2 signNotZero(vec2 v) {\n  return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n}\nvec2 float32x3_to_oct(in vec3 v) {\n  vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n  return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n}\nbool GetMetallicAlbedoFromDiffuseSpecularWithoutColor(out float metallic, out vec3 albedo, vec3 diffuse, vec3 specular, float f0 )\n{\n\tfloat d = max(max(diffuse.x, diffuse.y), diffuse.z);\n\tvec3 normalizedColor = diffuse / (d + (d < EPSILON_LOWP ? EPSILON_LOWP : 0.0));\n\tnormalizedColor = d < EPSILON_LOWP ? specular : normalizedColor;\n\tfloat s = max(max(specular.x, specular.y), specular.z);\n\tfloat delta = (d + s) * (d + s)  - 4.0 * f0 * d;\n\tfloat deltaSqrt = sqrt(max(0.0, delta));\n\tfloat solverMetallic = (-d - s + 2.0 * f0 + deltaSqrt) / (2.0 * f0);\n\tvec3 solverAlbedo = (d + s) * normalizedColor - vec3(f0 * (1.0 - solverMetallic));\n\tbool isValidSolver = delta >= 0.0;\n\tmetallic = isValidSolver ? clamp(solverMetallic, 0.0, 1.0) : 0.0;\n\talbedo = isValidSolver ? vec3(max(0.0, solverAlbedo.x), max(0.0, solverAlbedo.y), max(0.0, solverAlbedo.z)) : diffuse;\n\treturn isValidSolver;\n}\n  vec3 EnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n      #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n        roughness = pow(roughness, 0.5);\n      #endif\n    \tfloat mip = roughness * (mipCount - 1.0);\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n      vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    \tvec4 biased = fragTextureLod(cc_environment, rotationDir, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, rotationDir);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n  vec3 EnvReflection(samplerCube tex, vec3 R, float roughness, float mipCount) {\n    #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n      roughness = pow(roughness, 0.5);\n    #endif\n    vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    vec4 envmap = fragTextureLod(tex, rotationDir, roughness * (mipCount - 1.0));\n    #if CC_USE_IBL == 2 || CC_USE_REFLECTION_PROBE != REFLECTION_PROBE_TYPE_NONE\n      return unpackRGBE(envmap);\n    #else\n      return SRGBToLinear(envmap.rgb);\n    #endif\n  }\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  float SampleShadowMap (vec3 shadowNDCPos, sampler2D shadowMap)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return dot(texture(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    #else\n      return texture(shadowMap, shadowNDCPos.xy).x;\n    #endif\n  }\n  float NativePCFShadowFactorHard (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return step(shadowNDCPos.z, dot(texture(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      return step(shadowNDCPos.z, texture(shadowMap, shadowNDCPos.xy).x);\n    #endif\n  }\n  float NativePCFShadowFactorSoft (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block1 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)).x);\n    #endif\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorSoft3X (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    float shadowNDCPos_offset_L = shadowNDCPos.x - oneTap.x;\n    float shadowNDCPos_offset_R = shadowNDCPos.x + oneTap.x;\n    float shadowNDCPos_offset_U = shadowNDCPos.y - oneTap.y;\n    float shadowNDCPos_offset_D = shadowNDCPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)).x);\n      block1 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)).x);\n      block4 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block5 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)).x);\n      block6 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)).x);\n      block7 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)).x);\n      block8 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)).x);\n    #endif\n    float coefX = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float coefY = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float NativePCFShadowFactorSoft5X (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 twoTap = oneTap * 2.0;\n    vec2 offset1 = shadowNDCPos.xy + vec2(-twoTap.x, -twoTap.y);\n    vec2 offset2 = shadowNDCPos.xy + vec2(-oneTap.x, -twoTap.y);\n    vec2 offset3 = shadowNDCPos.xy + vec2(0.0, -twoTap.y);\n    vec2 offset4 = shadowNDCPos.xy + vec2(oneTap.x, -twoTap.y);\n    vec2 offset5 = shadowNDCPos.xy + vec2(twoTap.x, -twoTap.y);\n    vec2 offset6 = shadowNDCPos.xy + vec2(-twoTap.x, -oneTap.y);\n    vec2 offset7 = shadowNDCPos.xy + vec2(-oneTap.x, -oneTap.y);\n    vec2 offset8 = shadowNDCPos.xy + vec2(0.0, -oneTap.y);\n    vec2 offset9 = shadowNDCPos.xy + vec2(oneTap.x, -oneTap.y);\n    vec2 offset10 = shadowNDCPos.xy + vec2(twoTap.x, -oneTap.y);\n    vec2 offset11 = shadowNDCPos.xy + vec2(-twoTap.x, 0.0);\n    vec2 offset12 = shadowNDCPos.xy + vec2(-oneTap.x, 0.0);\n    vec2 offset13 = shadowNDCPos.xy + vec2(0.0, 0.0);\n    vec2 offset14 = shadowNDCPos.xy + vec2(oneTap.x, 0.0);\n    vec2 offset15 = shadowNDCPos.xy + vec2(twoTap.x, 0.0);\n    vec2 offset16 = shadowNDCPos.xy + vec2(-twoTap.x, oneTap.y);\n    vec2 offset17 = shadowNDCPos.xy + vec2(-oneTap.x, oneTap.y);\n    vec2 offset18 = shadowNDCPos.xy + vec2(0.0, oneTap.y);\n    vec2 offset19 = shadowNDCPos.xy + vec2(oneTap.x, oneTap.y);\n    vec2 offset20 = shadowNDCPos.xy + vec2(twoTap.x, oneTap.y);\n    vec2 offset21 = shadowNDCPos.xy + vec2(-twoTap.x, twoTap.y);\n    vec2 offset22 = shadowNDCPos.xy + vec2(-oneTap.x, twoTap.y);\n    vec2 offset23 = shadowNDCPos.xy + vec2(0.0, twoTap.y);\n    vec2 offset24 = shadowNDCPos.xy + vec2(oneTap.x, twoTap.y);\n    vec2 offset25 = shadowNDCPos.xy + vec2(twoTap.x, twoTap.y);\n    float block1, block2, block3, block4, block5, block6, block7, block8, block9, block10, block11, block12, block13, block14, block15, block16, block17, block18, block19, block20, block21, block22, block23, block24, block25;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, offset1), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, offset2), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, offset3), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture(shadowMap, offset4), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture(shadowMap, offset5), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture(shadowMap, offset6), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture(shadowMap, offset7), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture(shadowMap, offset8), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block9 = step(shadowNDCPos.z, dot(texture(shadowMap, offset9), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block10 = step(shadowNDCPos.z, dot(texture(shadowMap, offset10), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block11 = step(shadowNDCPos.z, dot(texture(shadowMap, offset11), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block12 = step(shadowNDCPos.z, dot(texture(shadowMap, offset12), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block13 = step(shadowNDCPos.z, dot(texture(shadowMap, offset13), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block14 = step(shadowNDCPos.z, dot(texture(shadowMap, offset14), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block15 = step(shadowNDCPos.z, dot(texture(shadowMap, offset15), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block16 = step(shadowNDCPos.z, dot(texture(shadowMap, offset16), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block17 = step(shadowNDCPos.z, dot(texture(shadowMap, offset17), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block18 = step(shadowNDCPos.z, dot(texture(shadowMap, offset18), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block19 = step(shadowNDCPos.z, dot(texture(shadowMap, offset19), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block20 = step(shadowNDCPos.z, dot(texture(shadowMap, offset20), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block21 = step(shadowNDCPos.z, dot(texture(shadowMap, offset21), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block22 = step(shadowNDCPos.z, dot(texture(shadowMap, offset22), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block23 = step(shadowNDCPos.z, dot(texture(shadowMap, offset23), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block24 = step(shadowNDCPos.z, dot(texture(shadowMap, offset24), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block25 = step(shadowNDCPos.z, dot(texture(shadowMap, offset25), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block1 = step(shadowNDCPos.z, texture(shadowMap, offset1).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, offset2).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, offset3).x);\n      block4 = step(shadowNDCPos.z, texture(shadowMap, offset4).x);\n      block5 = step(shadowNDCPos.z, texture(shadowMap, offset5).x);\n      block6 = step(shadowNDCPos.z, texture(shadowMap, offset6).x);\n      block7 = step(shadowNDCPos.z, texture(shadowMap, offset7).x);\n      block8 = step(shadowNDCPos.z, texture(shadowMap, offset8).x);\n      block9 = step(shadowNDCPos.z, texture(shadowMap, offset9).x);\n      block10 = step(shadowNDCPos.z, texture(shadowMap, offset10).x);\n      block11 = step(shadowNDCPos.z, texture(shadowMap, offset11).x);\n      block12 = step(shadowNDCPos.z, texture(shadowMap, offset12).x);\n      block13 = step(shadowNDCPos.z, texture(shadowMap, offset13).x);\n      block14 = step(shadowNDCPos.z, texture(shadowMap, offset14).x);\n      block15 = step(shadowNDCPos.z, texture(shadowMap, offset15).x);\n      block16 = step(shadowNDCPos.z, texture(shadowMap, offset16).x);\n      block17 = step(shadowNDCPos.z, texture(shadowMap, offset17).x);\n      block18 = step(shadowNDCPos.z, texture(shadowMap, offset18).x);\n      block19 = step(shadowNDCPos.z, texture(shadowMap, offset19).x);\n      block20 = step(shadowNDCPos.z, texture(shadowMap, offset20).x);\n      block21 = step(shadowNDCPos.z, texture(shadowMap, offset21).x);\n      block22 = step(shadowNDCPos.z, texture(shadowMap, offset22).x);\n      block23 = step(shadowNDCPos.z, texture(shadowMap, offset23).x);\n      block24 = step(shadowNDCPos.z, texture(shadowMap, offset24).x);\n      block25 = step(shadowNDCPos.z, texture(shadowMap, offset25).x);\n    #endif\n    vec2 coef = fract(shadowNDCPos.xy * shadowMapResolution);\n    vec2 v1X1 = mix(vec2(block1, block6), vec2(block2, block7), coef.xx);\n    vec2 v1X2 = mix(vec2(block2, block7), vec2(block3, block8), coef.xx);\n    vec2 v1X3 = mix(vec2(block3, block8), vec2(block4, block9), coef.xx);\n    vec2 v1X4 = mix(vec2(block4, block9), vec2(block5, block10), coef.xx);\n    float v1 = mix(v1X1.x, v1X1.y, coef.y) + mix(v1X2.x, v1X2.y, coef.y) + mix(v1X3.x, v1X3.y, coef.y) + mix(v1X4.x, v1X4.y, coef.y);\n    vec2 v2X1 = mix(vec2(block6, block11), vec2(block7, block12), coef.xx);\n    vec2 v2X2 = mix(vec2(block7, block12), vec2(block8, block13), coef.xx);\n    vec2 v2X3 = mix(vec2(block8, block13), vec2(block9, block14), coef.xx);\n    vec2 v2X4 = mix(vec2(block9, block14), vec2(block10, block15), coef.xx);\n    float v2 = mix(v2X1.x, v2X1.y, coef.y) + mix(v2X2.x, v2X2.y, coef.y) + mix(v2X3.x, v2X3.y, coef.y) + mix(v2X4.x, v2X4.y, coef.y);\n    vec2 v3X1 = mix(vec2(block11, block16), vec2(block12, block17), coef.xx);\n    vec2 v3X2 = mix(vec2(block12, block17), vec2(block13, block18), coef.xx);\n    vec2 v3X3 = mix(vec2(block13, block18), vec2(block14, block19), coef.xx);\n    vec2 v3X4 = mix(vec2(block14, block19), vec2(block15, block20), coef.xx);\n    float v3 = mix(v3X1.x, v3X1.y, coef.y) + mix(v3X2.x, v3X2.y, coef.y) + mix(v3X3.x, v3X3.y, coef.y) + mix(v3X4.x, v3X4.y, coef.y);\n    vec2 v4X1 = mix(vec2(block16, block21), vec2(block17, block22), coef.xx);\n    vec2 v4X2 = mix(vec2(block17, block22), vec2(block18, block23), coef.xx);\n    vec2 v4X3 = mix(vec2(block18, block23), vec2(block19, block24), coef.xx);\n    vec2 v4X4 = mix(vec2(block19, block24), vec2(block20, block25), coef.xx);\n    float v4 = mix(v4X1.x, v4X1.y, coef.y) + mix(v4X2.x, v4X2.y, coef.y) + mix(v4X3.x, v4X3.y, coef.y) + mix(v4X4.x, v4X4.y, coef.y);\n    float fAvg = (v1 + v2 + v3 + v4) * 0.0625;\n    return fAvg;\n  }\n  bool GetShadowNDCPos(out vec3 shadowNDCPos, vec4 shadowPosWithDepthBias)\n  {\n  \tshadowNDCPos = shadowPosWithDepthBias.xyz / shadowPosWithDepthBias.w * 0.5 + 0.5;\n  \tif (shadowNDCPos.x < 0.0 || shadowNDCPos.x > 1.0 ||\n  \t\tshadowNDCPos.y < 0.0 || shadowNDCPos.y > 1.0 ||\n  \t\tshadowNDCPos.z < 0.0 || shadowNDCPos.z > 1.0) {\n  \t\treturn false;\n  \t}\n  \tshadowNDCPos.xy = cc_cameraPos.w == 1.0 ? vec2(shadowNDCPos.xy.x, 1.0 - shadowNDCPos.xy.y) : shadowNDCPos.xy;\n  \treturn true;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, vec3 matViewDir0, vec3 matViewDir1, vec3 matViewDir2, vec2 projScaleXY)\n  {\n    vec4 newShadowPos = shadowPos;\n    if (normalBias > EPSILON_LOWP)\n    {\n      vec3 viewNormal = vec3(dot(matViewDir0, worldNormal), dot(matViewDir1, worldNormal), dot(matViewDir2, worldNormal));\n      if (viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, mat4 matLightView, vec2 projScaleXY)\n  {\n  \tvec4 newShadowPos = shadowPos;\n  \tif (normalBias > EPSILON_LOWP)\n  \t{\n  \t\tvec4 viewNormal = matLightView * vec4(worldNormal, 0.0);\n  \t\tif (viewNormal.z < 0.1)\n  \t\t\tnewShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n  \t}\n  \treturn newShadowPos;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Orthgraphic(float NDCDepth, float projScaleZ, float projBiasZ)\n  {\n  \treturn (NDCDepth - projBiasZ) / projScaleZ;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Perspective(float NDCDepth, float homogenousDividW, float invProjScaleZ, float invProjBiasZ)\n  {\n  \treturn NDCDepth * invProjScaleZ + homogenousDividW * invProjBiasZ;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n  \tvec3 viewSpacePos;\n  \tviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n  \tviewSpacePos.z = GetViewSpaceDepthFromNDCDepth_Perspective(shadowPos.z, shadowPos.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n  \tviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n  \tvec4 clipSpacePos;\n  \tclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n  \tclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n  \t#if CC_SHADOWMAP_USE_LINEAR_DEPTH\n  \t\tclipSpacePos.z = GetLinearDepthFromViewSpace(viewSpacePos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n  \t\tclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n  \t#endif\n  \treturn clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias, float projScaleZ, float projBiasZ)\n  {\n  \tfloat coeffA = projScaleZ;\n  \tfloat coeffB = projBiasZ;\n  \tfloat viewSpacePos_z = GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowPos.z, projScaleZ, projBiasZ);\n  \tviewSpacePos_z += viewspaceDepthBias;\n  \tvec4 result = shadowPos;\n  \tresult.z = viewSpacePos_z * coeffA + coeffB;\n  \treturn result;\n  }\n  vec4 ApplyShadowDepthBias_PerspectiveLinearDepth(vec4 shadowPos, float viewspaceDepthBias, vec3 worldPos)\n  {\n    shadowPos.z = CCGetLinearDepth(worldPos, viewspaceDepthBias) * 2.0 - 1.0;\n    shadowPos.z *= shadowPos.w;\n    return shadowPos;\n  }\n  float CCGetDirLightShadowFactorHard (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCSpotShadowFactorBase(out vec4 shadowNDCPosWithBias, vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    vec4 pos = vec4(1.0);\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      pos = ApplyShadowDepthBias_PerspectiveLinearDepth(shadowPos, shadowBias.x, worldPos);\n    #else\n      pos = ApplyShadowDepthBias_Perspective(shadowPos, shadowBias.x);\n    #endif\n    float realtimeShadow = 1.0;\n    if (pcf > 2.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft5X(pos, worldPos);\n    }else if (pcf > 1.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft3X(pos, worldPos);\n    }else if (pcf > 0.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft(pos, worldPos);\n    }else {\n      realtimeShadow = CCGetSpotLightShadowFactorHard(pos, worldPos);\n    }\n    shadowNDCPosWithBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  float CCShadowFactorBase(out vec4 shadowNDCPosWithBias, vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y, cc_matLightView, cc_shadowProjInfo.xy);\n    pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n    float realtimeShadow = 1.0;\n    #if CC_DIR_SHADOW_PCF_TYPE == 3\n      realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 2\n      realtimeShadow =  CCGetDirLightShadowFactorSoft3X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 1\n      realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 0\n      realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n    #endif\n    shadowNDCPosWithBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n    bool CCGetCSMLevelWithTransition(out float ratio, vec3 clipPos) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      highp float maxRange = 1.0 - cc_csmSplitsInfo.x - layerThreshold;\n      highp float minRange = cc_csmSplitsInfo.x - layerThreshold;\n      if (clipPos.x <= minRange || clipPos.x >= maxRange ||\n          clipPos.y <= minRange || clipPos.y >= maxRange) {\n        if (clipPos.x >= layerThreshold && clipPos.x <= cc_csmSplitsInfo.x) {\n          ratio = (clipPos.x - layerThreshold) / (cc_csmSplitsInfo.x - layerThreshold);\n        }\n        if (clipPos.x >= maxRange && clipPos.x <= 1.0 - layerThreshold) {\n          ratio = (clipPos.x - maxRange) / (cc_csmSplitsInfo.x - layerThreshold);\n        }\n        if (clipPos.y >= 0.0 && clipPos.y <= cc_csmSplitsInfo.x) {\n          ratio = min((clipPos.y - layerThreshold) / (cc_csmSplitsInfo.x - layerThreshold), 1.0);\n        }\n        if (clipPos.y >= maxRange && clipPos.y <= 1.0 - layerThreshold) {\n          ratio = (clipPos.y - maxRange) / (cc_csmSplitsInfo.x - layerThreshold);\n        }\n        return true;\n      }\n      return false;\n    }\n    int CCGetCSMLevel(out bool hasNextTransition, out bool transitionArea, out float transitionRatio, out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos, int nextLayer)\n    {\n      int layer = -1;\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= (0.0 + layerThreshold) && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= (0.0 + layerThreshold) && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0) {\n          #if CC_CASCADED_LAYERS_TRANSITION\n            if (layer < 0 || (nextLayer >= 0 && i == nextLayer))\n          #else\n            if (layer < 0)\n          #endif\n          {\n            #if CC_CASCADED_LAYERS_TRANSITION\n              if (nextLayer < 0) {\n                transitionArea = CCGetCSMLevelWithTransition(transitionRatio, clipPos);\n              }\n            #endif\n            csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n            csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n            shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n            shadowProjInfo = cc_csmProjInfo[i];\n            shadowViewDir0 = cc_csmViewDir0[i].xyz;\n            shadowViewDir1 = cc_csmViewDir1[i].xyz;\n            shadowViewDir2 = cc_csmViewDir2[i].xyz;\n            layer = i;\n            #if CC_CASCADED_LAYERS_TRANSITION\n              hasNextTransition = true;\n            #endif\n          }\n        }\n      }\n      return layer;\n    }\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      bool hasNextTransition = false;\n      bool transitionArea = false;\n      float transitionRatio = 0.0;\n      int nextLayer = -1;\n      return CCGetCSMLevel(hasNextTransition, transitionArea, transitionRatio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos, nextLayer);\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmNDCPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias)\n    {\n      bool hasNext = false;\n      bool transitionArea = false;\n      float ratio = 0.0;\n      csmPos = vec4(1.0);\n      vec4 shadowProjDepthInfo, shadowProjInfo;\n      vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n      int level = -1;\n      #if CC_CASCADED_LAYERS_TRANSITION\n        level = CCGetCSMLevel(hasNext, transitionArea, ratio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos, -1);\n      #else\n        level = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #endif\n      if (level < 0) { return 1.0; }\n      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y, shadowViewDir0, shadowViewDir1, shadowViewDir2, shadowProjInfo.xy);\n      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n      csmNDCPosWithBias = pos;\n      float realtimeShadow = 1.0;\n      #if CC_DIR_SHADOW_PCF_TYPE == 3\n        realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 2\n        realtimeShadow = CCGetDirLightShadowFactorSoft3X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 1\n        realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 0\n        realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n      #endif\n      #if CC_CASCADED_LAYERS_TRANSITION\n        vec4 nextCSMPos = vec4(1.0);\n        vec4 nextShadowProjDepthInfo, nextShadowProjInfo;\n        vec3 nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2;\n        float nextRealtimeShadow = 1.0;\n        CCGetCSMLevel(hasNext, transitionArea, ratio, nextCSMPos, nextShadowProjDepthInfo, nextShadowProjInfo, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, worldPos, level + 1);\n        if (hasNext && transitionArea) {\n          vec4 nexPos = ApplyShadowDepthBias_FaceNormal(nextCSMPos, N, shadowBias.y, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, nextShadowProjInfo.xy);\n          nexPos = ApplyShadowDepthBias_Orthographic(nexPos, shadowBias.x, nextShadowProjDepthInfo.x, nextShadowProjDepthInfo.y);\n          #if CC_DIR_SHADOW_PCF_TYPE == 3\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft5X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 2\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft3X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 1\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 0\n            nextRealtimeShadow = CCGetDirLightShadowFactorHard(nexPos);\n          #endif\n          return mix(mix(nextRealtimeShadow, realtimeShadow, ratio), 1.0, cc_shadowNFLSInfo.w);\n        }\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #else\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #endif\n    }\n  #else\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      return -1;\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmNDCPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias) {\n      csmPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n      return CCShadowFactorBase(csmNDCPosWithBias, csmPos, N, shadowBias);\n    }\n  #endif\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias) {\n    vec4 shadowNDCPosWithBias;\n    return CCShadowFactorBase(shadowNDCPosWithBias, shadowPos, N, shadowBias);\n  }\n  float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias) {\n    vec4 csmPos, csmNDCPosWithBias;\n    return CCCSMFactorBase(csmPos, csmNDCPosWithBias, worldPos, N, shadowBias);\n  }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    vec4 shadowNDCPosWithBias;\n    return CCSpotShadowFactorBase(shadowNDCPosWithBias, shadowPos, worldPos, shadowBias);\n  }\n#endif\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n\tcolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  vec3 SHEvaluate(vec3 normal)\n  {\n  #if USE_INSTANCING\n      vec3 result;\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(v_sh_linear_const_r, normal4);\n      result.g = dot(v_sh_linear_const_g, normal4);\n      result.b = dot(v_sh_linear_const_b, normal4);\n      return result;\n  #else\n      vec3 result;\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(cc_sh_linear_const_r, normal4);\n      result.g = dot(cc_sh_linear_const_g, normal4);\n      result.b = dot(cc_sh_linear_const_b, normal4);\n      vec4 n14 = normal.xyzz * normal.yzzx;\n      float n5 = normal.x * normal.x - normal.y * normal.y;\n      result.r += dot(cc_sh_quadratic_r, n14);\n      result.g += dot(cc_sh_quadratic_g, n14);\n      result.b += dot(cc_sh_quadratic_b, n14);\n      result += (cc_sh_quadratic_a.rgb * n5);\n      return result;\n  #endif\n  }\n  #endif\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n  void SampleAndDecodeLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  #if CC_LIGHT_MAP_VERSION > 2\n  #elif CC_LIGHT_MAP_VERSION > 1\n  \tluv.x *= 0.5;\n  \tvec4 dataLow = texture(lightingMap, luv);\n  \tvec4 dataHigh = texture(lightingMap, luv + vec2(0.5, 0.0));\n  \tlightmapColor.xyz = dataLow + dataHigh * 0.00392156862745098;\n      lightmapColor.rgb *= lum;\n  \tdirShadow = dataLow.a;\n  \tao = dataHigh.a;\n  #else\n      vec4 lightmap = texture(lightingMap, luv);\n      lightmapColor = lightmap.rgb * lum;\n  \tdirShadow = lightmap.a;\n  \tao = 1.0;\n  #endif\n  }\n  void GetLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  \tvec4 lightmap;\n  \tvec2 occlusion;\n  \tSampleAndDecodeLightMapColor(lightmapColor, dirShadow, ao, lightingMap, luv, lum, worldNormal);\n  #if CC_USE_HDR\n      lightmapColor.rgb *= cc_exposure.w * cc_exposure.x;\n  #endif\n  }\n#endif\nlayout(std140) uniform Constants {\n  vec4  tilingOffset;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float emissiveScale;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\n#define DCC_APP_OTHERS 0\n#define DCC_APP_MAX 1\n#define DCC_APP_BLENDER 2\n#define DCC_APP_CINEMA4D 3\n#define DCC_APP_GLTF 4\n#define DCC_APP_MAYA 5\n#if USE_SHININESS_MAP\n  uniform sampler2D shininessExponentMap;\n#endif\n#if USE_SPECULAR_GLOSSINESS_MAP\n  uniform sampler2D specularGlossinessMap;\n#endif\n#if USE_SPECULAR_MAP\n  uniform sampler2D specularMap;\n#endif\n #if USE_METALLIC_MAP\n  uniform sampler2D metallicMap;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_EMISSIVESCALE_MAP\n  uniform sampler2D emissiveScaleMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\nfloat discolor(vec3 srcColor)\n{\n  return dot(GRAY_VECTOR, srcColor);\n}\nfloat convertShininessExponent(float shininessExp)\n{\n  #if DCC_APP_NAME == DCC_APP_BLENDER\n    float glossiness = clamp(sqrt(shininessExp) * 0.1, 0.0, 0.95);\n  #elif DCC_APP_NAME == DCC_APP_MAX || DCC_APP_NAME == DCC_APP_MAYA\n    float l2 = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n    float glossiness = pow(l2, 0.5);\n  #else\n    float glossiness = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n  #endif\n    return glossiness;\n}\nfloat getSpecularIntensityFromRoughness(float roughness)\n{\n  #if DCC_APP_NAME == DCC_APP_BLENDER\n    float specularIntensityMultiplier = mix(1.0, 5.0, roughness);\n  #elif DCC_APP_NAME == DCC_APP_CINEMA4D\n    float specularIntensityMultiplier = mix(1.0, 50.0, roughness);\n  #elif DCC_APP_NAME == DCC_APP_MAX || DCC_APP_NAME == DCC_APP_MAYA\n    float specularIntensityMultiplier = mix(1.0, 20.0, roughness);\n  #else\n    float specularIntensityMultiplier = 1.0;\n  #endif\n    return specularIntensityMultiplier;\n}\nvec4 getSpecularColorAndFactor()\n{\n  vec3 inSpecular = specularColor.rgb * specularFactor;\n  float inFactor = 1.0;\n  #if USE_SPECULAR_GLOSSINESS_MAP\n    inSpecular = SRGBToLinear(texture(specularGlossinessMap, TEXTURE_UV).rgb);\n  #endif\n  #if USE_SPECULAR_MAP\n      vec4 specularTex = texture(specularMap, TEXTURE_UV);\n      specularTex.rgb = SRGBToLinear(specularTex.rgb);\n      inSpecular = specularTex.rgb;\n  #endif\n  return vec4(inSpecular, inFactor);\n}\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n  vec3 normal = FSInput_worldNormal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    normal = CalculateNormalFromTangentSpace(nmmp, normalScale, normal.xyz, FSInput_worldTangent, FSInput_mirrorNormal);\n  #endif\n  return normalize(normal);\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n  vec3 emissiveColor = emissive.rgb;\n  #if USE_EMISSIVE_MAP\n      emissiveColor.rgb = SRGBToLinear(texture(emissiveMap, TEXTURE_UV).rgb);\n  #endif\n  #if USE_EMISSIVESCALE_MAP\n      vec4 emissiveScaleColor = texture(emissiveScaleMap, TEXTURE_UV);\n      emissiveScaleColor.rgb = SRGBToLinear(emissiveScaleColor.rgb);\n      emissiveColor.rgb *= emissiveScaleColor.rgb;\n  #else\n      emissiveColor.rgb *= emissiveScale;\n  #endif\n  return emissiveColor;\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nstruct SurfacesMaterialData\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPos, worldPos_fract_part;\n  #else\n  vec3 worldPos;\n  #endif\n  vec4 baseColor;\n  vec3 worldNormal;\n  vec3 emissive;\n  float specularIntensity;\n  float roughness;\n  float metallic;\n  float ao;\n  vec3 worldTangent, worldBinormal;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMITTENCE\n  vec4 transmittenceParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRT\n  float roughnessTRT;\n#endif\n};\nvoid SurfacesFragmentModifySharedData(inout SurfacesMaterialData surfaceData)\n{\n    vec4 baseColor = vec4(1.0);\n    #if USE_VERTEX_COLOR\n      baseColor.rgb *= SRGBToLinear(FSInput_vertexColor.rgb);\n      baseColor.a *= FSInput_vertexColor.a;\n    #endif\n    #if USE_ALBEDO_MAP\n      vec4 texColor = texture(albedoMap, TEXTURE_UV);\n      texColor.rgb = SRGBToLinear(texColor.rgb);\n      texColor.a *= transparencyFactor;\n      baseColor *= texColor;\n    #else\n      baseColor *= diffuseColor;\n    #endif\n    baseColor.rgb *= diffuseFactor;\n    #if USE_TRANSPARENCY_MAP\n      baseColor.a = texture(transparencyMap, TEXTURE_UV).TRANSPARENCY_MAP_CHANNEL;\n      #if DCC_APP_NAME == DCC_APP_MAYA\n        baseColor.a = 1.0 - baseColor.a;\n      #endif\n    #endif\n    #if USE_ALPHA_TEST\n      if (baseColor.a < alphaThreshold) discard;\n    #endif\n    vec4 specularColorAndFactor = getSpecularColorAndFactor();\n    float inGlossiness = 0.0, inSpecularIntensity = 1.0;\n    #if HAS_EXPORTED_GLOSSINESS\n      #if USE_SPECULAR_GLOSSINESS_MAP\n        inGlossiness = 1.0 - texture(specularGlossinessMap, TEXTURE_UV).a;\n      #else\n        inGlossiness = glossiness;\n      #endif\n    #else\n      #if USE_SHININESS_MAP\n        #if GLOSSINESS_MAP_USE_SINGLE_CHANNEL\n          inGlossiness = 1.0 - texture(shininessExponentMap, TEXTURE_UV).GLOSSINESS_MAP_CHANNEL;\n        #else\n          inGlossiness = 1.0 - discolor(texture(shininessExponentMap, TEXTURE_UV).rgb);\n        #endif\n      #else\n        inGlossiness = convertShininessExponent(shininessExponent);\n      #endif\n      inSpecularIntensity *= getSpecularIntensityFromRoughness(1.0 - inGlossiness);\n    #endif\n    float inMetallic = 0.0;\n    vec3 albedo = baseColor.rgb;\n    #if HAS_EXPORTED_METALLIC\n      inMetallic = metallic;\n      float spec = specularFactor;\n      #if USE_SPECULAR_MAP\n        spec = dot(GRAY_VECTOR, texture(specularMap, TEXTURE_UV).rgb);\n      #endif\n      inSpecularIntensity *= spec * 0.5;\n    #else\n      GetMetallicAlbedoFromDiffuseSpecularWithoutColor(inMetallic, albedo.rgb, baseColor.rgb, specularColorAndFactor.rgb, 0.04);\n      inSpecularIntensity *= inMetallic;\n    #endif\n    baseColor.rgb = albedo;\n    surfaceData.baseColor = baseColor;\n    surfaceData.specularIntensity = inSpecularIntensity * 0.5;\n    surfaceData.roughness = 1.0 - inGlossiness;\n    surfaceData.metallic = inMetallic;\n    surfaceData.ao = 1.0;\n    #if USE_OCCLUSION_MAP\n      surfaceData.ao = texture(occlusionMap, OCCLUSION_UV).OCCLUSION_CHANNEL;\n    #endif\n}\nstruct LightingIntermediateData\n{\n  vec3 N, H, L, V;\n  float distToLight, distToLightSqr;\n  float distToCamera, distToCameraSqr;\n  float NoL, NoV, NoH;\n  float NoLSat, NoVSat, NoHSat;\n  float NoVAbsSat;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPosition, worldPosition_fract_part;\n  #else\n  vec3 worldPosition;\n  #endif\n  vec3 T, B;\n  float specularParam;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMITTENCE\n  vec4 shadowPosAndDepth;\n  vec4 transmittenceParams;\n#endif\n};\nvoid CCSurfacesLightingGetIntermediateData_PerPixel(inout LightingIntermediateData data, vec3 worldNormal, vec3 worldPos, vec3 worldTangent, vec3 worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n    , float anisotropyShape\n#endif\n)\n{\n  data.N = worldNormal;\n  data.V = cc_cameraPos.xyz - worldPos;\n  data.distToCameraSqr = dot(data.V, data.V);\n  data.distToCamera = sqrt(data.distToCameraSqr);\n  data.V /= data.distToCamera;\n  data.NoV = dot(data.N, data.V);\n  data.NoVSat = max(data.NoV, 0.0);\n  data.NoVAbsSat = max(abs(data.NoV), 0.0);\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(data.worldPosition, data.worldPosition_fract_part, worldPos);\n  #else\n  data.worldPosition = worldPos;\n  #endif\n  data.T = worldTangent;\n  data.B = worldBinormal;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  data.anisotropyShape = anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMITTENCE\n  data.shadowPosAndDepth = vec4(0.0, 0.0, 999999.0, 999999.0);\n#endif\n}\nvoid CCSurfacesLightingGetIntermediateData_PerLight(inout LightingIntermediateData data, vec3 lightDirWithDist)\n{\n  data.L = lightDirWithDist;\n  data.distToLightSqr = dot(data.L, data.L);\n  data.distToLight = sqrt(data.distToLightSqr);\n  data.L /= data.distToLight;\n  data.H = normalize(data.L + data.V);\n  data.NoL = dot(data.N, data.L);\n  data.NoH = dot(data.N, data.H);\n  data.NoLSat = max(data.NoL, 0.0);\n  data.NoHSat = max(data.NoH, 0.0);\n}\nstruct LightingResult\n{\n  vec3 diffuseColorWithLighting, specularColorWithLighting;\n  vec3 directDiffuse, directSpecular;\n  vec3 environmentDiffuse, environmentSpecular;\n  float shadow, ao;\n  vec3 lightmapColor;\n  vec3 emissive;\n#if CC_SURFACES_LIGHTING_USE_FRESNEL\n  float fresnel;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  vec3 directTransmitSpecular;\n  vec3 environmentTransmitSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMITTENCE\n  vec3 transmittence;\n#endif\n#if CC_SURFACES_LIGHTING_TRT\n  vec3 directTRT, environmentTRT;\n#endif\n};\nfloat D_GGX(float roughness, float NoH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float d = (NoH * m2 - NoH) * NoH + 1.0;\n    return m2 / max(EPSILON, d * d);\n}\nfloat D_GGXMobile(float roughness, float NoH) {\n  float OneMinusNoHSqr = 1.0 - NoH * NoH;\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nvoid GetAnisotropicRoughness(float roughness, float anisotropyShape, out float roughnessX, out float roughnessY)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    float r1 = roughness, r2 = roughness;\n    float lerpedRoughness = mix(1.0, 10.0, anisotropyShape);\n    r2 *= shapeSign < 0.0 ? lerpedRoughness : 1.0;\n    r1 *= shapeSign > 0.0 ? lerpedRoughness : 1.0;\n    roughnessX = saturate(r1);\n    roughnessY = saturate(r2);\n}\nfloat D_GGXAniso(float RoughnessX, float RoughnessY, float NoH, vec3 H, vec3 X, vec3 Y)\n{\n    float mx = max(EPSILON_LOWP, RoughnessX * RoughnessX);\n    float my = max(EPSILON_LOWP, RoughnessY * RoughnessY);\n    float XoH = dot(X, H);\n    float YoH = dot(Y, H);\n    float d = XoH * XoH / (mx * mx) + YoH * YoH / (my * my) + NoH * NoH;\n    return 1.0 / max(EPSILON_LOWP, mx * my * d * d);\n}\nvec3 GetAnisotropicReflect(float roughness, float anisotropyShape, vec3 V, vec3 N, vec3 X, vec3 Y)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    anisotropyShape = min(anisotropyShape, 0.4);\n    anisotropyShape *= smoothstep(0.0, 0.03, roughness);\n    vec3 reflectTarget = shapeSign < 0.0 ? mix(N, -Y, anisotropyShape) :\n                         shapeSign > 0.0 ? mix(N, -X, anisotropyShape) : N;\n    return reflect(-V, reflectTarget);\n}\nvec3 IntegratedGFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#define DiffuseCoefficient_EnergyConservation INV_PI\nfloat CalculateFresnelCoefficient(float ior, float NoVSat)\n{\n\tfloat g, c, n, prev, next;\n\tn = ior;\n\tc = ior * NoVSat;\n\tg = sqrt(1.0 + c * c - c);\n\tprev = (g - c) / (g + c);\n\tnext = (c * (g+c) - n*n) / (c * (g-c) + n*n);\n\tprev *= prev;\n\tnext *= next;\n\treturn 0.5 * prev * (1.0 + next);\n}\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\nfloat CalculateDistanceAttenuation(float distToLightSqr, float lightRadius, float lightRange)\n{\n  float litRadiusSqr = lightRadius * lightRadius;\n  float attRadiusSqrInv = 1.0 / max(lightRange, 0.01);\n  attRadiusSqrInv *= attRadiusSqrInv;\n  float edgeAttenuation = litRadiusSqr / max(litRadiusSqr, distToLightSqr);\n  return GetDistAtt(distToLightSqr, attRadiusSqrInv) * edgeAttenuation;\n}\nfloat CalculateAngleAttenuation(vec3 spotLightDir, vec3 L, float cosAngleOuter)\n{\n  float cosInner = max(dot(spotLightDir, L), 0.01);\n  float litAngleScale = 1.0 / max(0.001, cosInner - cosAngleOuter);\n  float litAngleOffset = -cosAngleOuter * litAngleScale;\n  return GetAngleAtt(L, spotLightDir, litAngleScale, litAngleOffset);\n}\nvec3 CalculateRefractDirection(vec3 N, vec3 V, float NoV, float ior)\n{\n  float NoVAbs = abs(NoV);\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  NoV *= sideSign;\n  float sinB = sqrt(1.0 - NoVAbs*NoVAbs) / ior;\n  vec3 X = normalize(-V + N * NoVAbs);\n  vec3 R = -N + X * sinB;\n  return R;\n}\nvec3 CalculateReflectDirection(vec3 N, vec3 V, float NoV)\n{\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  return reflect(-V, N);\n}\nvoid LightingCalculateDirect(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    lightingDiffuse = irradiance * DiffuseCoefficient_EnergyConservation;\n    float roughness = lightingData.specularParam;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n    float rT, rB;\n    GetAnisotropicRoughness(roughness, lightingData.anisotropyShape, rT, rB);\n    float calcSpec = D_GGXAniso(rT, rB, lightingData.NoHSat, lightingData.H, lightingData.T, lightingData.B);\n#else\n  #if CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n    float calcSpec = (roughness * 0.25 + 0.25) * D_GGXMobile(roughness, lightingData.NoHSat);\n  #else\n    float calcSpec = D_GGX(roughness, lightingData.NoHSat);\n  #endif\n#endif\n    lightingSpecular = irradiance * calcSpec;\n}\n#if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  vec3 EnvAnisotropicReflection(samplerCube tex, vec3 R, float roughness, float mipCount, float anisotropyShape, vec3 V, vec3 N, vec3 T, vec3 B) {\n      R = normalize(R);\n      float integratedBRDF = 0.0;\n      vec3 envSpec = vec3(0.0);\n      const int SAMPLE_STEP_COUNT = CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT;\n      float sampleAngleRange = PI * abs(anisotropyShape);\n      vec3 anisoDirection = anisotropyShape < 0.0 ? T : B;\n      vec3 ROnNormalPlane = normalize(R - anisoDirection * dot(R, anisoDirection));\n      vec3 stepOffset = normalize(ROnNormalPlane - N) * (sampleAngleRange / float(SAMPLE_STEP_COUNT * 2));\n      for (int i = -SAMPLE_STEP_COUNT; i <= SAMPLE_STEP_COUNT; ++i)\n      {\n          float rT, rB;\n          GetAnisotropicRoughness(roughness, anisotropyShape, rT, rB);\n          #if CC_IBL_CONVOLUTED\n            float coef = abs(float(i)) / float(SAMPLE_STEP_COUNT) * float(SAMPLE_STEP_COUNT);\n          #else\n            float coef = pow(abs(float(i)) / float(SAMPLE_STEP_COUNT), 1.3) * float(SAMPLE_STEP_COUNT);\n          #endif\n          vec3 H = normalize(N + stepOffset * sign(float(i)) * coef);\n          vec3 L = reflect(-V, H);\n          float NoHSat = saturate(dot(N, H));\n          float calcSpec = D_GGXAniso(rT, rB, NoHSat, H, T, B);\n          envSpec += calcSpec * EnvReflection(tex, L, roughness, mipCount);\n          integratedBRDF += calcSpec;\n      }\n      envSpec /= integratedBRDF;\n      return envSpec;\n  }\n#endif\nvec3 SampleEnvironmentSpecular(samplerCube tex, in LightingIntermediateData lightingData, float mipCount)\n{\n    vec3 envSpec = vec3(0.0);\n    float roughness = lightingData.specularParam;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && !CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      vec3 R = GetAnisotropicReflect(roughness, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      vec3 R = CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV);\n    #endif\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      envSpec = EnvAnisotropicReflection(tex, R, roughness, mipCount, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      #if CC_SURFACES_USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        envSpec = EnvReflectionWithMipFiltering(normalize(R), roughness, mipCount, 0.6);\n      #else\n        envSpec = EnvReflection(tex, R, roughness, mipCount);\n      #endif\n    #endif\n    return envSpec;\n}\nvec3 CalculateEnvironmentDiffuse(in LightingIntermediateData lightingData, float lightIntensity)\n{\n  float fAmb = 0.5 - lightingData.N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP && !CC_USE_LIGHT_PROBE\n      vec4 diffuseMap = texture(cc_diffuseMap, lightingData.N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n  #endif\n  ambDiff.rgb *= lightIntensity;\n  #if CC_USE_LIGHT_PROBE\n    ambDiff.rgb += SHEvaluate(lightingData.N);\n  #endif\n  return ambDiff.rgb;\n}\nvec3 CalculateEnvironmentSpecular(in LightingIntermediateData lightingData, float lightIntensity)\n{\n  vec3 envSpec = vec3(0.0);\n#if CC_USE_REFLECTION_PROBE\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n    envSpec = SampleEnvironmentSpecular(cc_reflectionProbeCubemap, lightingData, cc_ambientGround.w);\n  #elif CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_PLANAR\n    vec3 R = normalize(CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV));\n    vec3 worldPos;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    worldPos = unpackHighpData(lightingData.worldPosition, lightingData.worldPosition_fract_part);\n    #else\n    worldPos = lightingData.worldPosition;\n    #endif\n    vec3 bumpedWorldPos = worldPos;\n    vec2 screenUV = GetPlanarReflectScreenUV(bumpedWorldPos, cc_matViewProj, cc_cameraPos.w, lightingData.V, R);\n    vec4 rgbe = fragTextureLod(cc_reflectionProbePlanarMap, screenUV, cc_ambientGround.w);\n    envSpec = unpackRGBE(rgbe);\n  #endif\n#elif CC_USE_IBL\n    envSpec = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w);\n#endif\n  return envSpec * lightIntensity;\n}\nbool CCSurfacesLightingEnableShadow(in float NoL)\n{\n  return NoL > 0.0;\n}\nfloat CCSurfacesLightingCalculateDistanceAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle)\n{\n  return CalculateDistanceAttenuation(lightingData.distToLightSqr, lightSizeRangeAngle.x, lightSizeRangeAngle.y);\n}\nfloat CCSurfacesLightingCalculateAngleAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle, in vec3 spotLightDir)\n{\n  return CalculateAngleAttenuation(spotLightDir, lightingData.L, lightSizeRangeAngle.z);\n}\nvoid CCSurfacesLightingCalculateDirect(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n  LightingCalculateDirect(lightingDiffuse, lightingSpecular, lightingData, lightSourceColorAndIntensity);\n}\nvoid CCSurfacesLightingCalculateEnvironment(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, float lightIntensity)\n{\n  lightingDiffuse = CalculateEnvironmentDiffuse(lightingData, lightIntensity);\n  lightingSpecular = CalculateEnvironmentSpecular(lightingData, lightIntensity);\n}\n#if CC_SURFACES_LIGHTING_USE_FRESNEL\n  float CCSurfaceLightingCalculateFresnel(in LightingIntermediateData lightingData)\n  {\n    return CalculateFresnelCoefficient(lightingData.ior, abs(lightingData.NoV));\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  void CCSurfacesLightingCalculateDirectTransmitSpecular(out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    float roughness = lightingData.specularParam;\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    vec3 R = CalculateRefractDirection(lightingData.N, lightingData.V, lightingData.NoV, lightingData.ior);\n    float RoL = dot(lightingData.L, R);\n    float calcSpec = D_GGX(roughness, saturate(RoL));\n    lightingSpecular = irradiance * calcSpec;\n  }\n  void CCSurfacesLightingCalculateEnvironmentTransmitSpecular(out vec3 lightingSpecular, in LightingIntermediateData lightingData, float lightIntensity)\n  {\n    vec3 envSpec = vec3(0.0);\n    vec3 R = CalculateRefractDirection(lightingData.N, lightingData.V, lightingData.NoV, lightingData.ior);\n    float roughness = lightingData.specularParam;\n  #if USE_REFLECTION_PROBE\n    #if USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n      envSpec = EnvReflection(cc_reflectionProbeCubemap, R, roughness, cc_ambientGround.w);\n    #endif\n  #endif\n  #if CC_USE_IBL && USE_REFLECTION_PROBE != REFLECTION_PROBE_TYPE_CUBE\n    envSpec = EnvReflection(cc_environment, R, roughness, cc_ambientGround.w);\n  #endif\n    lightingSpecular = envSpec * lightIntensity;\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMITTENCE\n  vec3 CCSurfacesLightingCalculateDirectTransmittence(in LightingResult lightingResult, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    vec3 backIrradiance = vec3(saturate(-lightingData.NoL)) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    vec3 transmitDiffuse = backIrradiance * DiffuseCoefficient_EnergyConservation;\n    lightingData.transmittenceParams;\n    return vec3(0.0);\n  }\n  vec3 CCSurfacesLightingCalculateEnvironmentTransmittence(in LightingResult lightingResult, in LightingIntermediateData lightingData, float lightIntensity)\n  {\n    lightingData.N *= -1.0;\n    vec3 backIrradiance = CalculateEnvironmentDiffuse(lightingData, lightIntensity);\n    lightingData.transmittenceParams;\n    return vec3(0.0);\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRT\n  #ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_SPECULAR_COLOR\n    vec3 SurfacesLightingGetTRTSpecularColor(float specBRDF, bool isSaturated)\n    {\n      return vec3(specBRDF);\n    }\n  #endif\n  void CCSurfacesLightingCalculateDirectTRT(out vec3 TRTColor, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    vec3 unused;\n    CCSurfacesLightingCalculateDirect(unused, TRTColor, lightingData, vec4(1.0));\n    vec3 Color = SurfacesLightingGetTRTSpecularColor(TRTColor.x, true);\n    TRTColor *= Color * lightSourceColorAndIntensity.w;\n  }\n  void CCSurfacesLightingCalculateEnvironmentTRT(out vec3 TRTColor, in LightingIntermediateData lightingData, float lightIntensity)\n  {\n    vec3 unused;\n    TRTColor = CalculateEnvironmentSpecular(lightingData, 1.0);\n    float brdf = length(TRTColor);\n    vec3 Color = SurfacesLightingGetTRTSpecularColor(brdf, false);\n    TRTColor *= Color * lightIntensity;\n  }\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\nvec4 SurfacesFragmentModifyBaseColorAndTransparency()\n{\n    return FSInput_vertexColor;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n    return normalize(FSInput_worldNormal);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_TANGENT_AND_BINORMAL\nvoid SurfacesFragmentModifyWorldTangentAndBinormal(inout vec3 worldTangent, inout vec3 worldBinormal, vec3 worldNormal)\n{\n    vec3 tangent = FSInput_worldTangent;\n#if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 binormal = normalize(CalculateBinormal(worldNormal.xyz, tangent, FSInput_mirrorNormal));\n    tangent = normalize(cross(binormal, worldNormal));\n#else\n    vec3 binormal = vec3(0.0, 0.0, 0.0);\n#endif\n    worldTangent = tangent;\n    worldBinormal = binormal;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_IOR\nfloat SurfacesFragmentModifyIOR()\n{\n    return 1.0;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\nvec4 SurfacesFragmentModifyAnisotropyParams(out float isRotation)\n{\n    isRotation = 1.0;\n    return vec4(1.0, 0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvec4 SurfacesFragmentModifyPBRParams()\n{\n    return vec4(1.0, 0.5, 0.0, 0.5);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMITTENCE_PARAMS\nvec4 SurfacesFragmentModifytransmittenceParamss()\n{\n    return vec4(1.0, 0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_PARAMS\nvec4 SurfacesFragmentModifyTRTParams()\n{\n    return vec4(0.5, 0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nvoid SurfacesFragmentModifySharedData(inout SurfacesMaterialData surfaceData)\n{\n}\n#endif\nvoid CCSurfacesFragmentGetMaterialData(inout SurfacesMaterialData surfaceData)\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part, FSInput_worldPos);\n  #else\n  surfaceData.worldPos = FSInput_worldPos;\n  #endif\n  surfaceData.baseColor = SurfacesFragmentModifyBaseColorAndTransparency();\n  surfaceData.worldNormal = SurfacesFragmentModifyWorldNormal();\n  SurfacesFragmentModifyWorldTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal);\n  surfaceData.ior = SurfacesFragmentModifyIOR();\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float isRotation;\n  vec4 anisotropyParams = SurfacesFragmentModifyAnisotropyParams(isRotation);\n  surfaceData.anisotropyShape = anisotropyParams.x;\n  if (isRotation > 0.0) {\n    RotateTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal, anisotropyParams.y);\n  } else {\n    vec3 anisoDirTS = anisotropyParams.yzw;\n    vec3 tangentWS = anisoDirTS.x * surfaceData.worldTangent + anisoDirTS.y * surfaceData.worldBinormal + anisoDirTS.z * surfaceData.worldNormal;\n    surfaceData.worldTangent = normalize(tangentWS);\n    surfaceData.worldBinormal = cross(surfaceData.worldNormal, tangentWS);\n  }\n#endif\n  surfaceData.emissive = SurfacesFragmentModifyEmissive();\n  vec4 pbr = SurfacesFragmentModifyPBRParams();\n  surfaceData.ao = pbr.x;\n  surfaceData.roughness = pbr.y;\n  surfaceData.metallic = pbr.z;\n  surfaceData.specularIntensity = pbr.w;\n#if CC_SURFACES_LIGHTING_TRANSMITTENCE\n  surfaceData.transmittenceParams =SurfacesFragmentModifytransmittenceParamss();\n#endif\n#if CC_SURFACES_LIGHTING_TRT\n  vec4 trt = SurfacesFragmentModifyTRTParams();\n  surfaceData.roughnessTRT = trt.x;\n#endif\n  SurfacesFragmentModifySharedData(surfaceData);\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP) {\n      surfaceData.worldNormal = FSInput_worldNormal;\n      surfaceData.worldTangent = FSInput_worldTangent;\n  }\n#endif\n#if CC_USE_DEBUG_VIEW\n  if (!IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO)\n      surfaceData.baseColor.rgb = vec3(1.0);\n#endif\n}\nvec3 CCSurfacesGetDiffuseColor(in SurfacesMaterialData surfaceData)\n{\n  return surfaceData.baseColor.rgb * (1.0 - surfaceData.metallic);\n}\nvec3 CCSurfacesGetSpecularColor(in SurfacesMaterialData surfaceData)\n{\n  float F0 = surfaceData.specularIntensity * 0.08;\n  return mix(vec3(F0), surfaceData.baseColor.rgb, surfaceData.metallic);\n}\nvoid CCSurfacesLightingInitializeColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n  diffuseColorWithLighting = CCSurfacesGetDiffuseColor(surfaceData);\n  specularColorWithLighting = IntegratedGFApprox(CCSurfacesGetSpecularColor(surfaceData).xyz, surfaceData.roughness, lightingData.NoVAbsSat);\n}\nvoid CCSurfacesLightingCalculateColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n}\nvoid CCSurfacesInitializeLightingIntermediateData(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  vec3 worldPos;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n  #else\n  worldPos = surfaceData.worldPos;\n  #endif\n  CCSurfacesLightingGetIntermediateData_PerPixel(lightingData, surfaceData.worldNormal, worldPos, surfaceData.worldTangent, surfaceData.worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n      , surfaceData.anisotropyShape\n#endif\n  );\n  lightingData.specularParam = surfaceData.roughness;\n  lightingData.ior = surfaceData.ior;\n}\nvoid CCSurfacesLightingCalculateIntermediateData_PerLight(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData, vec3 lightDirWithDist)\n{\n  CCSurfacesLightingGetIntermediateData_PerLight(lightingData, lightDirWithDist);\n#if CC_SURFACES_LIGHTING_TRANSMITTENCE\n  lightingData.transmittenceParams = surfaceData.transmittenceParams;\n#endif\n}\n#if CC_SURFACES_LIGHTING_TRT\nvoid CCSurfacesGetLightingIntermediateDataTRT(out LightingIntermediateData lightingDataTRT, in LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  lightingDataTRT = lightingData;\n  lightingDataTRT.specularParam = surfaceData.roughnessTRT;\n}\n#endif\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData)\n{\n  lightingResult.ao = surfaceData.ao;\n  lightingResult.emissive = surfaceData.emissive;\n}\n#if CC_PIPELINE_TYPE == 1\n  vec4 CCSurfacesDeferredOutput0(in SurfacesMaterialData surfaceData)\n  {\n    return surfaceData.baseColor;\n  }\n  vec4 CCSurfacesDeferredOutput1(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(float32x3_to_oct(surfaceData.worldNormal), surfaceData.roughness, surfaceData.metallic);\n  }\n  vec4 CCSurfacesDeferredOutput2(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(surfaceData.emissive, surfaceData.ao);\n  }\n#endif\nvec4 CCSurfacesShading(in SurfacesMaterialData surfaceData, in LightingResult lightingResult)\n{\n  vec4 color = vec4(0.0, 0.0, 0.0, surfaceData.baseColor.a);\n#if CC_FORWARD_ADD\n  color.xyz += lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithLighting;\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.directTransmitSpecular * lightingResult.specularColorWithLighting\n  #endif\n  ;\n#else\n  float fresnel = 1.0;\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    fresnel = lightingResult.fresnel;\n  #endif\n  color.xyz +=\n    ( lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithLighting * fresnel\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.directTransmitSpecular * lightingResult.specularColorWithLighting * (1.0 - fresnel)\n  #endif\n  #if CC_SURFACES_LIGHTING_TRT\n    + lightingResult.directTRT * lightingResult.specularColorWithLighting\n  #endif\n    )\n    * lightingResult.shadow;\n  #if CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_ALL_IN_ONE\n    color.xyz += lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting * lightingResult.shadow;\n  #elif CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n    color.xyz += lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting;\n  #endif\n  color.xyz +=\n    ( lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.environmentSpecular * lightingResult.specularColorWithLighting * fresnel\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.environmentTransmitSpecular * lightingResult.specularColorWithLighting * (1.0 - fresnel)\n  #endif\n  #if CC_SURFACES_LIGHTING_TRT\n    + lightingResult.environmentTRT * lightingResult.specularColorWithLighting\n  #endif\n    )\n    * lightingResult.ao;\n  color.xyz += lightingResult.emissive;\n#endif\n  return color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\nvoid CCSurfacesDebugViewSurfaceData(inout vec4 color, in SurfacesMaterialData surfaceData)\n{\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    float scalar;\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(surfaceData.worldNormal * 0.5 + vec3(0.5), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldBinormal * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSPARENCY)) < EPSILON) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.baseColor.a;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_BASE_COLOR)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(surfaceData.baseColor.rgb), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(CCSurfacesGetDiffuseColor(surfaceData)), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(CCSurfacesGetSpecularColor(surfaceData)), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ROUGHNESS)) < EPSILON) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.roughness;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_METALLIC)) < EPSILON) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.metallic;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY)) < EPSILON) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.specularIntensity;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n}\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD && !CC_ENABLE_CLUSTERED_LIGHT_CULLING\n    void CCSurfacesLighting(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      vec3 worldPos;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n      #else\n      worldPos = surfaceData.worldPos;\n      #endif\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, surfaceData, lightingData);\n      lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n      int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n      for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n        if (i >= numLights) break;\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, cc_lightPos[i].xyz - worldPos);\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, surfaceData, lightingData);\n        vec3 diffuseLighting, specularLighting;\n        CCSurfacesLightingCalculateDirect(diffuseLighting, specularLighting, lightingData, cc_lightColor[i]);\n        float fresnel = 1.0;\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        fresnel = lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n        vec3 transmitSpecularLighting;\n        CCSurfacesLightingCalculateDirectTransmitSpecular(transmitSpecularLighting, lightingData, cc_lightColor[i]);\n      #endif\n        float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowNDCPosWithBias = vec4(0.0);\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            shadowPos = cc_matLightViewProj * vec4(surfaceData.worldPos, 1.0);\n            shadow = CCSpotShadowFactorBase(shadowNDCPosWithBias, shadowPos, worldPos, shadowBias);\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMITTENCE\n            lightingData.shadowPosAndDepth.xy = shadowNDCPosWithBias.xy;\n            lightingData.shadowPosAndDepth.z = shadowPos.z;\n            lightingData.shadowPosAndDepth.w = GetViewSpaceDepthFromNDCDepth_Perspective(SampleShadowMap(shadowNDCPosWithBias.xyz, cc_spotShadowMap), shadowNDCPosWithBias.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n          #endif\n        }\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW) {\n          shadow = 1.0;\n        }\n      #endif\n        float distAtt = CCSurfacesLightingCalculateDistanceAttenuation(lightingData, cc_lightSizeRangeAngle[i]);\n        float angleAtt = 1.0;\n        if (cc_lightPos[i].w > 0.0) {\n          angleAtt = CCSurfacesLightingCalculateAngleAttenuation(lightingData, cc_lightSizeRangeAngle[i], -cc_lightDir[i].xyz);\n        }\n        float multiplier = distAtt * angleAtt * shadow;\n        lightingResult.directDiffuse += diffuseLighting * multiplier;\n        lightingResult.directSpecular += specularLighting * multiplier * fresnel;\n        #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n          lightingResult.directTransmitSpecular += transmitSpecularLighting * multiplier * (1.0 - fresnel);\n        #endif\n        #if CC_SURFACES_LIGHTING_TRANSMITTENCE\n          lightingResult.transmittence = CCSurfacesLightingCalculateDirectTransmittence(lightingResult, lightingData, cc_lightColor[i]);\n        #endif\n        #if CC_SURFACES_LIGHTING_TRT\n          CCSurfacesLightingCalculateDirectTRT(lightingResult.directTRT, lightingData, cc_lightColor[i]);\n        #endif\n      }\n    }\n  #else\n    void CCSurfacesLighting(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      CCSurfacesInitializeLightingResult(lightingResult, surfaceData);\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, surfaceData, lightingData);\n      CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, -cc_mainLitDir.xyz);\n      lightingResult.shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_mainLitDir.w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowNDCPosWithBias = vec4(0.0);\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            if (cc_shadowLPNNInfo.w > 0.0) {\n              #if CC_DIR_LIGHT_SHADOW_TYPE == 2\n                lightingResult.shadow = CCCSMFactorBase(shadowPos, shadowNDCPosWithBias, surfaceData.worldPos, lightingData.N, shadowBias);\n              #endif\n            } else {\n              #if CC_DIR_LIGHT_SHADOW_TYPE == 1\n                shadowPos = cc_matLightViewProj * vec4(surfaceData.worldPos, 1.0);\n                lightingResult.shadow = CCShadowFactorBase(shadowPos, shadowNDCPosWithBias, lightingData.N, shadowBias);\n              #endif\n            }\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMITTENCE\n            lightingData.shadowPosAndDepth.xy = shadowNDCPosWithBias.xy;\n            lightingData.shadowPosAndDepth.z = shadowPos.z;\n            lightingData.shadowPosAndDepth.w = GetViewSpaceDepthFromNDCDepth_Orthgraphic(SampleShadowMap(shadowNDCPosWithBias.xyz, cc_shadowMap), cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n          #endif\n        }\n      #endif\n      lightingResult.lightmapColor = vec3(0.0);\n      #if CC_SURFACES_USE_LIGHT_MAP && !CC_FORWARD_ADD\n\t\t    float lightmapShadow, lightmapAO;\n        GetLightMapColor(lightingResult.lightmapColor, lightmapShadow, lightmapAO, cc_lightingMap, FSInput_lightMapUV.xy, FSInput_lightMapUV.z, surfaceData.worldNormal);\n        #if CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n          lightingResult.shadow *= lightmapShadow;\n          lightingResult.ao *= lightmapAO;\n        #endif\n      #endif\n      lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n      #if CC_SURFACES_USE_LIGHT_MAP != LIGHT_MAP_TYPE_ALL_IN_ONE && !CC_FORWARD_ADD\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, surfaceData, lightingData);\n        CCSurfacesLightingCalculateDirect(lightingResult.directDiffuse, lightingResult.directSpecular, lightingData, cc_mainLitColor);\n      #endif\n      CCSurfacesLightingCalculateEnvironment(lightingResult.environmentDiffuse, lightingResult.environmentSpecular, lightingData, cc_ambientSky.w);\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n        CCSurfacesLightingCalculateDirectTransmitSpecular(lightingResult.directTransmitSpecular, lightingData, cc_mainLitColor);\n        CCSurfacesLightingCalculateEnvironmentTransmitSpecular(lightingResult.environmentTransmitSpecular, lightingData, cc_ambientSky.w);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMITTENCE\n        lightingResult.transmittence = CCSurfacesLightingCalculateDirectTransmittence(lightingResult, lightingData, cc_mainLitColor);\n        lightingResult.transmittence += CCSurfacesLightingCalculateEnvironmentTransmittence(lightingResult, lightingData, cc_ambientSky.w);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRT\n      LightingIntermediateData lightingDataTRT;\n        CCSurfacesGetLightingIntermediateDataTRT(lightingDataTRT, lightingData, surfaceData);\n        CCSurfacesLightingCalculateDirectTRT(lightingResult.directTRT, lightingDataTRT, cc_mainLitColor);\n        CCSurfacesLightingCalculateEnvironmentTRT(lightingResult.environmentTRT, lightingDataTRT, cc_ambientSky.w);\n      #endif\n      #if CC_ENABLE_CLUSTERED_LIGHT_CULLING\n      #endif\n      #ifdef CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT\n        SurfacesLightingModifyFinalResult(lightingResult, lightingData, surfaceData);\n      #endif\n    }\n  #endif\n#endif\nvec4 CCSurfacesDebugDisplayInvalidNumber(vec4 color)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(color.rgb) || isinfs(color.rgb)) ? error : color;\n}\nvec4 CCSurfacesDebugDisplayInvalidInputData(vec4 color, vec3 data)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(data) || isinfs(data)) ? error : color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && !CC_FORWARD_ADD\n  void CCSurfacesDebugViewMeshData(inout vec4 color)\n  {\n    vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_VERTEX_COLOR\n        color = FSInput_vertexColor;\n      #else\n        color = white;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(FSInput_worldNormal * 0.5 + vec3(0.5), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(FSInput_worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        float sign = FSInput_mirrorNormal * 0.5 + 0.5;\n        color = vec4(sign, sign, sign, 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FACE_SIDE)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n        float scalar = clamp(FSInput_faceSideSign, 0.0, 1.0);\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UV0)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(FSInput_texcoord.xy, 0.0, 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UV1)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n      color = vec4(FSInput_texcoord1.xy, 0.0, 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n        color = vec4(FSInput_lightMapUV.xy, 0.0, 1.0);\n      #else\n        color = vec4(0.0, 0.0, 0.0, 1.0);\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n      vec4 clipPos = cc_matProj * cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = clipPos.z / clipPos.w;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n      vec4 viewPos = cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = (-viewPos.z - cc_nearFar.x) / cc_nearFar.y;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_WORLD_POS)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n      color = vec4(FSInput_worldPos.xyz, 1.0);\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\n  bool CCSurfacesDebugViewLightingResult(inout vec4 color, in LightingResult lightingResult)\n  {\n      bool isDebugMatched = false;\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting;\n        isDebugMatched = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directSpecular * lightingResult.specularColorWithLighting;\n        isDebugMatched = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.directSpecular * lightingResult.specularColorWithLighting;\n        isDebugMatched = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting;\n        isDebugMatched = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentSpecular * lightingResult.specularColorWithLighting;\n        isDebugMatched = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_ALL)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.environmentSpecular * lightingResult.specularColorWithLighting;\n        isDebugMatched = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_LIGHT_MAP)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.lightmapColor;\n        isDebugMatched = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_EMISSIVE)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.emissive;\n        isDebugMatched = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_AO)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(lightingResult.ao);\n        isDebugMatched = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SHADOW)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(lightingResult.shadow);\n        isDebugMatched = true;\n    }\n    return isDebugMatched;\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  void CCSurfacesDebugViewCompositeLightingResult(inout LightingResult lightingResult)\n  {\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE)\n      lightingResult.directDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR)\n      lightingResult.directSpecular = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE)\n      lightingResult.environmentDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR)\n      lightingResult.environmentSpecular = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE)\n      lightingResult.emissive = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP)\n      lightingResult.lightmapColor = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW)\n      lightingResult.shadow = 1.0;\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO)\n      lightingResult.ao = 1.0;\n  }\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main()  {\n  #if CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER\n    float NoL = dot(-cc_mainLitDir.xyz, FSInput_worldNormal.xyz);\n    vec4 color = SurfacesFragmentModifyBaseColorAndTransparency();\n  #else\n    SurfacesMaterialData surfaceData;\n    CCSurfacesFragmentGetMaterialData(surfaceData);\n    vec2 shadowBias = vec2(0.0);\n    vec3 colDebugCSMLayer = vec3(1.0);\n    #if CC_RECEIVE_SHADOW\n      shadowBias = FSInput_shadowBias;\n      #if !CC_FORWARD_ADD\n        #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n          if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION)\n          {\n              vec4 csmPos;\n              vec4 shadowProjDepthInfo, shadowProjInfo;\n              vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n              int csmLayer = -1;\n              csmLayer = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, surfaceData.worldPos);\n              bool OutOfRange = csmLayer < 0;\n              if (OutOfRange)\n                  colDebugCSMLayer = vec3(1.0);\n              else if (csmLayer == 0)\n                  colDebugCSMLayer = vec3(1.0, 0.0, 0.0);\n              else if (csmLayer == 1)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 0.0);\n              else if (csmLayer == 2)\n                  colDebugCSMLayer = vec3(0.0, 0.0, 1.0);\n              else if (csmLayer == 3)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 1.0);\n          }\n        #endif\n      #endif\n    #endif\n    #if !CC_FORWARD_ADD\n      float fogFactor = 1.0;\n      #if CC_USE_FOG != 4\n        #if !CC_USE_ACCURATE_FOG\n          fogFactor = FSInput_fogFactor;\n        #else\n          CC_TRANSFER_FOG_BASE(vec4(FSInput_worldPos, 1.0), fogFactor);\n        #endif\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG) {\n            fogFactor = 1.0;\n        }\n      #endif\n    #endif\n    LightingResult lightingResult;\n    CCSurfacesLighting(lightingResult, surfaceData, shadowBias);\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && CC_SURFACES_ENABLE_DEBUG_VIEW\n      vec4 debugColor = vec4(0.0, 0.0, 0.0, 1.0);\n      #if !CC_FORWARD_ADD\n        CCSurfacesDebugViewMeshData(debugColor);\n        CCSurfacesDebugViewSurfaceData(debugColor, surfaceData);\n        if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FOG)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n        {\n          fogFactor = 1.0 - fogFactor;\n          debugColor = vec4(fogFactor, fogFactor, fogFactor, 1.0);\n        }\n      #endif\n      #if CC_FORWARD_ADD\n        if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) < EPSILON) && (cc_surfaceTransform.y != 3.0)) || ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) < EPSILON) && (cc_surfaceTransform.y != 3.0)) || ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n      #endif\n        {\n            if (CCSurfacesDebugViewLightingResult(debugColor, lightingResult))\n            {\n              #if CC_USE_HDR\n                if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING)\n                    debugColor.rgb = ACESToneMap(debugColor.rgb);\n              #endif\n              if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION)\n                  debugColor.rgb = LinearToSRGB(debugColor.rgb);\n            }\n        }\n      if (IS_DEBUG_VIEW_ENABLE_WITH_CAMERA) {\n        fragColorX = debugColor;\n        return;\n      }\n    #elif CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n      CCSurfacesDebugViewCompositeLightingResult(lightingResult);\n    #endif\n    vec4 color = CCSurfacesShading(surfaceData, lightingResult);\n    #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n      if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION) {\n          color.rgb *= colDebugCSMLayer.rgb;\n      }\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = CCSurfacesDebugDisplayInvalidInputData(color, FSInput_worldTangent);\n      #endif\n    #endif\n  #endif\n    #if CC_USE_HDR\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n        if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING)\n      #endif\n        color.rgb = ACESToneMap(color.rgb);\n    #endif\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n      if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION)\n    #endif\n    color.rgb = LinearToSRGB(color.rgb);\n    #if !CC_FORWARD_ADD && CC_USE_FOG != 4\n      CC_APPLY_FOG_BASE(color, fogFactor);\n    #endif\n    fragColorX = CCSurfacesDebugDisplayInvalidNumber(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n    layout(location = 0) out vec4 fragColor0;\n    layout(location = 1) out vec4 fragColor1;\n    layout(location = 2) out vec4 fragColor2;\n    void main () {\n      SurfacesMaterialData surfaceData;\n      CCSurfacesFragmentGetMaterialData(surfaceData);\n      fragColor0 = CCSurfacesDeferredOutput0(surfaceData);\n      fragColor1 = CCSurfacesDeferredOutput1(surfaceData);\n      fragColor2 = CCSurfacesDeferredOutput2(surfaceData);\n    }\n#endif"},"glsl1":{"vert":"\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE USE_REFLECTION_DENOISE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING USE_COMPATIBLE_LIGHTING\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMITTENCE\n  #define CC_SURFACES_LIGHTING_TRANSMITTENCE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  attribute vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  attribute vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n#endif\nvarying highp vec3 v_worldPos;\nvarying mediump vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW\n  varying mediump vec2 v_shadowBias;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBias\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW\n  vec2 shadowBias;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\nuniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n  uniform highp vec4 cc_localShadowBias;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n    float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n        vec4 wPos = pos;\n        float cam_dis = distance(cameraPos, wPos.xyz);\n        return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n    }\n    float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * fogDensity);\n        return f;\n    }\n    float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n        return f;\n    }\n    float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n        vec4 wPos = pos;\n        vec3 camWorldProj = cameraPos.xyz;\n        camWorldProj.y = 0.;\n        vec3 worldPosProj = wPos.xyz;\n        worldPosProj.y = 0.;\n        float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n        float fDeltaY, fDensityIntegral;\n        if (cameraPos.y > fogTop) {\n            if (wPos.y < fogTop) {\n                fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n                fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n            }\n            else {\n                fDeltaY = 0.;\n                fDensityIntegral = 0.;\n            }\n        }\n        else {\n            if (wPos.y < fogTop) {\n                float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n                float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n                fDeltaY = abs(fDeltaA - fDeltaB);\n                fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n            }\n            else {\n                fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n                fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n            }\n        }\n        float fDensity;\n        if (fDeltaY != 0.) {\n            fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n        }\n        else {\n            fDensity = 0.;\n        }\n        float f = exp(-fDensity);\n        return f;\n    }\n  #endif\n  void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n  {\n  #if CC_USE_FOG == 0\n  \tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n  #elif CC_USE_FOG == 1\n  \tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 2\n  \tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 3\n  \tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n  #else\n  \tfactor = 1.0;\n  #endif\n  }\n#endif\n    uniform vec4 tilingOffset;\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.position.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\nvec3 SurfacesVertexModifyLocalNormal(in SurfacesStandardVertexIntermediate In)\n{\n  return In.normal.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 SurfacesVertexModifyLocalTangent(in SurfacesStandardVertexIntermediate In)\n    {\n      return In.tangent;\n    }\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\nvec3 SurfacesVertexModifyWorldNormal(in SurfacesStandardVertexIntermediate In)\n{\n    vec3 worldNormal = In.worldNormal.xyz;\n  #if CC_SURFACES_USE_TWO_SIDED\n      worldNormal.xyz *= In.worldNormal.w;\n  #endif\n  return worldNormal;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBias;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferFog(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(vec4(In.worldPos, 1.0), In.fogFactor);\n#endif\n}\nvoid CCSurfacesVertexTransferShadow(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_RECEIVE_SHADOW\n    In.shadowBias = vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n    #if USE_INSTANCING\n      In.shadowBias += a_localShadowBias.xy;\n    #else\n      In.shadowBias += cc_localShadowBias.xy;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferLightMapUV(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #if USE_INSTANCING\n    In.lightmapUV.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    In.lightmapUV.z = a_lightingMapUVParam.w;\n  #else\n    In.lightmapUV.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    In.lightmapUV.z = cc_lightingMapUVParam.w;\n  #endif\n#endif\n}\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  In.normal.xyz = SurfacesVertexModifyLocalNormal(In);\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    In.tangent = SurfacesVertexModifyLocalTangent(In);\n  #endif\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matProj * cc_matView * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  vec3 viewDirect = normalize(cc_cameraPos.xyz - In.worldPos);\n  In.worldNormal.w = dot(In.worldNormal.xyz, viewDirect) < 0.0 ? -1.0 : 1.0;\n  In.worldNormal.xyz = SurfacesVertexModifyWorldNormal(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexTransferFog(In);\n  CCSurfacesVertexTransferShadow(In);\n  CCSurfacesVertexTransferLightMapUV(In);\n  CCSurfacesVertexOutput(In);\n}","frag":"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE USE_REFLECTION_DENOISE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING USE_COMPATIBLE_LIGHTING\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMITTENCE\n  #define CC_SURFACES_LIGHTING_TRANSMITTENCE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nvarying highp vec3 v_worldPos;\nvarying mediump vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW\n  varying mediump vec2 v_shadowBias;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBias\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\nuniform highp vec4 cc_time;\n  uniform mediump vec4 cc_debug_view_mode;\n  uniform mediump vec4 cc_debug_view_composite_pack_1;\n  uniform mediump vec4 cc_debug_view_composite_pack_2;\n  uniform mediump vec4 cc_debug_view_composite_pack_3;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_surfaceTransform;\n  uniform mediump vec4 cc_exposure;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_ambientSky;\n  uniform mediump vec4 cc_ambientGround;\n  uniform mediump vec4 cc_fogColor;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n  uniform mediump vec4 cc_nearFar;\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO ((cc_debug_view_mode.y > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION ((cc_debug_view_mode.z > 0.0) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE ((cc_debug_view_composite_pack_1.x > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR ((cc_debug_view_composite_pack_1.y > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE ((cc_debug_view_composite_pack_1.z > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR ((cc_debug_view_composite_pack_1.w > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE ((cc_debug_view_composite_pack_2.x > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP ((cc_debug_view_composite_pack_2.y > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW ((cc_debug_view_composite_pack_2.z > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO ((cc_debug_view_composite_pack_2.w > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP ((cc_debug_view_composite_pack_3.x > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG ((cc_debug_view_composite_pack_3.y > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING ((cc_debug_view_composite_pack_3.z > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION ((cc_debug_view_composite_pack_3.w > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    uniform vec4 cc_sh_linear_const_r;\n  uniform vec4 cc_sh_linear_const_g;\n  uniform vec4 cc_sh_linear_const_b;\n  uniform vec4 cc_sh_quadratic_r;\n  uniform vec4 cc_sh_quadratic_g;\n  uniform vec4 cc_sh_quadratic_b;\n  uniform vec4 cc_sh_quadratic_a;\n  #endif\n#endif\nuniform highp mat4 cc_matLightView;\n  uniform highp mat4 cc_matLightViewProj;\n  uniform highp vec4 cc_shadowInvProjDepthInfo;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  uniform highp vec4 cc_csmViewDir0[4];\n  uniform highp vec4 cc_csmViewDir1[4];\n  uniform highp vec4 cc_csmViewDir2[4];\n  uniform highp vec4 cc_csmAtlas[4];\n  uniform highp mat4 cc_matCSMViewProj[4];\n  uniform highp vec4 cc_csmProjDepthInfo[4];\n  uniform highp vec4 cc_csmProjInfo[4];\n  uniform highp vec4 cc_csmSplitsInfo;\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON)\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return texture2DLodEXT(tex, coord, lod);\n    #else\n      return texture2D(tex, coord, lod);\n    #endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return textureCubeLodEXT(tex, coord, lod);\n    #else\n      return textureCube(tex, coord, lod);\n    #endif\n}\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\nvec3 LinearToSRGB(vec3 linear) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return linear;\n    }\n  #endif\n#endif\n  return sqrt(linear);\n}\nbool isnan(float val) {\n  return (val < 0.0 || 0.0 < val || val == 0.0) ? false : true;\n}\nbool isinf(float x) {\n  return x == x * 2.0 && x != 0.0;\n}\nbool isnans(vec2 val) {\n    return isnan(val.x) || isnan(val.y);\n}\nbool isnans(vec3 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z);\n}\nbool isnans(vec4 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z) || isnan(val.w);\n}\nbool isinfs(vec2 val) {\n    return isinf(val.x) || isinf(val.y);\n}\nbool isinfs(vec3 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z);\n}\nbool isinfs(vec4 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z) || isinf(val.w);\n}\nfloat saturate(float value)\n{\n    return min(max(value, 0.0), 1.0);\n}\nvec2 saturate(vec2 value) { return vec2(saturate(value.x), saturate(value.y)); }\nvec3 saturate(vec3 value) { return vec3(saturate(value.x), saturate(value.y), saturate(value.z)); }\nvec4 saturate(vec4 value) { return vec4(saturate(value.x), saturate(value.y), saturate(value.z), saturate(value.w)); }\nvec2 GetPlanarReflectScreenUV(vec3 worldPos, mat4 matVirtualCameraViewProj, float flipNDCSign, vec3 viewDir, vec3 reflectDir)\n{\n  vec4 clipPos = matVirtualCameraViewProj * vec4(worldPos, 1.0);\n  vec2 screenUV = clipPos.xy / clipPos.w * 0.5 + 0.5;\n  screenUV = vec2(1.0 - screenUV.x, screenUV.y);\n  screenUV = flipNDCSign == 1.0 ? vec2(screenUV.x, 1.0 - screenUV.y) : screenUV;\n  return screenUV;\n}\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nvec3 CalculateBinormal(vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    return cross(normal.xyz, tangent) * mirrorNormal;\n}\nvec3 CalculateNormalFromTangentSpace(vec3 normalFromTangentSpace, float normalStrength, vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    vec3 binormal = CalculateBinormal(normal, tangent, mirrorNormal);\n    return (normalFromTangentSpace.x * normalStrength) * normalize(tangent) +\n           (normalFromTangentSpace.y * normalStrength) * normalize(binormal) +\n            normalFromTangentSpace.z * normalize(normal);\n}\nvec3 RotationVecFromAxisY(vec3 v, float cosTheta, float sinTheta)\n{\n    vec3 result;\n    result.x = dot(v, vec3(cosTheta, 0.0, -sinTheta));\n    result.y = v.y;\n    result.z = dot(v, vec3(sinTheta, 0.0,  cosTheta));\n    return result;\n}\nvoid RotateTangentAndBinormal(inout vec3 tangent, inout vec3 binormal, vec3 normal, float rotationAngle)\n{\n    float cosTheta = cos(rotationAngle), sinTheta = sin(rotationAngle);\n    vec3 B = RotationVecFromAxisY(vec3(1.0, 0.0, 0.0), cosTheta, sinTheta);\n    vec3 T = RotationVecFromAxisY(vec3(0.0, 0.0, 1.0), cosTheta, sinTheta);\n    vec3 tangentNew, binormalNew;\n    binormalNew = B.x * binormal + B.y * normal + B.z * tangent;\n    binormal = normalize(binormalNew);\n    tangentNew = T.x * binormal + T.y * normal + T.z * tangent;\n    tangent = normalize(tangentNew);\n}\nvec2 signNotZero(vec2 v) {\n  return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n}\nvec2 float32x3_to_oct(in vec3 v) {\n  vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n  return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n}\nbool GetMetallicAlbedoFromDiffuseSpecularWithoutColor(out float metallic, out vec3 albedo, vec3 diffuse, vec3 specular, float f0 )\n{\n\tfloat d = max(max(diffuse.x, diffuse.y), diffuse.z);\n\tvec3 normalizedColor = diffuse / (d + (d < EPSILON_LOWP ? EPSILON_LOWP : 0.0));\n\tnormalizedColor = d < EPSILON_LOWP ? specular : normalizedColor;\n\tfloat s = max(max(specular.x, specular.y), specular.z);\n\tfloat delta = (d + s) * (d + s)  - 4.0 * f0 * d;\n\tfloat deltaSqrt = sqrt(max(0.0, delta));\n\tfloat solverMetallic = (-d - s + 2.0 * f0 + deltaSqrt) / (2.0 * f0);\n\tvec3 solverAlbedo = (d + s) * normalizedColor - vec3(f0 * (1.0 - solverMetallic));\n\tbool isValidSolver = delta >= 0.0;\n\tmetallic = isValidSolver ? clamp(solverMetallic, 0.0, 1.0) : 0.0;\n\talbedo = isValidSolver ? vec3(max(0.0, solverAlbedo.x), max(0.0, solverAlbedo.y), max(0.0, solverAlbedo.z)) : diffuse;\n\treturn isValidSolver;\n}\n  vec3 EnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n      #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n        roughness = pow(roughness, 0.5);\n      #endif\n    \tfloat mip = roughness * (mipCount - 1.0);\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n      vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    \tvec4 biased = fragTextureLod(cc_environment, rotationDir, mip + mipBias);\n     \tvec4 filtered = textureCube(cc_environment, rotationDir);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n  vec3 EnvReflection(samplerCube tex, vec3 R, float roughness, float mipCount) {\n    #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n      roughness = pow(roughness, 0.5);\n    #endif\n    vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    vec4 envmap = fragTextureLod(tex, rotationDir, roughness * (mipCount - 1.0));\n    #if CC_USE_IBL == 2 || CC_USE_REFLECTION_PROBE != REFLECTION_PROBE_TYPE_NONE\n      return unpackRGBE(envmap);\n    #else\n      return SRGBToLinear(envmap.rgb);\n    #endif\n  }\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  float SampleShadowMap (vec3 shadowNDCPos, sampler2D shadowMap)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return dot(texture2D(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    #else\n      return texture2D(shadowMap, shadowNDCPos.xy).x;\n    #endif\n  }\n  float NativePCFShadowFactorHard (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return step(shadowNDCPos.z, dot(texture2D(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      return step(shadowNDCPos.z, texture2D(shadowMap, shadowNDCPos.xy).x);\n    #endif\n  }\n  float NativePCFShadowFactorSoft (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)).x);\n    #endif\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorSoft3X (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    float shadowNDCPos_offset_L = shadowNDCPos.x - oneTap.x;\n    float shadowNDCPos_offset_R = shadowNDCPos.x + oneTap.x;\n    float shadowNDCPos_offset_U = shadowNDCPos.y - oneTap.y;\n    float shadowNDCPos_offset_D = shadowNDCPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)).x);\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)).x);\n      block4 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block5 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)).x);\n      block6 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)).x);\n      block7 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)).x);\n      block8 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)).x);\n    #endif\n    float coefX = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float coefY = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float NativePCFShadowFactorSoft5X (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 twoTap = oneTap * 2.0;\n    vec2 offset1 = shadowNDCPos.xy + vec2(-twoTap.x, -twoTap.y);\n    vec2 offset2 = shadowNDCPos.xy + vec2(-oneTap.x, -twoTap.y);\n    vec2 offset3 = shadowNDCPos.xy + vec2(0.0, -twoTap.y);\n    vec2 offset4 = shadowNDCPos.xy + vec2(oneTap.x, -twoTap.y);\n    vec2 offset5 = shadowNDCPos.xy + vec2(twoTap.x, -twoTap.y);\n    vec2 offset6 = shadowNDCPos.xy + vec2(-twoTap.x, -oneTap.y);\n    vec2 offset7 = shadowNDCPos.xy + vec2(-oneTap.x, -oneTap.y);\n    vec2 offset8 = shadowNDCPos.xy + vec2(0.0, -oneTap.y);\n    vec2 offset9 = shadowNDCPos.xy + vec2(oneTap.x, -oneTap.y);\n    vec2 offset10 = shadowNDCPos.xy + vec2(twoTap.x, -oneTap.y);\n    vec2 offset11 = shadowNDCPos.xy + vec2(-twoTap.x, 0.0);\n    vec2 offset12 = shadowNDCPos.xy + vec2(-oneTap.x, 0.0);\n    vec2 offset13 = shadowNDCPos.xy + vec2(0.0, 0.0);\n    vec2 offset14 = shadowNDCPos.xy + vec2(oneTap.x, 0.0);\n    vec2 offset15 = shadowNDCPos.xy + vec2(twoTap.x, 0.0);\n    vec2 offset16 = shadowNDCPos.xy + vec2(-twoTap.x, oneTap.y);\n    vec2 offset17 = shadowNDCPos.xy + vec2(-oneTap.x, oneTap.y);\n    vec2 offset18 = shadowNDCPos.xy + vec2(0.0, oneTap.y);\n    vec2 offset19 = shadowNDCPos.xy + vec2(oneTap.x, oneTap.y);\n    vec2 offset20 = shadowNDCPos.xy + vec2(twoTap.x, oneTap.y);\n    vec2 offset21 = shadowNDCPos.xy + vec2(-twoTap.x, twoTap.y);\n    vec2 offset22 = shadowNDCPos.xy + vec2(-oneTap.x, twoTap.y);\n    vec2 offset23 = shadowNDCPos.xy + vec2(0.0, twoTap.y);\n    vec2 offset24 = shadowNDCPos.xy + vec2(oneTap.x, twoTap.y);\n    vec2 offset25 = shadowNDCPos.xy + vec2(twoTap.x, twoTap.y);\n    float block1, block2, block3, block4, block5, block6, block7, block8, block9, block10, block11, block12, block13, block14, block15, block16, block17, block18, block19, block20, block21, block22, block23, block24, block25;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset1), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset2), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset3), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset4), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset5), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset6), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset7), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset8), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block9 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset9), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block10 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset10), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block11 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset11), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block12 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset12), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block13 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset13), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block14 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset14), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block15 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset15), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block16 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset16), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block17 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset17), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block18 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset18), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block19 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset19), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block20 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset20), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block21 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset21), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block22 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset22), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block23 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset23), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block24 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset24), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block25 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset25), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, offset1).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, offset2).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, offset3).x);\n      block4 = step(shadowNDCPos.z, texture2D(shadowMap, offset4).x);\n      block5 = step(shadowNDCPos.z, texture2D(shadowMap, offset5).x);\n      block6 = step(shadowNDCPos.z, texture2D(shadowMap, offset6).x);\n      block7 = step(shadowNDCPos.z, texture2D(shadowMap, offset7).x);\n      block8 = step(shadowNDCPos.z, texture2D(shadowMap, offset8).x);\n      block9 = step(shadowNDCPos.z, texture2D(shadowMap, offset9).x);\n      block10 = step(shadowNDCPos.z, texture2D(shadowMap, offset10).x);\n      block11 = step(shadowNDCPos.z, texture2D(shadowMap, offset11).x);\n      block12 = step(shadowNDCPos.z, texture2D(shadowMap, offset12).x);\n      block13 = step(shadowNDCPos.z, texture2D(shadowMap, offset13).x);\n      block14 = step(shadowNDCPos.z, texture2D(shadowMap, offset14).x);\n      block15 = step(shadowNDCPos.z, texture2D(shadowMap, offset15).x);\n      block16 = step(shadowNDCPos.z, texture2D(shadowMap, offset16).x);\n      block17 = step(shadowNDCPos.z, texture2D(shadowMap, offset17).x);\n      block18 = step(shadowNDCPos.z, texture2D(shadowMap, offset18).x);\n      block19 = step(shadowNDCPos.z, texture2D(shadowMap, offset19).x);\n      block20 = step(shadowNDCPos.z, texture2D(shadowMap, offset20).x);\n      block21 = step(shadowNDCPos.z, texture2D(shadowMap, offset21).x);\n      block22 = step(shadowNDCPos.z, texture2D(shadowMap, offset22).x);\n      block23 = step(shadowNDCPos.z, texture2D(shadowMap, offset23).x);\n      block24 = step(shadowNDCPos.z, texture2D(shadowMap, offset24).x);\n      block25 = step(shadowNDCPos.z, texture2D(shadowMap, offset25).x);\n    #endif\n    vec2 coef = fract(shadowNDCPos.xy * shadowMapResolution);\n    vec2 v1X1 = mix(vec2(block1, block6), vec2(block2, block7), coef.xx);\n    vec2 v1X2 = mix(vec2(block2, block7), vec2(block3, block8), coef.xx);\n    vec2 v1X3 = mix(vec2(block3, block8), vec2(block4, block9), coef.xx);\n    vec2 v1X4 = mix(vec2(block4, block9), vec2(block5, block10), coef.xx);\n    float v1 = mix(v1X1.x, v1X1.y, coef.y) + mix(v1X2.x, v1X2.y, coef.y) + mix(v1X3.x, v1X3.y, coef.y) + mix(v1X4.x, v1X4.y, coef.y);\n    vec2 v2X1 = mix(vec2(block6, block11), vec2(block7, block12), coef.xx);\n    vec2 v2X2 = mix(vec2(block7, block12), vec2(block8, block13), coef.xx);\n    vec2 v2X3 = mix(vec2(block8, block13), vec2(block9, block14), coef.xx);\n    vec2 v2X4 = mix(vec2(block9, block14), vec2(block10, block15), coef.xx);\n    float v2 = mix(v2X1.x, v2X1.y, coef.y) + mix(v2X2.x, v2X2.y, coef.y) + mix(v2X3.x, v2X3.y, coef.y) + mix(v2X4.x, v2X4.y, coef.y);\n    vec2 v3X1 = mix(vec2(block11, block16), vec2(block12, block17), coef.xx);\n    vec2 v3X2 = mix(vec2(block12, block17), vec2(block13, block18), coef.xx);\n    vec2 v3X3 = mix(vec2(block13, block18), vec2(block14, block19), coef.xx);\n    vec2 v3X4 = mix(vec2(block14, block19), vec2(block15, block20), coef.xx);\n    float v3 = mix(v3X1.x, v3X1.y, coef.y) + mix(v3X2.x, v3X2.y, coef.y) + mix(v3X3.x, v3X3.y, coef.y) + mix(v3X4.x, v3X4.y, coef.y);\n    vec2 v4X1 = mix(vec2(block16, block21), vec2(block17, block22), coef.xx);\n    vec2 v4X2 = mix(vec2(block17, block22), vec2(block18, block23), coef.xx);\n    vec2 v4X3 = mix(vec2(block18, block23), vec2(block19, block24), coef.xx);\n    vec2 v4X4 = mix(vec2(block19, block24), vec2(block20, block25), coef.xx);\n    float v4 = mix(v4X1.x, v4X1.y, coef.y) + mix(v4X2.x, v4X2.y, coef.y) + mix(v4X3.x, v4X3.y, coef.y) + mix(v4X4.x, v4X4.y, coef.y);\n    float fAvg = (v1 + v2 + v3 + v4) * 0.0625;\n    return fAvg;\n  }\n  bool GetShadowNDCPos(out vec3 shadowNDCPos, vec4 shadowPosWithDepthBias)\n  {\n  \tshadowNDCPos = shadowPosWithDepthBias.xyz / shadowPosWithDepthBias.w * 0.5 + 0.5;\n  \tif (shadowNDCPos.x < 0.0 || shadowNDCPos.x > 1.0 ||\n  \t\tshadowNDCPos.y < 0.0 || shadowNDCPos.y > 1.0 ||\n  \t\tshadowNDCPos.z < 0.0 || shadowNDCPos.z > 1.0) {\n  \t\treturn false;\n  \t}\n  \tshadowNDCPos.xy = cc_cameraPos.w == 1.0 ? vec2(shadowNDCPos.xy.x, 1.0 - shadowNDCPos.xy.y) : shadowNDCPos.xy;\n  \treturn true;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, vec3 matViewDir0, vec3 matViewDir1, vec3 matViewDir2, vec2 projScaleXY)\n  {\n    vec4 newShadowPos = shadowPos;\n    if (normalBias > EPSILON_LOWP)\n    {\n      vec3 viewNormal = vec3(dot(matViewDir0, worldNormal), dot(matViewDir1, worldNormal), dot(matViewDir2, worldNormal));\n      if (viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, mat4 matLightView, vec2 projScaleXY)\n  {\n  \tvec4 newShadowPos = shadowPos;\n  \tif (normalBias > EPSILON_LOWP)\n  \t{\n  \t\tvec4 viewNormal = matLightView * vec4(worldNormal, 0.0);\n  \t\tif (viewNormal.z < 0.1)\n  \t\t\tnewShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n  \t}\n  \treturn newShadowPos;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Orthgraphic(float NDCDepth, float projScaleZ, float projBiasZ)\n  {\n  \treturn (NDCDepth - projBiasZ) / projScaleZ;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Perspective(float NDCDepth, float homogenousDividW, float invProjScaleZ, float invProjBiasZ)\n  {\n  \treturn NDCDepth * invProjScaleZ + homogenousDividW * invProjBiasZ;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n  \tvec3 viewSpacePos;\n  \tviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n  \tviewSpacePos.z = GetViewSpaceDepthFromNDCDepth_Perspective(shadowPos.z, shadowPos.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n  \tviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n  \tvec4 clipSpacePos;\n  \tclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n  \tclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n  \t#if CC_SHADOWMAP_USE_LINEAR_DEPTH\n  \t\tclipSpacePos.z = GetLinearDepthFromViewSpace(viewSpacePos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n  \t\tclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n  \t#endif\n  \treturn clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias, float projScaleZ, float projBiasZ)\n  {\n  \tfloat coeffA = projScaleZ;\n  \tfloat coeffB = projBiasZ;\n  \tfloat viewSpacePos_z = GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowPos.z, projScaleZ, projBiasZ);\n  \tviewSpacePos_z += viewspaceDepthBias;\n  \tvec4 result = shadowPos;\n  \tresult.z = viewSpacePos_z * coeffA + coeffB;\n  \treturn result;\n  }\n  vec4 ApplyShadowDepthBias_PerspectiveLinearDepth(vec4 shadowPos, float viewspaceDepthBias, vec3 worldPos)\n  {\n    shadowPos.z = CCGetLinearDepth(worldPos, viewspaceDepthBias) * 2.0 - 1.0;\n    shadowPos.z *= shadowPos.w;\n    return shadowPos;\n  }\n  float CCGetDirLightShadowFactorHard (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCSpotShadowFactorBase(out vec4 shadowNDCPosWithBias, vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    vec4 pos = vec4(1.0);\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      pos = ApplyShadowDepthBias_PerspectiveLinearDepth(shadowPos, shadowBias.x, worldPos);\n    #else\n      pos = ApplyShadowDepthBias_Perspective(shadowPos, shadowBias.x);\n    #endif\n    float realtimeShadow = 1.0;\n    if (pcf > 2.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft5X(pos, worldPos);\n    }else if (pcf > 1.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft3X(pos, worldPos);\n    }else if (pcf > 0.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft(pos, worldPos);\n    }else {\n      realtimeShadow = CCGetSpotLightShadowFactorHard(pos, worldPos);\n    }\n    shadowNDCPosWithBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  float CCShadowFactorBase(out vec4 shadowNDCPosWithBias, vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y, cc_matLightView, cc_shadowProjInfo.xy);\n    pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n    float realtimeShadow = 1.0;\n    #if CC_DIR_SHADOW_PCF_TYPE == 3\n      realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 2\n      realtimeShadow =  CCGetDirLightShadowFactorSoft3X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 1\n      realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 0\n      realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n    #endif\n    shadowNDCPosWithBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n    bool CCGetCSMLevelWithTransition(out float ratio, vec3 clipPos) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      highp float maxRange = 1.0 - cc_csmSplitsInfo.x - layerThreshold;\n      highp float minRange = cc_csmSplitsInfo.x - layerThreshold;\n      if (clipPos.x <= minRange || clipPos.x >= maxRange ||\n          clipPos.y <= minRange || clipPos.y >= maxRange) {\n        if (clipPos.x >= layerThreshold && clipPos.x <= cc_csmSplitsInfo.x) {\n          ratio = (clipPos.x - layerThreshold) / (cc_csmSplitsInfo.x - layerThreshold);\n        }\n        if (clipPos.x >= maxRange && clipPos.x <= 1.0 - layerThreshold) {\n          ratio = (clipPos.x - maxRange) / (cc_csmSplitsInfo.x - layerThreshold);\n        }\n        if (clipPos.y >= 0.0 && clipPos.y <= cc_csmSplitsInfo.x) {\n          ratio = min((clipPos.y - layerThreshold) / (cc_csmSplitsInfo.x - layerThreshold), 1.0);\n        }\n        if (clipPos.y >= maxRange && clipPos.y <= 1.0 - layerThreshold) {\n          ratio = (clipPos.y - maxRange) / (cc_csmSplitsInfo.x - layerThreshold);\n        }\n        return true;\n      }\n      return false;\n    }\n    int CCGetCSMLevel(out bool hasNextTransition, out bool transitionArea, out float transitionRatio, out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos, int nextLayer)\n    {\n      int layer = -1;\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= (0.0 + layerThreshold) && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= (0.0 + layerThreshold) && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0) {\n          #if CC_CASCADED_LAYERS_TRANSITION\n            if (layer < 0 || (nextLayer >= 0 && i == nextLayer))\n          #else\n            if (layer < 0)\n          #endif\n          {\n            #if CC_CASCADED_LAYERS_TRANSITION\n              if (nextLayer < 0) {\n                transitionArea = CCGetCSMLevelWithTransition(transitionRatio, clipPos);\n              }\n            #endif\n            csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n            csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n            shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n            shadowProjInfo = cc_csmProjInfo[i];\n            shadowViewDir0 = cc_csmViewDir0[i].xyz;\n            shadowViewDir1 = cc_csmViewDir1[i].xyz;\n            shadowViewDir2 = cc_csmViewDir2[i].xyz;\n            layer = i;\n            #if CC_CASCADED_LAYERS_TRANSITION\n              hasNextTransition = true;\n            #endif\n          }\n        }\n      }\n      return layer;\n    }\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      bool hasNextTransition = false;\n      bool transitionArea = false;\n      float transitionRatio = 0.0;\n      int nextLayer = -1;\n      return CCGetCSMLevel(hasNextTransition, transitionArea, transitionRatio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos, nextLayer);\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmNDCPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias)\n    {\n      bool hasNext = false;\n      bool transitionArea = false;\n      float ratio = 0.0;\n      csmPos = vec4(1.0);\n      vec4 shadowProjDepthInfo, shadowProjInfo;\n      vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n      int level = -1;\n      #if CC_CASCADED_LAYERS_TRANSITION\n        level = CCGetCSMLevel(hasNext, transitionArea, ratio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos, -1);\n      #else\n        level = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #endif\n      if (level < 0) { return 1.0; }\n      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y, shadowViewDir0, shadowViewDir1, shadowViewDir2, shadowProjInfo.xy);\n      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n      csmNDCPosWithBias = pos;\n      float realtimeShadow = 1.0;\n      #if CC_DIR_SHADOW_PCF_TYPE == 3\n        realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 2\n        realtimeShadow = CCGetDirLightShadowFactorSoft3X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 1\n        realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 0\n        realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n      #endif\n      #if CC_CASCADED_LAYERS_TRANSITION\n        vec4 nextCSMPos = vec4(1.0);\n        vec4 nextShadowProjDepthInfo, nextShadowProjInfo;\n        vec3 nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2;\n        float nextRealtimeShadow = 1.0;\n        CCGetCSMLevel(hasNext, transitionArea, ratio, nextCSMPos, nextShadowProjDepthInfo, nextShadowProjInfo, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, worldPos, level + 1);\n        if (hasNext && transitionArea) {\n          vec4 nexPos = ApplyShadowDepthBias_FaceNormal(nextCSMPos, N, shadowBias.y, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, nextShadowProjInfo.xy);\n          nexPos = ApplyShadowDepthBias_Orthographic(nexPos, shadowBias.x, nextShadowProjDepthInfo.x, nextShadowProjDepthInfo.y);\n          #if CC_DIR_SHADOW_PCF_TYPE == 3\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft5X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 2\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft3X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 1\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 0\n            nextRealtimeShadow = CCGetDirLightShadowFactorHard(nexPos);\n          #endif\n          return mix(mix(nextRealtimeShadow, realtimeShadow, ratio), 1.0, cc_shadowNFLSInfo.w);\n        }\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #else\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #endif\n    }\n  #else\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      return -1;\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmNDCPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias) {\n      csmPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n      return CCShadowFactorBase(csmNDCPosWithBias, csmPos, N, shadowBias);\n    }\n  #endif\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias) {\n    vec4 shadowNDCPosWithBias;\n    return CCShadowFactorBase(shadowNDCPosWithBias, shadowPos, N, shadowBias);\n  }\n  float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias) {\n    vec4 csmPos, csmNDCPosWithBias;\n    return CCCSMFactorBase(csmPos, csmNDCPosWithBias, worldPos, N, shadowBias);\n  }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    vec4 shadowNDCPosWithBias;\n    return CCSpotShadowFactorBase(shadowNDCPosWithBias, shadowPos, worldPos, shadowBias);\n  }\n#endif\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n\tcolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  vec3 SHEvaluate(vec3 normal)\n  {\n  #if USE_INSTANCING\n      vec3 result;\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(v_sh_linear_const_r, normal4);\n      result.g = dot(v_sh_linear_const_g, normal4);\n      result.b = dot(v_sh_linear_const_b, normal4);\n      return result;\n  #else\n      vec3 result;\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(cc_sh_linear_const_r, normal4);\n      result.g = dot(cc_sh_linear_const_g, normal4);\n      result.b = dot(cc_sh_linear_const_b, normal4);\n      vec4 n14 = normal.xyzz * normal.yzzx;\n      float n5 = normal.x * normal.x - normal.y * normal.y;\n      result.r += dot(cc_sh_quadratic_r, n14);\n      result.g += dot(cc_sh_quadratic_g, n14);\n      result.b += dot(cc_sh_quadratic_b, n14);\n      result += (cc_sh_quadratic_a.rgb * n5);\n      return result;\n  #endif\n  }\n  #endif\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n  void SampleAndDecodeLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  #if CC_LIGHT_MAP_VERSION > 2\n  #elif CC_LIGHT_MAP_VERSION > 1\n  \tluv.x *= 0.5;\n  \tvec4 dataLow = texture2D(lightingMap, luv);\n  \tvec4 dataHigh = texture2D(lightingMap, luv + vec2(0.5, 0.0));\n  \tlightmapColor.xyz = dataLow + dataHigh * 0.00392156862745098;\n      lightmapColor.rgb *= lum;\n  \tdirShadow = dataLow.a;\n  \tao = dataHigh.a;\n  #else\n      vec4 lightmap = texture2D(lightingMap, luv);\n      lightmapColor = lightmap.rgb * lum;\n  \tdirShadow = lightmap.a;\n  \tao = 1.0;\n  #endif\n  }\n  void GetLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  \tvec4 lightmap;\n  \tvec2 occlusion;\n  \tSampleAndDecodeLightMapColor(lightmapColor, dirShadow, ao, lightingMap, luv, lum, worldNormal);\n  #if CC_USE_HDR\n      lightmapColor.rgb *= cc_exposure.w * cc_exposure.x;\n  #endif\n  }\n#endif\n    uniform vec4 diffuseColor;\n    uniform vec4 specularColor;\n    uniform vec4 emissive;\n    uniform float emissiveScale;\n    uniform float alphaThreshold;\n    uniform float shininessExponent;\n    uniform float glossiness;\n    uniform float metallic;\n    uniform float normalScale;\n    uniform float transparencyFactor;\n    uniform float diffuseFactor;\n    uniform float specularFactor;\n#define DCC_APP_OTHERS 0\n#define DCC_APP_MAX 1\n#define DCC_APP_BLENDER 2\n#define DCC_APP_CINEMA4D 3\n#define DCC_APP_GLTF 4\n#define DCC_APP_MAYA 5\n#if USE_SHININESS_MAP\n  uniform sampler2D shininessExponentMap;\n#endif\n#if USE_SPECULAR_GLOSSINESS_MAP\n  uniform sampler2D specularGlossinessMap;\n#endif\n#if USE_SPECULAR_MAP\n  uniform sampler2D specularMap;\n#endif\n #if USE_METALLIC_MAP\n  uniform sampler2D metallicMap;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_EMISSIVESCALE_MAP\n  uniform sampler2D emissiveScaleMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\nfloat discolor(vec3 srcColor)\n{\n  return dot(GRAY_VECTOR, srcColor);\n}\nfloat convertShininessExponent(float shininessExp)\n{\n  #if DCC_APP_NAME == DCC_APP_BLENDER\n    float glossiness = clamp(sqrt(shininessExp) * 0.1, 0.0, 0.95);\n  #elif DCC_APP_NAME == DCC_APP_MAX || DCC_APP_NAME == DCC_APP_MAYA\n    float l2 = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n    float glossiness = pow(l2, 0.5);\n  #else\n    float glossiness = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n  #endif\n    return glossiness;\n}\nfloat getSpecularIntensityFromRoughness(float roughness)\n{\n  #if DCC_APP_NAME == DCC_APP_BLENDER\n    float specularIntensityMultiplier = mix(1.0, 5.0, roughness);\n  #elif DCC_APP_NAME == DCC_APP_CINEMA4D\n    float specularIntensityMultiplier = mix(1.0, 50.0, roughness);\n  #elif DCC_APP_NAME == DCC_APP_MAX || DCC_APP_NAME == DCC_APP_MAYA\n    float specularIntensityMultiplier = mix(1.0, 20.0, roughness);\n  #else\n    float specularIntensityMultiplier = 1.0;\n  #endif\n    return specularIntensityMultiplier;\n}\nvec4 getSpecularColorAndFactor()\n{\n  vec3 inSpecular = specularColor.rgb * specularFactor;\n  float inFactor = 1.0;\n  #if USE_SPECULAR_GLOSSINESS_MAP\n    inSpecular = SRGBToLinear(texture2D(specularGlossinessMap, TEXTURE_UV).rgb);\n  #endif\n  #if USE_SPECULAR_MAP\n      vec4 specularTex = texture2D(specularMap, TEXTURE_UV);\n      specularTex.rgb = SRGBToLinear(specularTex.rgb);\n      inSpecular = specularTex.rgb;\n  #endif\n  return vec4(inSpecular, inFactor);\n}\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n  vec3 normal = FSInput_worldNormal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    normal = CalculateNormalFromTangentSpace(nmmp, normalScale, normal.xyz, FSInput_worldTangent, FSInput_mirrorNormal);\n  #endif\n  return normalize(normal);\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n  vec3 emissiveColor = emissive.rgb;\n  #if USE_EMISSIVE_MAP\n      emissiveColor.rgb = SRGBToLinear(texture2D(emissiveMap, TEXTURE_UV).rgb);\n  #endif\n  #if USE_EMISSIVESCALE_MAP\n      vec4 emissiveScaleColor = texture2D(emissiveScaleMap, TEXTURE_UV);\n      emissiveScaleColor.rgb = SRGBToLinear(emissiveScaleColor.rgb);\n      emissiveColor.rgb *= emissiveScaleColor.rgb;\n  #else\n      emissiveColor.rgb *= emissiveScale;\n  #endif\n  return emissiveColor;\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nstruct SurfacesMaterialData\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPos, worldPos_fract_part;\n  #else\n  vec3 worldPos;\n  #endif\n  vec4 baseColor;\n  vec3 worldNormal;\n  vec3 emissive;\n  float specularIntensity;\n  float roughness;\n  float metallic;\n  float ao;\n  vec3 worldTangent, worldBinormal;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMITTENCE\n  vec4 transmittenceParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRT\n  float roughnessTRT;\n#endif\n};\nvoid SurfacesFragmentModifySharedData(inout SurfacesMaterialData surfaceData)\n{\n    vec4 baseColor = vec4(1.0);\n    #if USE_VERTEX_COLOR\n      baseColor.rgb *= SRGBToLinear(FSInput_vertexColor.rgb);\n      baseColor.a *= FSInput_vertexColor.a;\n    #endif\n    #if USE_ALBEDO_MAP\n      vec4 texColor = texture2D(albedoMap, TEXTURE_UV);\n      texColor.rgb = SRGBToLinear(texColor.rgb);\n      texColor.a *= transparencyFactor;\n      baseColor *= texColor;\n    #else\n      baseColor *= diffuseColor;\n    #endif\n    baseColor.rgb *= diffuseFactor;\n    #if USE_TRANSPARENCY_MAP\n      baseColor.a = texture2D(transparencyMap, TEXTURE_UV).TRANSPARENCY_MAP_CHANNEL;\n      #if DCC_APP_NAME == DCC_APP_MAYA\n        baseColor.a = 1.0 - baseColor.a;\n      #endif\n    #endif\n    #if USE_ALPHA_TEST\n      if (baseColor.a < alphaThreshold) discard;\n    #endif\n    vec4 specularColorAndFactor = getSpecularColorAndFactor();\n    float inGlossiness = 0.0, inSpecularIntensity = 1.0;\n    #if HAS_EXPORTED_GLOSSINESS\n      #if USE_SPECULAR_GLOSSINESS_MAP\n        inGlossiness = 1.0 - texture2D(specularGlossinessMap, TEXTURE_UV).a;\n      #else\n        inGlossiness = glossiness;\n      #endif\n    #else\n      #if USE_SHININESS_MAP\n        #if GLOSSINESS_MAP_USE_SINGLE_CHANNEL\n          inGlossiness = 1.0 - texture2D(shininessExponentMap, TEXTURE_UV).GLOSSINESS_MAP_CHANNEL;\n        #else\n          inGlossiness = 1.0 - discolor(texture2D(shininessExponentMap, TEXTURE_UV).rgb);\n        #endif\n      #else\n        inGlossiness = convertShininessExponent(shininessExponent);\n      #endif\n      inSpecularIntensity *= getSpecularIntensityFromRoughness(1.0 - inGlossiness);\n    #endif\n    float inMetallic = 0.0;\n    vec3 albedo = baseColor.rgb;\n    #if HAS_EXPORTED_METALLIC\n      inMetallic = metallic;\n      float spec = specularFactor;\n      #if USE_SPECULAR_MAP\n        spec = dot(GRAY_VECTOR, texture2D(specularMap, TEXTURE_UV).rgb);\n      #endif\n      inSpecularIntensity *= spec * 0.5;\n    #else\n      GetMetallicAlbedoFromDiffuseSpecularWithoutColor(inMetallic, albedo.rgb, baseColor.rgb, specularColorAndFactor.rgb, 0.04);\n      inSpecularIntensity *= inMetallic;\n    #endif\n    baseColor.rgb = albedo;\n    surfaceData.baseColor = baseColor;\n    surfaceData.specularIntensity = inSpecularIntensity * 0.5;\n    surfaceData.roughness = 1.0 - inGlossiness;\n    surfaceData.metallic = inMetallic;\n    surfaceData.ao = 1.0;\n    #if USE_OCCLUSION_MAP\n      surfaceData.ao = texture2D(occlusionMap, OCCLUSION_UV).OCCLUSION_CHANNEL;\n    #endif\n}\nstruct LightingIntermediateData\n{\n  vec3 N, H, L, V;\n  float distToLight, distToLightSqr;\n  float distToCamera, distToCameraSqr;\n  float NoL, NoV, NoH;\n  float NoLSat, NoVSat, NoHSat;\n  float NoVAbsSat;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPosition, worldPosition_fract_part;\n  #else\n  vec3 worldPosition;\n  #endif\n  vec3 T, B;\n  float specularParam;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMITTENCE\n  vec4 shadowPosAndDepth;\n  vec4 transmittenceParams;\n#endif\n};\nvoid CCSurfacesLightingGetIntermediateData_PerPixel(inout LightingIntermediateData data, vec3 worldNormal, vec3 worldPos, vec3 worldTangent, vec3 worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n    , float anisotropyShape\n#endif\n)\n{\n  data.N = worldNormal;\n  data.V = cc_cameraPos.xyz - worldPos;\n  data.distToCameraSqr = dot(data.V, data.V);\n  data.distToCamera = sqrt(data.distToCameraSqr);\n  data.V /= data.distToCamera;\n  data.NoV = dot(data.N, data.V);\n  data.NoVSat = max(data.NoV, 0.0);\n  data.NoVAbsSat = max(abs(data.NoV), 0.0);\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(data.worldPosition, data.worldPosition_fract_part, worldPos);\n  #else\n  data.worldPosition = worldPos;\n  #endif\n  data.T = worldTangent;\n  data.B = worldBinormal;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  data.anisotropyShape = anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMITTENCE\n  data.shadowPosAndDepth = vec4(0.0, 0.0, 999999.0, 999999.0);\n#endif\n}\nvoid CCSurfacesLightingGetIntermediateData_PerLight(inout LightingIntermediateData data, vec3 lightDirWithDist)\n{\n  data.L = lightDirWithDist;\n  data.distToLightSqr = dot(data.L, data.L);\n  data.distToLight = sqrt(data.distToLightSqr);\n  data.L /= data.distToLight;\n  data.H = normalize(data.L + data.V);\n  data.NoL = dot(data.N, data.L);\n  data.NoH = dot(data.N, data.H);\n  data.NoLSat = max(data.NoL, 0.0);\n  data.NoHSat = max(data.NoH, 0.0);\n}\nstruct LightingResult\n{\n  vec3 diffuseColorWithLighting, specularColorWithLighting;\n  vec3 directDiffuse, directSpecular;\n  vec3 environmentDiffuse, environmentSpecular;\n  float shadow, ao;\n  vec3 lightmapColor;\n  vec3 emissive;\n#if CC_SURFACES_LIGHTING_USE_FRESNEL\n  float fresnel;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  vec3 directTransmitSpecular;\n  vec3 environmentTransmitSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMITTENCE\n  vec3 transmittence;\n#endif\n#if CC_SURFACES_LIGHTING_TRT\n  vec3 directTRT, environmentTRT;\n#endif\n};\nfloat D_GGX(float roughness, float NoH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float d = (NoH * m2 - NoH) * NoH + 1.0;\n    return m2 / max(EPSILON, d * d);\n}\nfloat D_GGXMobile(float roughness, float NoH) {\n  float OneMinusNoHSqr = 1.0 - NoH * NoH;\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nvoid GetAnisotropicRoughness(float roughness, float anisotropyShape, out float roughnessX, out float roughnessY)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    float r1 = roughness, r2 = roughness;\n    float lerpedRoughness = mix(1.0, 10.0, anisotropyShape);\n    r2 *= shapeSign < 0.0 ? lerpedRoughness : 1.0;\n    r1 *= shapeSign > 0.0 ? lerpedRoughness : 1.0;\n    roughnessX = saturate(r1);\n    roughnessY = saturate(r2);\n}\nfloat D_GGXAniso(float RoughnessX, float RoughnessY, float NoH, vec3 H, vec3 X, vec3 Y)\n{\n    float mx = max(EPSILON_LOWP, RoughnessX * RoughnessX);\n    float my = max(EPSILON_LOWP, RoughnessY * RoughnessY);\n    float XoH = dot(X, H);\n    float YoH = dot(Y, H);\n    float d = XoH * XoH / (mx * mx) + YoH * YoH / (my * my) + NoH * NoH;\n    return 1.0 / max(EPSILON_LOWP, mx * my * d * d);\n}\nvec3 GetAnisotropicReflect(float roughness, float anisotropyShape, vec3 V, vec3 N, vec3 X, vec3 Y)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    anisotropyShape = min(anisotropyShape, 0.4);\n    anisotropyShape *= smoothstep(0.0, 0.03, roughness);\n    vec3 reflectTarget = shapeSign < 0.0 ? mix(N, -Y, anisotropyShape) :\n                         shapeSign > 0.0 ? mix(N, -X, anisotropyShape) : N;\n    return reflect(-V, reflectTarget);\n}\nvec3 IntegratedGFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#define DiffuseCoefficient_EnergyConservation INV_PI\nfloat CalculateFresnelCoefficient(float ior, float NoVSat)\n{\n\tfloat g, c, n, prev, next;\n\tn = ior;\n\tc = ior * NoVSat;\n\tg = sqrt(1.0 + c * c - c);\n\tprev = (g - c) / (g + c);\n\tnext = (c * (g+c) - n*n) / (c * (g-c) + n*n);\n\tprev *= prev;\n\tnext *= next;\n\treturn 0.5 * prev * (1.0 + next);\n}\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\nfloat CalculateDistanceAttenuation(float distToLightSqr, float lightRadius, float lightRange)\n{\n  float litRadiusSqr = lightRadius * lightRadius;\n  float attRadiusSqrInv = 1.0 / max(lightRange, 0.01);\n  attRadiusSqrInv *= attRadiusSqrInv;\n  float edgeAttenuation = litRadiusSqr / max(litRadiusSqr, distToLightSqr);\n  return GetDistAtt(distToLightSqr, attRadiusSqrInv) * edgeAttenuation;\n}\nfloat CalculateAngleAttenuation(vec3 spotLightDir, vec3 L, float cosAngleOuter)\n{\n  float cosInner = max(dot(spotLightDir, L), 0.01);\n  float litAngleScale = 1.0 / max(0.001, cosInner - cosAngleOuter);\n  float litAngleOffset = -cosAngleOuter * litAngleScale;\n  return GetAngleAtt(L, spotLightDir, litAngleScale, litAngleOffset);\n}\nvec3 CalculateRefractDirection(vec3 N, vec3 V, float NoV, float ior)\n{\n  float NoVAbs = abs(NoV);\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  NoV *= sideSign;\n  float sinB = sqrt(1.0 - NoVAbs*NoVAbs) / ior;\n  vec3 X = normalize(-V + N * NoVAbs);\n  vec3 R = -N + X * sinB;\n  return R;\n}\nvec3 CalculateReflectDirection(vec3 N, vec3 V, float NoV)\n{\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  return reflect(-V, N);\n}\nvoid LightingCalculateDirect(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    lightingDiffuse = irradiance * DiffuseCoefficient_EnergyConservation;\n    float roughness = lightingData.specularParam;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n    float rT, rB;\n    GetAnisotropicRoughness(roughness, lightingData.anisotropyShape, rT, rB);\n    float calcSpec = D_GGXAniso(rT, rB, lightingData.NoHSat, lightingData.H, lightingData.T, lightingData.B);\n#else\n  #if CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n    float calcSpec = (roughness * 0.25 + 0.25) * D_GGXMobile(roughness, lightingData.NoHSat);\n  #else\n    float calcSpec = D_GGX(roughness, lightingData.NoHSat);\n  #endif\n#endif\n    lightingSpecular = irradiance * calcSpec;\n}\n#if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  vec3 EnvAnisotropicReflection(samplerCube tex, vec3 R, float roughness, float mipCount, float anisotropyShape, vec3 V, vec3 N, vec3 T, vec3 B) {\n      R = normalize(R);\n      float integratedBRDF = 0.0;\n      vec3 envSpec = vec3(0.0);\n      const int SAMPLE_STEP_COUNT = CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT;\n      float sampleAngleRange = PI * abs(anisotropyShape);\n      vec3 anisoDirection = anisotropyShape < 0.0 ? T : B;\n      vec3 ROnNormalPlane = normalize(R - anisoDirection * dot(R, anisoDirection));\n      vec3 stepOffset = normalize(ROnNormalPlane - N) * (sampleAngleRange / float(SAMPLE_STEP_COUNT * 2));\n      for (int i = -SAMPLE_STEP_COUNT; i <= SAMPLE_STEP_COUNT; ++i)\n      {\n          float rT, rB;\n          GetAnisotropicRoughness(roughness, anisotropyShape, rT, rB);\n          #if CC_IBL_CONVOLUTED\n            float coef = abs(float(i)) / float(SAMPLE_STEP_COUNT) * float(SAMPLE_STEP_COUNT);\n          #else\n            float coef = pow(abs(float(i)) / float(SAMPLE_STEP_COUNT), 1.3) * float(SAMPLE_STEP_COUNT);\n          #endif\n          vec3 H = normalize(N + stepOffset * sign(float(i)) * coef);\n          vec3 L = reflect(-V, H);\n          float NoHSat = saturate(dot(N, H));\n          float calcSpec = D_GGXAniso(rT, rB, NoHSat, H, T, B);\n          envSpec += calcSpec * EnvReflection(tex, L, roughness, mipCount);\n          integratedBRDF += calcSpec;\n      }\n      envSpec /= integratedBRDF;\n      return envSpec;\n  }\n#endif\nvec3 SampleEnvironmentSpecular(samplerCube tex, in LightingIntermediateData lightingData, float mipCount)\n{\n    vec3 envSpec = vec3(0.0);\n    float roughness = lightingData.specularParam;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && !CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      vec3 R = GetAnisotropicReflect(roughness, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      vec3 R = CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV);\n    #endif\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      envSpec = EnvAnisotropicReflection(tex, R, roughness, mipCount, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      #if CC_SURFACES_USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        envSpec = EnvReflectionWithMipFiltering(normalize(R), roughness, mipCount, 0.6);\n      #else\n        envSpec = EnvReflection(tex, R, roughness, mipCount);\n      #endif\n    #endif\n    return envSpec;\n}\nvec3 CalculateEnvironmentDiffuse(in LightingIntermediateData lightingData, float lightIntensity)\n{\n  float fAmb = 0.5 - lightingData.N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP && !CC_USE_LIGHT_PROBE\n      vec4 diffuseMap = textureCube(cc_diffuseMap, lightingData.N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n  #endif\n  ambDiff.rgb *= lightIntensity;\n  #if CC_USE_LIGHT_PROBE\n    ambDiff.rgb += SHEvaluate(lightingData.N);\n  #endif\n  return ambDiff.rgb;\n}\nvec3 CalculateEnvironmentSpecular(in LightingIntermediateData lightingData, float lightIntensity)\n{\n  vec3 envSpec = vec3(0.0);\n#if CC_USE_REFLECTION_PROBE\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n    envSpec = SampleEnvironmentSpecular(cc_reflectionProbeCubemap, lightingData, cc_ambientGround.w);\n  #elif CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_PLANAR\n    vec3 R = normalize(CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV));\n    vec3 worldPos;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    worldPos = unpackHighpData(lightingData.worldPosition, lightingData.worldPosition_fract_part);\n    #else\n    worldPos = lightingData.worldPosition;\n    #endif\n    vec3 bumpedWorldPos = worldPos;\n    vec2 screenUV = GetPlanarReflectScreenUV(bumpedWorldPos, cc_matViewProj, cc_cameraPos.w, lightingData.V, R);\n    vec4 rgbe = fragTextureLod(cc_reflectionProbePlanarMap, screenUV, cc_ambientGround.w);\n    envSpec = unpackRGBE(rgbe);\n  #endif\n#elif CC_USE_IBL\n    envSpec = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w);\n#endif\n  return envSpec * lightIntensity;\n}\nbool CCSurfacesLightingEnableShadow(in float NoL)\n{\n  return NoL > 0.0;\n}\nfloat CCSurfacesLightingCalculateDistanceAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle)\n{\n  return CalculateDistanceAttenuation(lightingData.distToLightSqr, lightSizeRangeAngle.x, lightSizeRangeAngle.y);\n}\nfloat CCSurfacesLightingCalculateAngleAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle, in vec3 spotLightDir)\n{\n  return CalculateAngleAttenuation(spotLightDir, lightingData.L, lightSizeRangeAngle.z);\n}\nvoid CCSurfacesLightingCalculateDirect(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n  LightingCalculateDirect(lightingDiffuse, lightingSpecular, lightingData, lightSourceColorAndIntensity);\n}\nvoid CCSurfacesLightingCalculateEnvironment(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, float lightIntensity)\n{\n  lightingDiffuse = CalculateEnvironmentDiffuse(lightingData, lightIntensity);\n  lightingSpecular = CalculateEnvironmentSpecular(lightingData, lightIntensity);\n}\n#if CC_SURFACES_LIGHTING_USE_FRESNEL\n  float CCSurfaceLightingCalculateFresnel(in LightingIntermediateData lightingData)\n  {\n    return CalculateFresnelCoefficient(lightingData.ior, abs(lightingData.NoV));\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  void CCSurfacesLightingCalculateDirectTransmitSpecular(out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    float roughness = lightingData.specularParam;\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    vec3 R = CalculateRefractDirection(lightingData.N, lightingData.V, lightingData.NoV, lightingData.ior);\n    float RoL = dot(lightingData.L, R);\n    float calcSpec = D_GGX(roughness, saturate(RoL));\n    lightingSpecular = irradiance * calcSpec;\n  }\n  void CCSurfacesLightingCalculateEnvironmentTransmitSpecular(out vec3 lightingSpecular, in LightingIntermediateData lightingData, float lightIntensity)\n  {\n    vec3 envSpec = vec3(0.0);\n    vec3 R = CalculateRefractDirection(lightingData.N, lightingData.V, lightingData.NoV, lightingData.ior);\n    float roughness = lightingData.specularParam;\n  #if USE_REFLECTION_PROBE\n    #if USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n      envSpec = EnvReflection(cc_reflectionProbeCubemap, R, roughness, cc_ambientGround.w);\n    #endif\n  #endif\n  #if CC_USE_IBL && USE_REFLECTION_PROBE != REFLECTION_PROBE_TYPE_CUBE\n    envSpec = EnvReflection(cc_environment, R, roughness, cc_ambientGround.w);\n  #endif\n    lightingSpecular = envSpec * lightIntensity;\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMITTENCE\n  vec3 CCSurfacesLightingCalculateDirectTransmittence(in LightingResult lightingResult, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    vec3 backIrradiance = vec3(saturate(-lightingData.NoL)) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    vec3 transmitDiffuse = backIrradiance * DiffuseCoefficient_EnergyConservation;\n    lightingData.transmittenceParams;\n    return vec3(0.0);\n  }\n  vec3 CCSurfacesLightingCalculateEnvironmentTransmittence(in LightingResult lightingResult, in LightingIntermediateData lightingData, float lightIntensity)\n  {\n    lightingData.N *= -1.0;\n    vec3 backIrradiance = CalculateEnvironmentDiffuse(lightingData, lightIntensity);\n    lightingData.transmittenceParams;\n    return vec3(0.0);\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRT\n  #ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_SPECULAR_COLOR\n    vec3 SurfacesLightingGetTRTSpecularColor(float specBRDF, bool isSaturated)\n    {\n      return vec3(specBRDF);\n    }\n  #endif\n  void CCSurfacesLightingCalculateDirectTRT(out vec3 TRTColor, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    vec3 unused;\n    CCSurfacesLightingCalculateDirect(unused, TRTColor, lightingData, vec4(1.0));\n    vec3 Color = SurfacesLightingGetTRTSpecularColor(TRTColor.x, true);\n    TRTColor *= Color * lightSourceColorAndIntensity.w;\n  }\n  void CCSurfacesLightingCalculateEnvironmentTRT(out vec3 TRTColor, in LightingIntermediateData lightingData, float lightIntensity)\n  {\n    vec3 unused;\n    TRTColor = CalculateEnvironmentSpecular(lightingData, 1.0);\n    float brdf = length(TRTColor);\n    vec3 Color = SurfacesLightingGetTRTSpecularColor(brdf, false);\n    TRTColor *= Color * lightIntensity;\n  }\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\nvec4 SurfacesFragmentModifyBaseColorAndTransparency()\n{\n    return FSInput_vertexColor;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n    return normalize(FSInput_worldNormal);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_TANGENT_AND_BINORMAL\nvoid SurfacesFragmentModifyWorldTangentAndBinormal(inout vec3 worldTangent, inout vec3 worldBinormal, vec3 worldNormal)\n{\n    vec3 tangent = FSInput_worldTangent;\n#if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 binormal = normalize(CalculateBinormal(worldNormal.xyz, tangent, FSInput_mirrorNormal));\n    tangent = normalize(cross(binormal, worldNormal));\n#else\n    vec3 binormal = vec3(0.0, 0.0, 0.0);\n#endif\n    worldTangent = tangent;\n    worldBinormal = binormal;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_IOR\nfloat SurfacesFragmentModifyIOR()\n{\n    return 1.0;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\nvec4 SurfacesFragmentModifyAnisotropyParams(out float isRotation)\n{\n    isRotation = 1.0;\n    return vec4(1.0, 0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvec4 SurfacesFragmentModifyPBRParams()\n{\n    return vec4(1.0, 0.5, 0.0, 0.5);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMITTENCE_PARAMS\nvec4 SurfacesFragmentModifytransmittenceParamss()\n{\n    return vec4(1.0, 0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_PARAMS\nvec4 SurfacesFragmentModifyTRTParams()\n{\n    return vec4(0.5, 0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nvoid SurfacesFragmentModifySharedData(inout SurfacesMaterialData surfaceData)\n{\n}\n#endif\nvoid CCSurfacesFragmentGetMaterialData(inout SurfacesMaterialData surfaceData)\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part, FSInput_worldPos);\n  #else\n  surfaceData.worldPos = FSInput_worldPos;\n  #endif\n  surfaceData.baseColor = SurfacesFragmentModifyBaseColorAndTransparency();\n  surfaceData.worldNormal = SurfacesFragmentModifyWorldNormal();\n  SurfacesFragmentModifyWorldTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal);\n  surfaceData.ior = SurfacesFragmentModifyIOR();\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float isRotation;\n  vec4 anisotropyParams = SurfacesFragmentModifyAnisotropyParams(isRotation);\n  surfaceData.anisotropyShape = anisotropyParams.x;\n  if (isRotation > 0.0) {\n    RotateTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal, anisotropyParams.y);\n  } else {\n    vec3 anisoDirTS = anisotropyParams.yzw;\n    vec3 tangentWS = anisoDirTS.x * surfaceData.worldTangent + anisoDirTS.y * surfaceData.worldBinormal + anisoDirTS.z * surfaceData.worldNormal;\n    surfaceData.worldTangent = normalize(tangentWS);\n    surfaceData.worldBinormal = cross(surfaceData.worldNormal, tangentWS);\n  }\n#endif\n  surfaceData.emissive = SurfacesFragmentModifyEmissive();\n  vec4 pbr = SurfacesFragmentModifyPBRParams();\n  surfaceData.ao = pbr.x;\n  surfaceData.roughness = pbr.y;\n  surfaceData.metallic = pbr.z;\n  surfaceData.specularIntensity = pbr.w;\n#if CC_SURFACES_LIGHTING_TRANSMITTENCE\n  surfaceData.transmittenceParams =SurfacesFragmentModifytransmittenceParamss();\n#endif\n#if CC_SURFACES_LIGHTING_TRT\n  vec4 trt = SurfacesFragmentModifyTRTParams();\n  surfaceData.roughnessTRT = trt.x;\n#endif\n  SurfacesFragmentModifySharedData(surfaceData);\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP) {\n      surfaceData.worldNormal = FSInput_worldNormal;\n      surfaceData.worldTangent = FSInput_worldTangent;\n  }\n#endif\n#if CC_USE_DEBUG_VIEW\n  if (!IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO)\n      surfaceData.baseColor.rgb = vec3(1.0);\n#endif\n}\nvec3 CCSurfacesGetDiffuseColor(in SurfacesMaterialData surfaceData)\n{\n  return surfaceData.baseColor.rgb * (1.0 - surfaceData.metallic);\n}\nvec3 CCSurfacesGetSpecularColor(in SurfacesMaterialData surfaceData)\n{\n  float F0 = surfaceData.specularIntensity * 0.08;\n  return mix(vec3(F0), surfaceData.baseColor.rgb, surfaceData.metallic);\n}\nvoid CCSurfacesLightingInitializeColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n  diffuseColorWithLighting = CCSurfacesGetDiffuseColor(surfaceData);\n  specularColorWithLighting = IntegratedGFApprox(CCSurfacesGetSpecularColor(surfaceData).xyz, surfaceData.roughness, lightingData.NoVAbsSat);\n}\nvoid CCSurfacesLightingCalculateColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n}\nvoid CCSurfacesInitializeLightingIntermediateData(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  vec3 worldPos;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n  #else\n  worldPos = surfaceData.worldPos;\n  #endif\n  CCSurfacesLightingGetIntermediateData_PerPixel(lightingData, surfaceData.worldNormal, worldPos, surfaceData.worldTangent, surfaceData.worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n      , surfaceData.anisotropyShape\n#endif\n  );\n  lightingData.specularParam = surfaceData.roughness;\n  lightingData.ior = surfaceData.ior;\n}\nvoid CCSurfacesLightingCalculateIntermediateData_PerLight(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData, vec3 lightDirWithDist)\n{\n  CCSurfacesLightingGetIntermediateData_PerLight(lightingData, lightDirWithDist);\n#if CC_SURFACES_LIGHTING_TRANSMITTENCE\n  lightingData.transmittenceParams = surfaceData.transmittenceParams;\n#endif\n}\n#if CC_SURFACES_LIGHTING_TRT\nvoid CCSurfacesGetLightingIntermediateDataTRT(out LightingIntermediateData lightingDataTRT, in LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  lightingDataTRT = lightingData;\n  lightingDataTRT.specularParam = surfaceData.roughnessTRT;\n}\n#endif\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData)\n{\n  lightingResult.ao = surfaceData.ao;\n  lightingResult.emissive = surfaceData.emissive;\n}\n#if CC_PIPELINE_TYPE == 1\n  vec4 CCSurfacesDeferredOutput0(in SurfacesMaterialData surfaceData)\n  {\n    return surfaceData.baseColor;\n  }\n  vec4 CCSurfacesDeferredOutput1(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(float32x3_to_oct(surfaceData.worldNormal), surfaceData.roughness, surfaceData.metallic);\n  }\n  vec4 CCSurfacesDeferredOutput2(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(surfaceData.emissive, surfaceData.ao);\n  }\n#endif\nvec4 CCSurfacesShading(in SurfacesMaterialData surfaceData, in LightingResult lightingResult)\n{\n  vec4 color = vec4(0.0, 0.0, 0.0, surfaceData.baseColor.a);\n#if CC_FORWARD_ADD\n  color.xyz += lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithLighting;\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.directTransmitSpecular * lightingResult.specularColorWithLighting\n  #endif\n  ;\n#else\n  float fresnel = 1.0;\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    fresnel = lightingResult.fresnel;\n  #endif\n  color.xyz +=\n    ( lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithLighting * fresnel\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.directTransmitSpecular * lightingResult.specularColorWithLighting * (1.0 - fresnel)\n  #endif\n  #if CC_SURFACES_LIGHTING_TRT\n    + lightingResult.directTRT * lightingResult.specularColorWithLighting\n  #endif\n    )\n    * lightingResult.shadow;\n  #if CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_ALL_IN_ONE\n    color.xyz += lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting * lightingResult.shadow;\n  #elif CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n    color.xyz += lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting;\n  #endif\n  color.xyz +=\n    ( lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.environmentSpecular * lightingResult.specularColorWithLighting * fresnel\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.environmentTransmitSpecular * lightingResult.specularColorWithLighting * (1.0 - fresnel)\n  #endif\n  #if CC_SURFACES_LIGHTING_TRT\n    + lightingResult.environmentTRT * lightingResult.specularColorWithLighting\n  #endif\n    )\n    * lightingResult.ao;\n  color.xyz += lightingResult.emissive;\n#endif\n  return color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\nvoid CCSurfacesDebugViewSurfaceData(inout vec4 color, in SurfacesMaterialData surfaceData)\n{\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    float scalar;\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(surfaceData.worldNormal * 0.5 + vec3(0.5), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldBinormal * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSPARENCY)) < EPSILON) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.baseColor.a;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_BASE_COLOR)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(surfaceData.baseColor.rgb), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(CCSurfacesGetDiffuseColor(surfaceData)), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(CCSurfacesGetSpecularColor(surfaceData)), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ROUGHNESS)) < EPSILON) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.roughness;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_METALLIC)) < EPSILON) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.metallic;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY)) < EPSILON) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.specularIntensity;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n}\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD && !CC_ENABLE_CLUSTERED_LIGHT_CULLING\n    void CCSurfacesLighting(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      vec3 worldPos;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n      #else\n      worldPos = surfaceData.worldPos;\n      #endif\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, surfaceData, lightingData);\n      lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n      int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n      for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n        if (i >= numLights) break;\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, cc_lightPos[i].xyz - worldPos);\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, surfaceData, lightingData);\n        vec3 diffuseLighting, specularLighting;\n        CCSurfacesLightingCalculateDirect(diffuseLighting, specularLighting, lightingData, cc_lightColor[i]);\n        float fresnel = 1.0;\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        fresnel = lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n        vec3 transmitSpecularLighting;\n        CCSurfacesLightingCalculateDirectTransmitSpecular(transmitSpecularLighting, lightingData, cc_lightColor[i]);\n      #endif\n        float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowNDCPosWithBias = vec4(0.0);\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            shadowPos = cc_matLightViewProj * vec4(surfaceData.worldPos, 1.0);\n            shadow = CCSpotShadowFactorBase(shadowNDCPosWithBias, shadowPos, worldPos, shadowBias);\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMITTENCE\n            lightingData.shadowPosAndDepth.xy = shadowNDCPosWithBias.xy;\n            lightingData.shadowPosAndDepth.z = shadowPos.z;\n            lightingData.shadowPosAndDepth.w = GetViewSpaceDepthFromNDCDepth_Perspective(SampleShadowMap(shadowNDCPosWithBias.xyz, cc_spotShadowMap), shadowNDCPosWithBias.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n          #endif\n        }\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW) {\n          shadow = 1.0;\n        }\n      #endif\n        float distAtt = CCSurfacesLightingCalculateDistanceAttenuation(lightingData, cc_lightSizeRangeAngle[i]);\n        float angleAtt = 1.0;\n        if (cc_lightPos[i].w > 0.0) {\n          angleAtt = CCSurfacesLightingCalculateAngleAttenuation(lightingData, cc_lightSizeRangeAngle[i], -cc_lightDir[i].xyz);\n        }\n        float multiplier = distAtt * angleAtt * shadow;\n        lightingResult.directDiffuse += diffuseLighting * multiplier;\n        lightingResult.directSpecular += specularLighting * multiplier * fresnel;\n        #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n          lightingResult.directTransmitSpecular += transmitSpecularLighting * multiplier * (1.0 - fresnel);\n        #endif\n        #if CC_SURFACES_LIGHTING_TRANSMITTENCE\n          lightingResult.transmittence = CCSurfacesLightingCalculateDirectTransmittence(lightingResult, lightingData, cc_lightColor[i]);\n        #endif\n        #if CC_SURFACES_LIGHTING_TRT\n          CCSurfacesLightingCalculateDirectTRT(lightingResult.directTRT, lightingData, cc_lightColor[i]);\n        #endif\n      }\n    }\n  #else\n    void CCSurfacesLighting(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      CCSurfacesInitializeLightingResult(lightingResult, surfaceData);\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, surfaceData, lightingData);\n      CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, -cc_mainLitDir.xyz);\n      lightingResult.shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_mainLitDir.w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowNDCPosWithBias = vec4(0.0);\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            if (cc_shadowLPNNInfo.w > 0.0) {\n              #if CC_DIR_LIGHT_SHADOW_TYPE == 2\n                lightingResult.shadow = CCCSMFactorBase(shadowPos, shadowNDCPosWithBias, surfaceData.worldPos, lightingData.N, shadowBias);\n              #endif\n            } else {\n              #if CC_DIR_LIGHT_SHADOW_TYPE == 1\n                shadowPos = cc_matLightViewProj * vec4(surfaceData.worldPos, 1.0);\n                lightingResult.shadow = CCShadowFactorBase(shadowPos, shadowNDCPosWithBias, lightingData.N, shadowBias);\n              #endif\n            }\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMITTENCE\n            lightingData.shadowPosAndDepth.xy = shadowNDCPosWithBias.xy;\n            lightingData.shadowPosAndDepth.z = shadowPos.z;\n            lightingData.shadowPosAndDepth.w = GetViewSpaceDepthFromNDCDepth_Orthgraphic(SampleShadowMap(shadowNDCPosWithBias.xyz, cc_shadowMap), cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n          #endif\n        }\n      #endif\n      lightingResult.lightmapColor = vec3(0.0);\n      #if CC_SURFACES_USE_LIGHT_MAP && !CC_FORWARD_ADD\n\t\t    float lightmapShadow, lightmapAO;\n        GetLightMapColor(lightingResult.lightmapColor, lightmapShadow, lightmapAO, cc_lightingMap, FSInput_lightMapUV.xy, FSInput_lightMapUV.z, surfaceData.worldNormal);\n        #if CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n          lightingResult.shadow *= lightmapShadow;\n          lightingResult.ao *= lightmapAO;\n        #endif\n      #endif\n      lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n      #if CC_SURFACES_USE_LIGHT_MAP != LIGHT_MAP_TYPE_ALL_IN_ONE && !CC_FORWARD_ADD\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, surfaceData, lightingData);\n        CCSurfacesLightingCalculateDirect(lightingResult.directDiffuse, lightingResult.directSpecular, lightingData, cc_mainLitColor);\n      #endif\n      CCSurfacesLightingCalculateEnvironment(lightingResult.environmentDiffuse, lightingResult.environmentSpecular, lightingData, cc_ambientSky.w);\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n        CCSurfacesLightingCalculateDirectTransmitSpecular(lightingResult.directTransmitSpecular, lightingData, cc_mainLitColor);\n        CCSurfacesLightingCalculateEnvironmentTransmitSpecular(lightingResult.environmentTransmitSpecular, lightingData, cc_ambientSky.w);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMITTENCE\n        lightingResult.transmittence = CCSurfacesLightingCalculateDirectTransmittence(lightingResult, lightingData, cc_mainLitColor);\n        lightingResult.transmittence += CCSurfacesLightingCalculateEnvironmentTransmittence(lightingResult, lightingData, cc_ambientSky.w);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRT\n      LightingIntermediateData lightingDataTRT;\n        CCSurfacesGetLightingIntermediateDataTRT(lightingDataTRT, lightingData, surfaceData);\n        CCSurfacesLightingCalculateDirectTRT(lightingResult.directTRT, lightingDataTRT, cc_mainLitColor);\n        CCSurfacesLightingCalculateEnvironmentTRT(lightingResult.environmentTRT, lightingDataTRT, cc_ambientSky.w);\n      #endif\n      #if CC_ENABLE_CLUSTERED_LIGHT_CULLING\n      #endif\n      #ifdef CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT\n        SurfacesLightingModifyFinalResult(lightingResult, lightingData, surfaceData);\n      #endif\n    }\n  #endif\n#endif\nvec4 CCSurfacesDebugDisplayInvalidNumber(vec4 color)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(color.rgb) || isinfs(color.rgb)) ? error : color;\n}\nvec4 CCSurfacesDebugDisplayInvalidInputData(vec4 color, vec3 data)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(data) || isinfs(data)) ? error : color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && !CC_FORWARD_ADD\n  void CCSurfacesDebugViewMeshData(inout vec4 color)\n  {\n    vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_VERTEX_COLOR\n        color = FSInput_vertexColor;\n      #else\n        color = white;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(FSInput_worldNormal * 0.5 + vec3(0.5), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(FSInput_worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        float sign = FSInput_mirrorNormal * 0.5 + 0.5;\n        color = vec4(sign, sign, sign, 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FACE_SIDE)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n        float scalar = clamp(FSInput_faceSideSign, 0.0, 1.0);\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UV0)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(FSInput_texcoord.xy, 0.0, 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UV1)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n      color = vec4(FSInput_texcoord1.xy, 0.0, 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n        color = vec4(FSInput_lightMapUV.xy, 0.0, 1.0);\n      #else\n        color = vec4(0.0, 0.0, 0.0, 1.0);\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n      vec4 clipPos = cc_matProj * cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = clipPos.z / clipPos.w;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n      vec4 viewPos = cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = (-viewPos.z - cc_nearFar.x) / cc_nearFar.y;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_WORLD_POS)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n      color = vec4(FSInput_worldPos.xyz, 1.0);\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\n  bool CCSurfacesDebugViewLightingResult(inout vec4 color, in LightingResult lightingResult)\n  {\n      bool isDebugMatched = false;\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting;\n        isDebugMatched = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directSpecular * lightingResult.specularColorWithLighting;\n        isDebugMatched = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.directSpecular * lightingResult.specularColorWithLighting;\n        isDebugMatched = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting;\n        isDebugMatched = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentSpecular * lightingResult.specularColorWithLighting;\n        isDebugMatched = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_ALL)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.environmentSpecular * lightingResult.specularColorWithLighting;\n        isDebugMatched = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_LIGHT_MAP)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.lightmapColor;\n        isDebugMatched = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_EMISSIVE)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.emissive;\n        isDebugMatched = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_AO)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(lightingResult.ao);\n        isDebugMatched = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SHADOW)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(lightingResult.shadow);\n        isDebugMatched = true;\n    }\n    return isDebugMatched;\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  void CCSurfacesDebugViewCompositeLightingResult(inout LightingResult lightingResult)\n  {\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE)\n      lightingResult.directDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR)\n      lightingResult.directSpecular = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE)\n      lightingResult.environmentDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR)\n      lightingResult.environmentSpecular = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE)\n      lightingResult.emissive = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP)\n      lightingResult.lightmapColor = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW)\n      lightingResult.shadow = 1.0;\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO)\n      lightingResult.ao = 1.0;\n  }\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  void main()  {\n  #if CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER\n    float NoL = dot(-cc_mainLitDir.xyz, FSInput_worldNormal.xyz);\n    vec4 color = SurfacesFragmentModifyBaseColorAndTransparency();\n  #else\n    SurfacesMaterialData surfaceData;\n    CCSurfacesFragmentGetMaterialData(surfaceData);\n    vec2 shadowBias = vec2(0.0);\n    vec3 colDebugCSMLayer = vec3(1.0);\n    #if CC_RECEIVE_SHADOW\n      shadowBias = FSInput_shadowBias;\n      #if !CC_FORWARD_ADD\n        #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n          if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION)\n          {\n              vec4 csmPos;\n              vec4 shadowProjDepthInfo, shadowProjInfo;\n              vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n              int csmLayer = -1;\n              csmLayer = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, surfaceData.worldPos);\n              bool OutOfRange = csmLayer < 0;\n              if (OutOfRange)\n                  colDebugCSMLayer = vec3(1.0);\n              else if (csmLayer == 0)\n                  colDebugCSMLayer = vec3(1.0, 0.0, 0.0);\n              else if (csmLayer == 1)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 0.0);\n              else if (csmLayer == 2)\n                  colDebugCSMLayer = vec3(0.0, 0.0, 1.0);\n              else if (csmLayer == 3)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 1.0);\n          }\n        #endif\n      #endif\n    #endif\n    #if !CC_FORWARD_ADD\n      float fogFactor = 1.0;\n      #if CC_USE_FOG != 4\n        #if !CC_USE_ACCURATE_FOG\n          fogFactor = FSInput_fogFactor;\n        #else\n          CC_TRANSFER_FOG_BASE(vec4(FSInput_worldPos, 1.0), fogFactor);\n        #endif\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG) {\n            fogFactor = 1.0;\n        }\n      #endif\n    #endif\n    LightingResult lightingResult;\n    CCSurfacesLighting(lightingResult, surfaceData, shadowBias);\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && CC_SURFACES_ENABLE_DEBUG_VIEW\n      vec4 debugColor = vec4(0.0, 0.0, 0.0, 1.0);\n      #if !CC_FORWARD_ADD\n        CCSurfacesDebugViewMeshData(debugColor);\n        CCSurfacesDebugViewSurfaceData(debugColor, surfaceData);\n        if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FOG)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n        {\n          fogFactor = 1.0 - fogFactor;\n          debugColor = vec4(fogFactor, fogFactor, fogFactor, 1.0);\n        }\n      #endif\n      #if CC_FORWARD_ADD\n        if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) < EPSILON) && (cc_surfaceTransform.y != 3.0)) || ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) < EPSILON) && (cc_surfaceTransform.y != 3.0)) || ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) < EPSILON) && (cc_surfaceTransform.y != 3.0)))\n      #endif\n        {\n            if (CCSurfacesDebugViewLightingResult(debugColor, lightingResult))\n            {\n              #if CC_USE_HDR\n                if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING)\n                    debugColor.rgb = ACESToneMap(debugColor.rgb);\n              #endif\n              if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION)\n                  debugColor.rgb = LinearToSRGB(debugColor.rgb);\n            }\n        }\n      if (IS_DEBUG_VIEW_ENABLE_WITH_CAMERA) {\n        gl_FragData[0] = debugColor;\n        return;\n      }\n    #elif CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n      CCSurfacesDebugViewCompositeLightingResult(lightingResult);\n    #endif\n    vec4 color = CCSurfacesShading(surfaceData, lightingResult);\n    #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n      if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION) {\n          color.rgb *= colDebugCSMLayer.rgb;\n      }\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = CCSurfacesDebugDisplayInvalidInputData(color, FSInput_worldTangent);\n      #endif\n    #endif\n  #endif\n    #if CC_USE_HDR\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n        if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING)\n      #endif\n        color.rgb = ACESToneMap(color.rgb);\n    #endif\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n      if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION)\n    #endif\n    color.rgb = LinearToSRGB(color.rgb);\n    #if !CC_FORWARD_ADD && CC_USE_FOG != 4\n      CC_APPLY_FOG_BASE(color, fogFactor);\n    #endif\n    gl_FragData[0] = CCSurfacesDebugDisplayInvalidNumber(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n    void main () {\n      SurfacesMaterialData surfaceData;\n      CCSurfacesFragmentGetMaterialData(surfaceData);\n      gl_FragData[0] = CCSurfacesDeferredOutput0(surfaceData);\n      gl_FragData[1] = CCSurfacesDeferredOutput1(surfaceData);\n      gl_FragData[2] = CCSurfacesDeferredOutput2(surfaceData);\n    }\n#endif"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","defines":["CC_USE_IBL"]},{"name":"cc_diffuseMap","defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":["!USE_INSTANCING"]},{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":101,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":121}},"defines":[{"name":"HAS_SECOND_UV","type":"boolean"},{"name":"USE_TWOSIDE","type":"boolean"},{"name":"USE_REFLECTION_DENOISE","type":"boolean"},{"name":"IS_ANISOTROPY","type":"boolean"},{"name":"USE_VERTEX_COLOR","type":"boolean"},{"name":"USE_COMPATIBLE_LIGHTING","type":"boolean"},{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_LIGHT_PROBE","type":"boolean","default":0},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_FORWARD_ADD","type":"boolean"},{"name":"CC_USE_FOG","type":"number","range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER","type":"number","range":[0,1]},{"name":"CC_PIPELINE_TYPE","type":"number","range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean"},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"CC_USE_IBL","type":"number","range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","range":[0,2]},{"name":"CC_USE_REFLECTION_PROBE","type":"number","range":[0,3]},{"name":"CC_USE_DEBUG_VIEW","type":"number","range":[0,3]},{"name":"CC_IBL_CONVOLUTED","type":"boolean"},{"name":"CC_SHADOWMAP_FORMAT","type":"number","range":[0,3]},{"name":"CC_SHADOWMAP_USE_LINEAR_DEPTH","type":"boolean"},{"name":"CC_DIR_SHADOW_PCF_TYPE","type":"number","range":[0,3]},{"name":"CC_CASCADED_LAYERS_TRANSITION","type":"boolean"},{"name":"CC_LIGHT_MAP_VERSION","type":"number","range":[0,3]},{"name":"CC_USE_HDR","type":"boolean"},{"name":"TEXTURE_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"DCC_APP_NAME","type":"number","range":[0,5]},{"name":"USE_SHININESS_MAP","type":"boolean"},{"name":"GLOSSINESS_MAP_CHANNEL","type":"string","options":["r","g","b","a"]},{"name":"USE_SPECULAR_GLOSSINESS_MAP","type":"boolean"},{"name":"USE_SPECULAR_MAP","type":"boolean"},{"name":"USE_METALLIC_MAP","type":"boolean"},{"name":"USE_ALBEDO_MAP","type":"boolean"},{"name":"USE_TRANSPARENCY_MAP","type":"boolean"},{"name":"TRANSPARENCY_MAP_CHANNEL","type":"string","options":["a","r","g","b"]},{"name":"USE_EMISSIVE_MAP","type":"boolean"},{"name":"USE_EMISSIVESCALE_MAP","type":"boolean"},{"name":"USE_NORMAL_MAP","type":"boolean"},{"name":"NORMAL_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_OCCLUSION_MAP","type":"boolean"},{"name":"OCCLUSION_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"OCCLUSION_CHANNEL","type":"string","options":["r","g","b","a"]},{"name":"USE_ALPHA_TEST","type":"boolean"},{"name":"HAS_EXPORTED_GLOSSINESS","type":"boolean"},{"name":"GLOSSINESS_MAP_USE_SINGLE_CHANNEL","type":"boolean"},{"name":"HAS_EXPORTED_METALLIC","type":"boolean"},{"name":"USE_REFLECTION_PROBE","type":"number","range":[0,3]},{"name":"CC_SHADOW_TYPE","type":"number","range":[0,3]},{"name":"CC_DIR_LIGHT_SHADOW_TYPE","type":"number","range":[0,3]}]},{"hash":2485103015,"name":"dcc/surfaces-imported-specular-glossiness|shadow-caster-vs|shadow-caster-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"diffuseColor","type":16,"count":1},{"name":"specularColor","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScale","type":13,"count":1},{"name":"alphaThreshold","type":13,"count":1},{"name":"shininessExponent","type":13,"count":1},{"name":"glossiness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalScale","type":13,"count":1},{"name":"transparencyFactor","type":13,"count":1},{"name":"diffuseFactor","type":13,"count":1},{"name":"specularFactor","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"shininessExponentMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_SHININESS_MAP"]},{"name":"specularGlossinessMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_SPECULAR_GLOSSINESS_MAP"]},{"name":"specularMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_SPECULAR_MAP"]},{"name":"metallicMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_MAP"]},{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_ALBEDO_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_TRANSPARENCY_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["USE_EMISSIVE_MAP"]},{"name":"emissiveScaleMap","type":28,"count":1,"stageFlags":16,"binding":8,"defines":["USE_EMISSIVESCALE_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":9,"defines":["USE_NORMAL_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":10,"defines":["USE_OCCLUSION_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_color","format":44,"location":6,"defines":["CC_SURFACES_USE_VERTEX_COLOR"]},{"name":"a_texCoord1","format":21,"location":7,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":13,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":15,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":16,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":17,"defines":["CC_USE_MORPH"]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCLocal","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]},{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_lightPos","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true},{"name":"cc_lightColor","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightSizeRangeAngle","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightDir","typename":"vec4","type":16,"count":0,"isArray":true}],"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_sh_linear_const_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_a","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"diffuseColor","type":16,"count":1},{"name":"specularColor","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScale","type":13,"count":1},{"name":"alphaThreshold","type":13,"count":1},{"name":"shininessExponent","type":13,"count":1},{"name":"glossiness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalScale","type":13,"count":1},{"name":"transparencyFactor","type":13,"count":1},{"name":"diffuseFactor","type":13,"count":1},{"name":"specularFactor","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"shininessExponentMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_SHININESS_MAP"]},{"name":"specularGlossinessMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_SPECULAR_GLOSSINESS_MAP"]},{"name":"specularMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_SPECULAR_MAP"]},{"name":"metallicMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_MAP"]},{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_ALBEDO_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_TRANSPARENCY_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["USE_EMISSIVE_MAP"]},{"name":"emissiveScaleMap","type":28,"count":1,"stageFlags":16,"binding":8,"defines":["USE_EMISSIVESCALE_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":9,"defines":["USE_NORMAL_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":10,"defines":["USE_OCCLUSION_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_composite_pack_1","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_composite_pack_2","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_composite_pack_3","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCShadow","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matLightView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matLightViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_shadowInvProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowNFLSInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowWHPBInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowLPNNInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowColor","typename":"vec4","type":16,"count":1,"precision":"lowp "},{"name":"cc_planarNDInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCSM","stageFlags":16,"tags":{"builtin":"global"},"members":[{"name":"cc_csmViewDir0","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir1","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir2","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmAtlas","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_matCSMViewProj","typename":"mat4","type":25,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjDepthInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmSplitsInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_USE_IBL"]},{"name":"cc_diffuseMap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\n#define CC_SURFACES_USE_TANGENT_SPACE 0\n#define CC_SURFACES_USE_VERTEX_COLOR 0\n#define CC_SURFACES_USE_SECOND_UV 0\n#define CC_SURFACES_USE_LIGHT_MAP 0\n#define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMITTENCE\n  #define CC_SURFACES_LIGHTING_TRANSMITTENCE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    in vec4 a_sh_linear_const_r;\n    in vec4 a_sh_linear_const_g;\n    in vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n#endif\nout highp vec3 v_worldPos;\nout mediump vec4 v_normal;\nout vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  out lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  out mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  out mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  out mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW\n  out mediump vec2 v_shadowBias;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  out mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  out highp vec4 v_localPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    out mediump vec4 v_sh_linear_const_r;\n    out mediump vec4 v_sh_linear_const_g;\n    out mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBias\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW\n  vec2 shadowBias;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_debug_view_mode;\n  mediump vec4 cc_debug_view_composite_pack_1;\n  mediump vec4 cc_debug_view_composite_pack_2;\n  mediump vec4 cc_debug_view_composite_pack_3;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n  };\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n  #endif\n#endif\nlayout(std140) uniform Constants {\n  vec4  tilingOffset;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float emissiveScale;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.position.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBias;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nout highp vec2 v_clip_depth;\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matLightViewProj * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexOutput(In);\n  v_clip_depth = In.clipPos.zw;\n}","frag":"\nprecision highp float;\n#define CC_SURFACES_USE_TANGENT_SPACE 0\n#define CC_SURFACES_USE_VERTEX_COLOR 0\n#define CC_SURFACES_USE_SECOND_UV 0\n#define CC_SURFACES_USE_LIGHT_MAP 0\n#define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMITTENCE\n  #define CC_SURFACES_LIGHTING_TRANSMITTENCE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nin highp vec3 v_worldPos;\nin mediump vec4 v_normal;\nin vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  in mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  in mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW\n  in mediump vec2 v_shadowBias;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  in mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  in highp vec4 v_localPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    in mediump vec4 v_sh_linear_const_r;\n    in mediump vec4 v_sh_linear_const_g;\n    in mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBias\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_debug_view_mode;\n  mediump vec4 cc_debug_view_composite_pack_1;\n  mediump vec4 cc_debug_view_composite_pack_2;\n  mediump vec4 cc_debug_view_composite_pack_3;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO ((cc_debug_view_mode.y > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION ((cc_debug_view_mode.z > 0.0) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE ((cc_debug_view_composite_pack_1.x > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR ((cc_debug_view_composite_pack_1.y > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE ((cc_debug_view_composite_pack_1.z > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR ((cc_debug_view_composite_pack_1.w > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE ((cc_debug_view_composite_pack_2.x > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP ((cc_debug_view_composite_pack_2.y > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW ((cc_debug_view_composite_pack_2.z > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO ((cc_debug_view_composite_pack_2.w > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP ((cc_debug_view_composite_pack_3.x > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG ((cc_debug_view_composite_pack_3.y > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING ((cc_debug_view_composite_pack_3.z > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION ((cc_debug_view_composite_pack_3.w > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    layout(std140) uniform CCForwardLight {\n      highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n      vec4 cc_lightColor[LIGHTS_PER_PASS];\n      vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n      vec4 cc_lightDir[LIGHTS_PER_PASS];\n    };\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    layout(std140) uniform CCSH {\n      vec4 cc_sh_linear_const_r;\n      vec4 cc_sh_linear_const_g;\n      vec4 cc_sh_linear_const_b;\n      vec4 cc_sh_quadratic_r;\n      vec4 cc_sh_quadratic_g;\n      vec4 cc_sh_quadratic_b;\n      vec4 cc_sh_quadratic_a;\n    };\n  #endif\n#endif\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON)\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_USE_FOG != 4\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  #endif\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n#endif\nlayout(std140) uniform Constants {\n  vec4  tilingOffset;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float emissiveScale;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\n#define DCC_APP_OTHERS 0\n#define DCC_APP_MAX 1\n#define DCC_APP_BLENDER 2\n#define DCC_APP_CINEMA4D 3\n#define DCC_APP_GLTF 4\n#define DCC_APP_MAYA 5\n#if USE_SHININESS_MAP\n  uniform sampler2D shininessExponentMap;\n#endif\n#if USE_SPECULAR_GLOSSINESS_MAP\n  uniform sampler2D specularGlossinessMap;\n#endif\n#if USE_SPECULAR_MAP\n  uniform sampler2D specularMap;\n#endif\n #if USE_METALLIC_MAP\n  uniform sampler2D metallicMap;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_EMISSIVESCALE_MAP\n  uniform sampler2D emissiveScaleMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\nvoid SurfacesFragmentAlphaClipOnly()\n{\n    #if USE_ALPHA_TEST\n      float alpha = diffuseColor.a;\n      #if USE_VERTEX_COLOR\n        alpha *= FSInput_vertexColor.a;\n      #endif\n      #if USE_ALBEDO_MAP\n        alpha *= texture(albedoMap, TEXTURE_UV).a * transparencyFactor;\n      #endif\n      #if USE_TRANSPARENCY_MAP\n        alpha = texture(transparencyMap, TEXTURE_UV).TRANSPARENCY_MAP_CHANNEL;\n        #if DCC_APP_NAME == DCC_APP_MAYA\n          alpha = 1.0 - alpha;\n        #endif\n      #endif\n      if (alpha < alphaThreshold) discard;\n    #endif\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\n#define CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nstruct SurfacesMaterialData\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPos, worldPos_fract_part;\n  #else\n  vec3 worldPos;\n  #endif\n  vec4 baseColor;\n  vec3 worldNormal;\n  vec3 emissive;\n  float specularIntensity;\n  float roughness;\n  float metallic;\n  float ao;\n  vec3 worldTangent, worldBinormal;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMITTENCE\n  vec4 transmittenceParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRT\n  float roughnessTRT;\n#endif\n};\nin highp vec2 v_clip_depth;\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\n  SurfacesFragmentAlphaClipOnly();\n  highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;\n  if(cc_shadowLPNNInfo.x > EPSILON && cc_shadowLPNNInfo.x < 1.999999) {\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      clipDepth = CCGetLinearDepth(FSInput_worldPos.xyz);\n    #endif\n  }\n  #if CC_SHADOWMAP_FORMAT == 1\n    fragColorX = packDepthToRGBA(clipDepth);\n  #else\n    fragColorX = vec4(clipDepth, 1.0, 1.0, 1.0);\n  #endif\n}"},"glsl1":{"vert":"\nprecision highp float;\n#define CC_SURFACES_USE_TANGENT_SPACE 0\n#define CC_SURFACES_USE_VERTEX_COLOR 0\n#define CC_SURFACES_USE_SECOND_UV 0\n#define CC_SURFACES_USE_LIGHT_MAP 0\n#define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMITTENCE\n  #define CC_SURFACES_LIGHTING_TRANSMITTENCE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  attribute vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  attribute vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n#endif\nvarying highp vec3 v_worldPos;\nvarying mediump vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW\n  varying mediump vec2 v_shadowBias;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBias\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW\n  vec2 shadowBias;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matLightViewProj;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n  #endif\n#endif\n    uniform vec4 tilingOffset;\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.position.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBias;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nvarying highp vec2 v_clip_depth;\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matLightViewProj * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexOutput(In);\n  v_clip_depth = In.clipPos.zw;\n}","frag":"\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\n#define CC_SURFACES_USE_TANGENT_SPACE 0\n#define CC_SURFACES_USE_VERTEX_COLOR 0\n#define CC_SURFACES_USE_SECOND_UV 0\n#define CC_SURFACES_USE_LIGHT_MAP 0\n#define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMITTENCE\n  #define CC_SURFACES_LIGHTING_TRANSMITTENCE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nvarying highp vec3 v_worldPos;\nvarying mediump vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW\n  varying mediump vec2 v_shadowBias;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBias\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\nuniform mediump vec4 cc_debug_view_mode;\n  uniform mediump vec4 cc_debug_view_composite_pack_1;\n  uniform mediump vec4 cc_debug_view_composite_pack_2;\n  uniform mediump vec4 cc_debug_view_composite_pack_3;\nuniform mediump vec4 cc_surfaceTransform;\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO ((cc_debug_view_mode.y > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION ((cc_debug_view_mode.z > 0.0) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE ((cc_debug_view_composite_pack_1.x > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR ((cc_debug_view_composite_pack_1.y > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE ((cc_debug_view_composite_pack_1.z > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR ((cc_debug_view_composite_pack_1.w > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE ((cc_debug_view_composite_pack_2.x > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP ((cc_debug_view_composite_pack_2.y > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW ((cc_debug_view_composite_pack_2.z > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO ((cc_debug_view_composite_pack_2.w > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP ((cc_debug_view_composite_pack_3.x > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG ((cc_debug_view_composite_pack_3.y > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING ((cc_debug_view_composite_pack_3.z > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION ((cc_debug_view_composite_pack_3.w > 0.0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    #endif\n#endif\nuniform highp mat4 cc_matLightView;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON)\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_USE_FOG != 4\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  #endif\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n#endif\n    uniform vec4 diffuseColor;\n    uniform vec4 emissive;\n    uniform float alphaThreshold;\n    uniform float metallic;\n    uniform float transparencyFactor;\n#define DCC_APP_OTHERS 0\n#define DCC_APP_MAX 1\n#define DCC_APP_BLENDER 2\n#define DCC_APP_CINEMA4D 3\n#define DCC_APP_GLTF 4\n#define DCC_APP_MAYA 5\n#if USE_SHININESS_MAP\n  uniform sampler2D shininessExponentMap;\n#endif\n#if USE_SPECULAR_GLOSSINESS_MAP\n  uniform sampler2D specularGlossinessMap;\n#endif\n#if USE_SPECULAR_MAP\n  uniform sampler2D specularMap;\n#endif\n #if USE_METALLIC_MAP\n  uniform sampler2D metallicMap;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_EMISSIVESCALE_MAP\n  uniform sampler2D emissiveScaleMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\nvoid SurfacesFragmentAlphaClipOnly()\n{\n    #if USE_ALPHA_TEST\n      float alpha = diffuseColor.a;\n      #if USE_VERTEX_COLOR\n        alpha *= FSInput_vertexColor.a;\n      #endif\n      #if USE_ALBEDO_MAP\n        alpha *= texture2D(albedoMap, TEXTURE_UV).a * transparencyFactor;\n      #endif\n      #if USE_TRANSPARENCY_MAP\n        alpha = texture2D(transparencyMap, TEXTURE_UV).TRANSPARENCY_MAP_CHANNEL;\n        #if DCC_APP_NAME == DCC_APP_MAYA\n          alpha = 1.0 - alpha;\n        #endif\n      #endif\n      if (alpha < alphaThreshold) discard;\n    #endif\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\n#define CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nstruct SurfacesMaterialData\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPos, worldPos_fract_part;\n  #else\n  vec3 worldPos;\n  #endif\n  vec4 baseColor;\n  vec3 worldNormal;\n  vec3 emissive;\n  float specularIntensity;\n  float roughness;\n  float metallic;\n  float ao;\n  vec3 worldTangent, worldBinormal;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMITTENCE\n  vec4 transmittenceParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRT\n  float roughnessTRT;\n#endif\n};\nvarying highp vec2 v_clip_depth;\nvoid main () {\n  SurfacesFragmentAlphaClipOnly();\n  highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;\n  if(cc_shadowLPNNInfo.x > EPSILON && cc_shadowLPNNInfo.x < 1.999999) {\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      clipDepth = CCGetLinearDepth(FSInput_worldPos.xyz);\n    #endif\n  }\n  #if CC_SHADOWMAP_FORMAT == 1\n    gl_FragColor = packDepthToRGBA(clipDepth);\n  #else\n    gl_FragColor = vec4(clipDepth, 1.0, 1.0, 1.0);\n  #endif\n}"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","defines":["CC_USE_IBL"]},{"name":"cc_diffuseMap","defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":["!USE_INSTANCING"]},{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":101,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":121}},"defines":[{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_LIGHT_PROBE","type":"boolean","default":0},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_FORWARD_ADD","type":"boolean"},{"name":"CC_USE_FOG","type":"number","range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER","type":"number","range":[0,1]},{"name":"CC_PIPELINE_TYPE","type":"number","range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean"},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"CC_USE_IBL","type":"number","range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","range":[0,2]},{"name":"CC_USE_REFLECTION_PROBE","type":"boolean"},{"name":"TEXTURE_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"DCC_APP_NAME","type":"number","range":[0,5]},{"name":"USE_SHININESS_MAP","type":"boolean"},{"name":"GLOSSINESS_MAP_CHANNEL","type":"string","options":["r","g","b","a"]},{"name":"USE_SPECULAR_GLOSSINESS_MAP","type":"boolean"},{"name":"USE_SPECULAR_MAP","type":"boolean"},{"name":"USE_METALLIC_MAP","type":"boolean"},{"name":"USE_ALBEDO_MAP","type":"boolean"},{"name":"USE_TRANSPARENCY_MAP","type":"boolean"},{"name":"TRANSPARENCY_MAP_CHANNEL","type":"string","options":["a","r","g","b"]},{"name":"USE_EMISSIVE_MAP","type":"boolean"},{"name":"USE_EMISSIVESCALE_MAP","type":"boolean"},{"name":"USE_NORMAL_MAP","type":"boolean"},{"name":"NORMAL_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_OCCLUSION_MAP","type":"boolean"},{"name":"OCCLUSION_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"OCCLUSION_CHANNEL","type":"string","options":["r","g","b","a"]},{"name":"USE_ALPHA_TEST","type":"boolean"},{"name":"USE_VERTEX_COLOR","type":"boolean"},{"name":"CC_SHADOWMAP_USE_LINEAR_DEPTH","type":"boolean"},{"name":"CC_SHADOWMAP_FORMAT","type":"number","range":[0,3]}]}],[{"name":"opaque","passes":[{"program":"dcc/surfaces-imported-specular-glossiness|standard-vs|standard-fs","properties":{"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"handleInfo":["diffuseColor",0,16]},"albedoScale":{"type":13,"value":[1],"handleInfo":["diffuseFactor",0,13]},"alphaThreshold":{"type":13,"value":[0.5]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1]},"emissiveMap":{"value":"grey","type":28},"emissiveScale":{"type":13,"value":[1]},"emissiveScaleMap":{"value":"grey","type":28},"shininessExponentMap":{"value":"grey","type":28},"shininessExponent":{"type":13,"value":[100]},"specularGlossinessMap":{"value":"grey","type":28},"specularColor":{"linear":true,"type":16,"value":[0,0,0,0]},"specularMap":{"value":"grey","type":28},"specularFactor":{"type":13,"value":[1]},"transparencyMap":{"value":"grey","type":28},"transparencyFactor":{"type":13,"value":[1]},"tilingOffset":{"type":16,"value":[1,1,0,0]},"normalStrength":{"type":13,"value":[1],"handleInfo":["normalScale",0,13]},"normalMap":{"value":"normal","type":28},"glossiness":{"type":13,"value":[0]},"metallic":{"type":13,"value":[0]},"metallicMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"albedoMap":{"type":28,"value":"grey"},"diffuseColor":{"type":16,"value":[1,1,1,1]},"diffuseFactor":{"type":13,"value":[1]},"normalScale":{"type":13,"value":[1]}}},{"phase":"forward-add","propertyIndex":0,"program":"dcc/surfaces-imported-specular-glossiness|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"dcc/surfaces-imported-specular-glossiness|shadow-caster-vs|shadow-caster-fs","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"handleInfo":["diffuseColor",0,16]},"albedoScale":{"type":13,"value":[1],"handleInfo":["diffuseFactor",0,13]},"alphaThreshold":{"type":13,"value":[0.5]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"transparencyMap":{"value":"grey","type":28},"transparencyFactor":{"type":13,"value":[1]},"diffuseColor":{"type":16,"value":[1,1,1,1]},"diffuseFactor":{"type":13,"value":[1]},"albedoMap":{"type":28,"value":"grey"}}}]},{"name":"transparent","passes":[{"program":"dcc/surfaces-imported-specular-glossiness|standard-vs|standard-fs","embeddedMacros":{"CC_FORCE_FORWARD_SHADING":true},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"handleInfo":["diffuseColor",0,16]},"albedoScale":{"type":13,"value":[1],"handleInfo":["diffuseFactor",0,13]},"alphaThreshold":{"type":13,"value":[0.5]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1]},"emissiveMap":{"value":"grey","type":28},"emissiveScale":{"type":13,"value":[1]},"emissiveScaleMap":{"value":"grey","type":28},"shininessExponentMap":{"value":"grey","type":28},"shininessExponent":{"type":13,"value":[100]},"specularGlossinessMap":{"value":"grey","type":28},"specularColor":{"linear":true,"type":16,"value":[0,0,0,0]},"specularMap":{"value":"grey","type":28},"specularFactor":{"type":13,"value":[1]},"transparencyMap":{"value":"grey","type":28},"transparencyFactor":{"type":13,"value":[1]},"tilingOffset":{"type":16,"value":[1,1,0,0]},"normalStrength":{"type":13,"value":[1],"handleInfo":["normalScale",0,13]},"normalMap":{"value":"normal","type":28},"glossiness":{"type":13,"value":[0]},"metallic":{"type":13,"value":[0]},"metallicMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"albedoMap":{"type":28,"value":"grey"},"diffuseColor":{"type":16,"value":[1,1,1,1]},"diffuseFactor":{"type":13,"value":[1]},"normalScale":{"type":13,"value":[1]}}},{"phase":"forward-add","propertyIndex":0,"program":"dcc/surfaces-imported-specular-glossiness|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"dcc/surfaces-imported-specular-glossiness|shadow-caster-vs|shadow-caster-fs","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"handleInfo":["diffuseColor",0,16]},"albedoScale":{"type":13,"value":[1],"handleInfo":["diffuseFactor",0,13]},"alphaThreshold":{"type":13,"value":[0.5]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"transparencyMap":{"value":"grey","type":28},"transparencyFactor":{"type":13,"value":[1]},"diffuseColor":{"type":16,"value":[1,1,1,1]},"diffuseFactor":{"type":13,"value":[1]},"albedoMap":{"type":28,"value":"grey"}}}]}]]],0,0,[],[],[]],[[[4,"Stone",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4287136633],"emissive",8,[4,4287136633]]],11]]],0,0,[0],[0],[0]],[[[19],[17,"wall_gate_closed",[-2],[1,"f09whsSkpY+LhHmv+P0e4F",null,null,null,-1,0]],[15,"wall_gate_closed",1,[[16,-3,[6,"5fYD3Rm9VUrI8xdwGUerma"],[0,1,2],[9],3]],[1,"e4yQi33sZUd4wagrzt++wX",null,null,null,1,0]]],0,[0,2,1,0,-1,2,0,1,2,0,5,1,3],[0,0,0,0],[-1,-2,-3,3],[145,146,147,148]],[[[4,"BrownDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4282735259],"emissive",8,[4,4282735259]]],11]]],0,0,[0],[0],[0]],[[[4,"StoneDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4284768345],"emissive",8,[4,4284768345]]],11]]],0,0,[0],[0],[0]],[[[14,".bin",2739159844,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":66720,"length":9480,"count":2370,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":89832,"length":2184,"count":546,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[2],"indexView":{"offset":94320,"length":288,"count":72,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":66720,"count":1390,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":76200,"length":13632,"count":284,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":92016,"length":2304,"count":48,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.9999998211860657,0,-0.26715904474258423],"maxPosition",8,[1,0.9999998211860657,1.152435064315796,0.2671549320220947]]],-1],0,0,[],[],[]],[[[82,"Arrow",true],[90,"Arrow",[-4,-5],[[98,16,-3,[6,"ccZ2oG3BNHjL6WJh3o2PVy"],-2]],[155,"d7laBUGOdIhqK9jNuW0FVd",null,null,[],-1,0],[1,0.055,0,0],[3,0.4999999999999999,0.5,0.5000000000000001,0.5000000000000001],[1,0,89.99999999999999,90]],[131,"ARROW",1,[[16,-6,[6,"773NOlkl5IIY22V55uCwSB"],[0],[9],1]],[1,"eaZq20DAxIJoP969rPNSbW",null,null,null,1,0],[1,0,0,-0.5],[3,-0.7071067513842232,-4.7415211902227383e-8,-5.795192092132646e-8,0.7071068109888664],[1,-89.9999951703271,-0.000008537737362112608,-8.537737542032294e-7]],[150,"trail",1,[-7],[1,"3dXAFwivJOyYdGKPbbtLQh",null,null,null,1,0],[1,0,0,-0.931]],[208,0.5,false,1,3,[6,"a5UCqC1V1FHaw1QUHcDKIN"],[2,3],[27,4,[55,[[29]],[[101],[30,255,0.17633928571428573],[30,255,0.5424107142857143],[30,0,1]]]],[0],[0],[0],[0],[0],[0],[0],[0],[3,0.5],[0],[0],[0],[[40,[3,1]]],[31,true,[28,[4,1409286143]]],[47,0,[3,1]],[49,[0],[0],[0],[0]],[22,[0],[0],[0],[3,1]],[23,[0],[0],[0]],[45,[0],[0],[0],[0]],[32,[0],[0],[0]],[24,[21,1,[18,[0,1],[[10,2,1],[10,2,1]]]],[0]],[25],[221,true,false,[3,4],[215,0.6,0.05],[28,[4,1308622847]],[28,[4,1409286143]],-8],[224,2,1,4,5]]],0,[0,2,1,0,16,2,0,1,1,0,-1,2,0,-2,3,0,1,2,0,-1,4,0,13,4,0,5,1,8],[0,0,0,0,0,0],[-1,3,-1,-2,7,8],[26,149,9,32,9,20]],[[[77,"material-010",1,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"tintColor",8,[4,2134522623],"mainTexture",6,0]],11]]],0,0,[0,0],[6,0],[10,1]],[[[63,".bin",[{"vertexBundles":[{"attributes":[{"name":"a_position","format":32,"isNormalized":false,"stream":0,"isInstanced":false,"location":0},{"name":"a_normal","format":32,"isNormalized":false,"stream":0,"isInstanced":false,"location":0},{"name":"a_texCoord","format":21,"isNormalized":false,"stream":0,"isInstanced":false,"location":0},{"name":"a_tangent","format":44,"isNormalized":false,"stream":0,"isInstanced":false,"location":0}],"view":{"offset":0,"length":6048,"count":126,"stride":48}}],"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":6048,"length":348,"count":174,"stride":2}}]},"minPosition",8,[1,-0.3539995551109314,-0.17003630101680756,0],"maxPosition",8,[1,0.3539995551109314,0.17003630101680756,0.9313730597496033]]],-1],0,0,[],[],[]],[[[4,"material-002",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_TEXTURE":true}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[6,0],[150,30]],[[[19],[17,"forest",[-2],[1,"24Ys2U9jpV+qVYrD2vvkNf",null,null,null,-1,0]],[15,"forest",1,[[16,-3,[6,"c1Vm5FtsVZRJEtCpV0O6dZ"],[0,1],[9],2]],[1,"4eFZUQ6GZRHbB4gO3OmK9S",null,null,null,1,0]]],0,[0,2,1,0,-1,2,0,1,2,0,5,1,3],[0,0,0],[-1,-2,3],[151,152,153]],[[[14,".bin",4076309842,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":16128,"length":2016,"count":504,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":136320,"length":25920,"count":6480,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":16128,"count":336,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":18144,"length":118176,"count":2462,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.9777076840400696,-0.01863694190979004,-0.9737462997436523],"maxPosition",8,[1,0.9527628421783447,1.3415250778198242,0.9223982095718384]]],-1],0,0,[],[],[]],[[[4,"BrownDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4282735259],"emissive",8,[4,4282735259]]],11]]],0,0,[0],[0],[0]],[[[4,"GreenDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4287466280],"emissive",8,[4,4287466280]]],11]]],0,0,[0],[0],[0]],[[{"base":"2,2,0,0,2,0","rgbe":false,"mipmaps":[{"front":"6fAc9/gb9Kfr1dCvwZaWSA@b47c0@e9a6d","back":"6fAc9/gb9Kfr1dCvwZaWSA@b47c0@40c10","left":"6fAc9/gb9Kfr1dCvwZaWSA@b47c0@8fd34","right":"6fAc9/gb9Kfr1dCvwZaWSA@b47c0@74afd","top":"6fAc9/gb9Kfr1dCvwZaWSA@b47c0@bb97f","bottom":"6fAc9/gb9Kfr1dCvwZaWSA@b47c0@7d38f"}]}],[35],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[6],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[6],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[6],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[6],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[6],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[6],0,[],[],[]],[[[82,"mofaqiu",true],[87,"mofaqiu",[-2,-3,-4,-5,-6],[1,"2eko6nV9xBCJJnflwlX0bx",null,null,null,-1,0],[3,0.4999999999999999,0.5,0.5000000000000001,0.5000000000000001],[1,0,89.99999999999999,90]],[50,"Particle-004",1,[-7],[1,"e8w92SbgRPB4xtDg1xfm4F",null,null,null,1,0],[1,0.3,0.3,0.3]],[66,1,true,1,2,[6,"54lndX13REu4wcozsc30pb"],[[0,null],6,0],[8],[3,5.5],[0],[0],[0],[0],[0],[0],[0],[3,100],[0],[3,1],[0],[[40,[3,1]]],[56,[8]],[47,0,[3,1]],[49,[0],[0],[0],[0]],[22,[0],[0],[0],[3,1]],[23,[0],[0],[0]],[45,[0],[0],[0],[0]],[32,[0],[0],[0]],[24,[21,1,[18,[0,1],[[10,2,1],[10,2,1]]]],[0]],[25],[70,false,[3,0.5],[3,0.1],[8],[8],-8],[105,1,2,3]],[50,"Particle",1,[-9],[1,"9e6fmNo7BF4bHzPspQp91N",null,null,null,1,0],[1,0.3,0.3,0.3]],[66,1,true,1,4,[6,"f9mXr8oqlNn7mNweXyoQoV"],[[4,null],6,0],[8],[3,5],[0],[0],[0],[0],[0],[0],[0],[3,100],[0],[3,1],[0],[[40,[3,1]]],[56,[8]],[47,0,[3,1]],[49,[0],[0],[0],[0]],[22,[0],[0],[0],[3,1]],[23,[0],[0],[0]],[45,[0],[0],[0],[0]],[57,true,[0],[0],[3,1.3457312328283222]],[24,[21,1,[18,[0,1],[[10,2,1],[10,2,1]]]],[0]],[25],[70,false,[3,0.5],[3,0.1],[8],[8],-10],[106,4,5,6,7]],[50,"Particle-001",1,[-11],[1,"cayNBaVSRPsrCjhAOtnBIP",null,null,null,1,0],[1,0.3,0.3,0.3]],[66,1,true,1,6,[6,"dfPE0xtzJEAL8ThAost+Rx"],[[8,null],6,0],[8],[3,5],[0],[0],[0],[0],[0],[0],[0],[3,100],[0],[3,1],[0],[[40,[3,1]]],[56,[8]],[47,0,[3,1]],[49,[0],[0],[0],[0]],[22,[0],[0],[0],[3,1]],[23,[0],[0],[0]],[45,[0],[0],[0],[0]],[57,true,[0],[0],[3,-1.147472458856911]],[24,[21,1,[18,[0,1],[[10,2,1],[10,2,1]]]],[0]],[25],[70,false,[3,0.5],[3,0.1],[8],[8],-12],[106,4,9,10,11]],[50,"Particle-002",1,[-13],[1,"f0e603xmlIhrQ+YOHm9ZE8",null,null,null,1,0],[1,0.3,0.3,0.3]],[209,1,8,[6,"dbYU4tHfZCl5TY/bj6k3dM"],[12,13],[28,[4,3714344191]],[0],[0],[0],[0],[0],[0],[0],[0],[3,2],[0],[0],[0],[[40,[3,1]]],[56,[8]],[47,0,[3,1]],[49,[0],[0],[0],[0]],[22,[0],[0],[0],[3,1]],[23,[0],[0],[0]],[45,[0],[0],[0],[0]],[32,[0],[0],[0]],[24,[21,1,[18,[0,1],[[10,2,1],[10,2,1]]]],[0]],[25],[222,true,false,true,[3,3],[216,1,3.5,[18,[0,1],[[58,2,1,-2,1,-2,1],[219,2,1,1]]]],[28,[4,3533469183]],[28,[4,3656974168]],-14],[225,2,14,15]],[50,"Particle-003",1,[-15],[1,"e46wqlk3ZICZJjNUDBiWAW",null,null,null,1,0],[1,0.3,0.3,0.3]],[66,1,true,1,10,[6,"b6HysCEWxGs4r2NRukN0Ji"],[[16,null],6,0],[8],[3,5.5],[0],[0],[0],[0],[0],[0],[0],[3,100],[0],[3,1],[0],[[40,[3,1]]],[56,[8]],[47,0,[3,1]],[49,[0],[0],[0],[0]],[22,[0],[0],[0],[3,1]],[23,[0],[0],[0]],[45,[0],[0],[0],[0]],[32,[0],[0],[0]],[24,[21,1,[18,[0,1],[[10,2,1],[10,2,1]]]],[0]],[25],[70,false,[3,0.5],[3,0.1],[8],[8],-16],[105,17,18,19]]],0,[0,2,1,0,-1,2,0,-2,4,0,-3,6,0,-4,8,0,-5,10,0,-1,3,0,13,3,0,-1,5,0,13,5,0,-1,7,0,13,7,0,-1,9,0,13,9,0,-1,11,0,13,11,0,5,1,16],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,3,7,8,-1,3,7,8,-1,3,7,8,-1,-2,7,8,-1,3,7,8],[33,11,33,3,34,11,34,10,35,11,35,10,9,32,9,20,36,11,36,3]],[[[38,"MagicBuffBlue"],[132,"MagicBuffBlue",[[210,0,1,false,1000,-2,[6,"0eiEi3TnNHH6XG/kt1Opp5"],[[0,null],6,0],[8],[20,3,1.2,1.5],[0],[0],[20,3,10,15],[0],[0],[0],[0],[20,3,0.5,0.1],[0],[3,3.72],[0],[[34,0.01,[3,15]]],[31,true,[27,1,[37,[[29],[29],[46,0.9866071428571429,[4,4294795086]]]]]],[217,true,0.32,0.2,0,[0],[1,18,1,10]],[26,true,[21,1,[18,[0,1],[[10,2,1],[10,2,1]]]],[0],[0],[0]],[22,[0],[0],[0],[3,1]],[23,[0],[0],[0]],[36,true,0.15,[0],[0],[0],[3,1]],[32,[0],[0],[0]],[24,[0],[0]],[25],[35,[0],[0],[8],[8]],[226,1,3,1,2]]],[1,"8a/WkRPe9ALpn4wJuqyitk",null,null,null,-1,0],[1,0.006934325,0.74751997,2.8241134],[1,0.69343317,0.6934335,0.6934335]]],0,[0,2,1,0,1,1,0,5,1,2],[0,0,0],[-1,7,8],[12,12,21]],[[[4,"Beige",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":25,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4286492378],"emissive",8,[4,4286492378]]],11]]],0,0,[0],[0],[0]],[[[4,"Brown",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":25,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4284450248],"emissive",8,[4,4284450248]]],11]]],0,0,[0],[0],[0]],[[[4,"BrownDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4282735259],"emissive",8,[4,4282735259]]],11]]],0,0,[0],[0],[0]],[[[14,".bin",4082153956,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":10368,"length":1584,"count":396,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":10368,"count":216,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.5971965789794922,0.08399230986833572,-0.5118821263313293],"maxPosition",8,[1,0.6026098728179932,0.44065529108047485,0.5142877697944641]]],-1],0,0,[],[],[]],[[[19],[17,"farm_plot",[-2],[1,"75THaENV1fgYQv5nw/oO5m",null,null,null,-1,0]],[60,"farm_plot",1,[-4],[[16,-3,[6,"2bUxUqlSVYqKA8VJ5QWOCr"],[2,3,4],[9],5]],[1,"e86bbUKTpSVYRBB3uN+Qvd",null,null,null,1,0]],[15,"farm_wheat",2,[[16,-5,[6,"e9lxQmSBdVPrBHh98W1VDD"],[0],[9],1]],[1,"facgkYSkVesYBdXvkokVFS",null,null,null,1,0]]],0,[0,2,1,0,-1,2,0,1,2,0,-1,3,0,1,3,0,5,1,5],[0,0,0,0,0,0],[-1,3,-1,-2,-3,3],[154,155,156,157,158,159]],[[[4,"Yellow",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4280597759],"emissive",8,[4,4280597759]]],11]]],0,0,[0],[0],[0]],[[[14,".bin",3816117929,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":19584,"length":4992,"count":1248,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":29184,"length":1296,"count":324,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[2],"indexView":{"offset":54480,"length":3000,"count":750,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":19584,"count":408,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":24576,"length":4608,"count":96,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":30480,"length":24000,"count":500,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.736423671245575,-0.015901368111371994,-0.6415857076644897],"maxPosition",8,[1,0.736282467842102,0.28383883833885193,0.6415857076644897]]],-1],0,0,[],[],[]],[[[38,"RoundHitBlue"],[91,"RoundHitBlue",[-3],[[99,0,1,false,false,1000,-2,[6,"d5GI40I7FA8aZM9c7AweBi"],[[4,null],6,0],[28,[4,4292986880]],[3,0.4],[0],[0],[3,5],[0],[0],[0],[0],[3,0.2],[0],[0],[0],[[34,0.01,[3,8]]],[31,true,[27,1,[37,[[39,[4,4294952960]],[46,1,[4,4294953472]]]]]],[48,true,3,0.01,0,[0]],[26,true,[21,1,[18,[0,1],[[10,2,0.6444444444444445],[10,2,1]]]],[0],[0],[0]],[22,[0],[0],[0],[3,1]],[23,[0],[0],[0]],[36,true,0.02,[0],[0],[0],[3,1]],[32,[0],[0],[0]],[24,[0],[0]],[25],[35,[0],[0],[8],[8]],[107,1,0,3,5,6]]],[1,"19/QDdVANNHLitUdG1xQjn",null,null,null,-1,0],[3,-0.7071067999999991,0,0,0.7071067623730954],[1,-90.00000304885037,0,0]],[15,"HitSpikes",1,[[65,0,1,false,false,50,-4,[6,"4aArTrKyFAd5R1omOK5NRg"],[0],[8],[20,3,0.07,0.12],[0],[0],[20,3,6,9],[0],[0],[0],[0],[20,3,0.3,0.6],[0],[0],[0],[[34,0.01,[3,8]]],[31,true,[27,1,[37,[[39,[4,4294178559]],[39,[4,4294937344]]]]]],[48,true,3,0.49,0,[0]],[26,true,[21,1,[18,[0,0.6743589743589744,1],[[10,2,1],[68,2,1,-0.02777777777777741,-0.02777777777777741],[220,2,-5.666666666666668,-5.666666666666668]]]],[0],[0],[0]],[22,[0],[0],[0],[3,1]],[23,[0],[0],[0]],[36,true,0.2,[0],[0],[0],[3,1]],[32,[0],[0],[0]],[24,[0],[0]],[25],[35,[0],[0],[8],[8]],[227,1,0.45,4.2,1,2,3]]],[1,"c9U2k3W15DnYImxymYMpPJ",null,null,null,1,0]]],0,[0,2,1,0,1,1,0,-1,2,0,1,2,0,5,1,4],[0,0,0,0,0,0,0],[-1,7,49,8,-1,7,8],[13,13,160,8,13,13,8]],[[[4,"Stone",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4287136633],"emissive",8,[4,4287136633]]],11]]],0,0,[0],[0],[0]],[[[4,"Brown",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":25,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4284450248],"emissive",8,[4,4284450248]]],11]]],0,0,[0],[0],[0]],[[[19],[17,"castle",[-2],[1,"06q8bXbxtaFL5Lb+Tp3u8p",null,null,null,-1,0]],[15,"castle",1,[[16,-3,[6,"c94NT1W5xX5KAbNCc7kl3X"],[0,1,2,3,4],[9],5]],[1,"eeacUXpm1dSZ941F9oBisY",null,null,null,1,0]]],0,[0,2,1,0,-1,2,0,1,2,0,5,1,3],[0,0,0,0,0,0],[-1,-2,-3,-4,-5,3],[161,162,163,164,165,166]],[[[4,"BrownDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4282735259],"emissive",8,[4,4282735259]]],11]]],0,0,[0],[0],[0]],[[[4,"White",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4293388263],"emissive",8,[4,4293388263]]],11]]],0,0,[0],[0],[0]],[[[4,"StoneDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4284768345],"emissive",8,[4,4284768345]]],11]]],0,0,[0],[0],[0]],[[[14,".bin",3683584594,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":123840,"length":17232,"count":4308,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":185088,"length":7092,"count":1773,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[2],"indexView":{"offset":194196,"length":264,"count":66,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[3],"indexView":{"offset":202332,"length":1104,"count":276,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[4],"indexView":{"offset":211980,"length":1080,"count":270,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":123840,"count":2580,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":141072,"length":44016,"count":917,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":192180,"length":2016,"count":42,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":194460,"length":7872,"count":164,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":203436,"length":8544,"count":178,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.9024187922477722,-0.025685003027319908,-0.9499285817146301],"maxPosition",8,[1,0.9024187922477722,2.507077932357788,0.9024187922477722]]],-1],0,0,[],[],[]],[[[4,"BrownDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4282735259],"emissive",8,[4,4282735259]]],11]]],0,0,[0],[0],[0]],[[[14,".bin",1550447011,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4368,"length":1404,"count":351,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":14028,"length":2640,"count":660,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":4368,"count":91,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":5772,"length":8256,"count":172,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.27688834071159363,-0.000911755720153451,-0.17305736243724823],"maxPosition",8,[1,0.2587195932865143,0.7565363645553589,0.2486431747674942]]],-1],0,0,[],[],[]],[[[19],[17,"detail_treeC",[-2],[1,"a4K9bi/XBTr4e3gZlzYVtr",null,null,null,-1,0]],[15,"detail_treeC",1,[[16,-3,[6,"18UXT8C0pduJ5nG3AfY/az"],[0,1],[9],2]],[1,"fc1dURISZbvY/4oolGx+8y",null,null,null,1,0]]],0,[0,2,1,0,-1,2,0,1,2,0,5,1,3],[0,0,0],[-1,-2,3],[167,168,169]],[[[4,"GreenDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4287466280],"emissive",8,[4,4287466280]]],11]]],0,0,[0],[0],[0]],[[[4,"material-009",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainTiling_Offset",8,[2,5,5,0,0],"tintColor",8,[4,2134062079],"mainTexture",6,0]],11]]],0,0,[0,0],[6,0],[10,1]],[[[4,"01 - Default",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":1}],[[[{"albedoScale":1,"specularFactor":0,"shininessExponent":1.9999999173704188,"emissiveScale":0},"mainColor",8,[4,4291480266],"specularColor",8,[4,4294177779],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[0],[0]],[[[4,"BrownDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4282735259],"emissive",8,[4,4282735259]]],11]]],0,0,[0],[0],[0]],[[[14,".bin",2303737069,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":3984,"length":1308,"count":327,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":19740,"length":5640,"count":1410,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":3984,"count":83,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":5292,"length":14448,"count":301,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.24838916957378387,0,-0.1719273328781128],"maxPosition",8,[1,0.23835070431232452,0.7268149852752686,0.17192775011062622]]],-1],0,0,[],[],[]],[[[19],[17,"detail_treeB",[-2],[1,"026DiC+npYBqhs90Rl7PXo",null,null,null,-1,0]],[15,"detail_treeB",1,[[16,-3,[6,"60p5BD1GxWDpFqpOrqRIyo"],[0,1],[9],2]],[1,"f0/MCuEPxSELndQ1CyVBTC",null,null,null,1,0]]],0,[0,2,1,0,-1,2,0,1,2,0,5,1,3],[0,0,0],[-1,-2,3],[170,171,172]],[[[4,"GreenDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4287466280],"emissive",8,[4,4287466280]]],11]]],0,0,[0],[0],[0]],[[[19],[17,"detail_rocks_small",[-2],[1,"a0vP15IIpfAKdgSklTl1lQ",null,null,null,-1,0]],[15,"detail_rocks_small",1,[[16,-3,[6,"93X/APyztUmajSR2ZqU1M4"],[0],[9],1]],[1,"04A4yyWStUqaSMfAbuy45y",null,null,null,1,0]]],0,[0,2,1,0,-1,2,0,1,2,0,5,1,3],[0,0],[-1,3],[173,174]],[[[4,"Stone",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4287136633],"emissive",8,[4,4287136633]]],11]]],0,0,[0],[0],[0]],[[[14,".bin",3033383193,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":21888,"length":6624,"count":1656,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":21888,"count":456,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.26563864946365356,-0.012810967862606049,-0.1890316605567932],"maxPosition",8,[1,0.38001301884651184,0.19927656650543213,0.3403770923614502]]],-1],0,0,[],[],[]],[[[4,"Stone",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4287136633],"emissive",8,[4,4287136633]]],11]]],0,0,[0],[0],[0]],[[[4,"BrownDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4282735259],"emissive",8,[4,4282735259]]],11]]],0,0,[0],[0],[0]],[[[14,".bin",453409429,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":70128,"length":22440,"count":5610,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":111768,"length":4080,"count":1020,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[2],"indexView":{"offset":143160,"length":8280,"count":2070,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":70128,"count":1461,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":92568,"length":19200,"count":400,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":115848,"length":27312,"count":569,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.9221485257148743,-0.0013824235647916794,-0.7839129567146301],"maxPosition",8,[1,0.9185132384300232,0.7324152588844299,0.39936262369155884]]],-1],0,0,[],[],[]],[[[19],[17,"detail_forestA",[-2],[1,"7b+UM53ahYJ75Pl0xQ772k",null,null,null,-1,0]],[15,"detail_forestA",1,[[16,-3,[6,"adAQhE8bNf9bV10ZtIWrfE"],[0,1,2],[9],3]],[1,"79vvT9z+VQOaTELJLpm9wS",null,null,null,1,0]]],0,[0,2,1,0,-1,2,0,1,2,0,5,1,3],[0,0,0,0],[-1,-2,-3,3],[175,176,177,178]],[[[4,"GreenDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4287466280],"emissive",8,[4,4287466280]]],11]]],0,0,[0],[0],[0]],[[[95,"depth-test",[{}],[{"rasterizerState":{},"depthStencilState":{"depthTest":true},"blendState":{"targets":[{}]}}],[{"USE_TEXTURE":true}]]],0,0,[0],[0],[179]],[[[4,"star_ADD",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[6,0],[7,1]],[[[77,"magic_line",1,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[6,0],[21,1]],[[[38,"Grid"],[91,"Grid",[-9,-10,-11,-12,-13,-14],[[62,-3,[6,"3dEQjIdlNAuo4UwqGNOY0/"],[5,2.56,2.56]],[230,-8,[6,"f79vkcAhpEwZu2YmACFLLC"],-7,-6,-5,-4]],[158,"a8fRM6kbVDjLwKJ6nfIBYV",null,null,-2,0,[-1]],[3,-0.7071067811865475,0,0,0.7071067811865476],[1,-90,0,0]],[60,"MergeEffect",1,[-16,-17,-18],[[65,0,2,false,false,1000,-15,[6,"2c4ke1UddOdaYGzH2MTw+K"],[18],[8],[20,3,0.1,0.3],[0],[0],[20,3,2,16],[0],[0],[0],[0],[20,3,0.3,0.5],[0],[0],[0],[[34,0.01,[3,35]]],[31,true,[27,1,[37,[[29],[29],[46,1,[4,4294908160]]]]]],[81,true,1,0.37843633,[0]],[26,true,[21,1,[18,[0,1],[[10,2,1],[10,2,1]]]],[0],[0],[0]],[22,[0],[0],[0],[3,1]],[23,[0],[0],[0]],[36,true,0.2,[0],[0],[0],[3,1]],[32,[0],[0],[0]],[24,[0],[0]],[25],[35,[0],[0],[8],[8]],[42,19,20]]],[1,"bbfVrq71ZN2KBcPXxpsYHR",null,null,null,1,0]],[7,["6eayv53tBNB5yEAigKuwqS"]],[11,0,{},1,[12,"335qPJretBVYfmbZsFenhw",null,null,-23,[96,"93HB08l/1Gk6fW9qn7fGIH",1,[[5,"AddgridEffect",["_name"],-19],[2,["_lpos"],-20,[1,0,0,0]],[2,["_lrot"],-21,[3,0,0,0,1]],[2,["_euler"],-22,[1,0,0,0]],[5,false,["playOnAwake"],3],[5,0.3888888888888889,["_sizeOvertimeModule","size","spline","_values","0","value"],3],[2,["startColor","color"],3,[4,1427761663]],[5,0,["_sizeOvertimeModule","size","spline","_times","0"],3],[5,-0.1313131313131315,["_sizeOvertimeModule","size","spline","_values","0","rightTangent"],3],[5,-0.1313131313131315,["_sizeOvertimeModule","size","spline","_values","0","leftTangent"],3]]],25]],[7,["335qPJretBVYfmbZsFenhw"]],[15,"Frame_Active",1,[[62,-24,[6,"d4CyR/MIVNZI24eKXluGZ2"],[5,2.56,2.56]],[154,0,-25,[6,"10AsjjD5tAwaiwj30j+g4u"],[4,3030448362],0,1]],[1,"e0jTVGrhZCPYhXc6dT/rdk",null,null,null,1,0]],[133,"Frame_Lock",false,1,[[62,-26,[6,"d01AvG3L5MYb3BG4E8BDSI"],[5,2.56,2.56]],[93,-27,[6,"37kXPWtChK0aOCgOh4SvDU"],[4,346093802],2,3]],[1,"b0ZqGJWLJMc6bM+I2d6szT",null,null,null,1,0]],[134,"DropPointEffect",1,[-28],[1,"cfGLzcdGBExonnXO/iljkX",null,null,null,1,0]],[135,"LevelUpEffect",1,[-29],[1,"d1oOB+ZZxMv6p5MRswtTgT",null,null,null,1,0],[1,0.6,1,0.6]],[61,"Rings",8,[[100,0,true,2,false,1.000000013418055,1.000000045812106,1.000000045812106,1000,-30,[6,"63mL9huSdOx6YSK2hJX+Wz"],[[4,null],6,0],[28,[4,2649867274]],[3,2],[3,2],[3,2],[0],[0],[0],[0],[0],[3,1.2],[0],[3,2],[0],[[34,0.01,[3,1]]],[31,true,[27,1,[55,[[29],[46,1,[4,4294919936]]],[[30,0,0.002232142857142857],[30,255,0.35714285714285715],[30,255,0.4107142857142857],[30,0,0.9977678571428571]]]]],[67,[0]],[26,true,[21,1,[18,[0,1],[[58,2,1,-2.243498817966903,1,-2.243498817966903,1],[58,2,0.11481481481481481,-0.11328976034858385,1,-0.11328976034858385,1]]]],[0],[0],[0]],[22,[0],[0],[0],[3,1]],[23,[0],[0],[0]],[36,true,0.1,[0],[0],[0],[3,1]],[32,[0],[0],[0]],[24,[0],[0]],[25],[35,[0],[0],[8],[8]],[108,4,1,5,6,7]]],[1,"0f5iAMLvdCILF3otEjUFEU",null,null,null,1,0],[1,1.5,1.5,1.5]],[136,"MagicVertical",2,[[99,0,2,false,false,1000,-31,[6,"991qsIFINICpy/mwCgG/0Z"],[[8,null],6,0],[8],[20,3,0.4,0.5],[0],[0],[20,3,4,24],[0],[0],[0],[0],[20,3,0.3,0.5],[0],[0],[0],[[34,0.01,[3,9]]],[31,true,[27,1,[37,[[29],[29],[46,1,[4,4294908160]]]]]],[103,true,0,0.37843633,0.005061454830783556,[0]],[26,true,[21,1,[18,[0,1],[[10,2,1],[104,2]]]],[0],[0],[0]],[22,[0],[0],[0],[3,1]],[23,[0],[0],[0]],[36,true,0.1,[0],[0],[0],[3,1]],[32,[0],[0],[0]],[24,[0],[0]],[25],[35,[0],[0],[8],[8]],[109,1,0.3,9,10]]],[1,"19DKc4vulMt6Spn7/Idhbh",null,null,null,1,0],[1,0,0,3],[3,1,0,0,6.123233995736766e-17],[1,5,5,3.5],[1,180,0,0]],[15,"MagicNova",2,[[65,0,2,false,false,1000,-32,[6,"fcMk4C08xFY4hDLM0ulsMs"],[11],[8],[3,4],[0],[0],[0],[0],[0],[0],[0],[3,0.35],[0],[0],[0],[[34,0.01,[3,1]]],[31,true,[27,1,[37,[[39,[4,4294967040]],[39,[4,4294967040]]]]]],[81,true,3,0.01,[0]],[26,true,[21,1,[18,[0,1],[[104,2],[10,2,1]]]],[0],[0],[0]],[22,[0],[0],[0],[3,1]],[23,[0],[0],[0]],[45,[0],[0],[0],[0]],[32,[0],[0],[0]],[24,[0],[0]],[25],[35,[0],[0],[8],[8]],[228,4,0.1,0,0,12,13,14]]],[1,"02ihozzkhJ/aY0j3XcG2sY",null,null,null,1,0]],[137,"MagicDust",2,[[65,0,2,false,false,1000,-33,[6,"27o7Ba5k1Kh69QxQlVrDBG"],[15],[8],[20,3,0.1,0.3],[0],[0],[20,3,2,16],[0],[0],[0],[0],[20,3,0.35,1.5],[0],[0],[0],[[34,0.01,[3,35]]],[31,true,[27,1,[37,[[29],[29],[46,1,[4,4294908160]]]]]],[103,true,0,0.37843633,0.02496132197090447,[0]],[26,true,[21,1,[18,[0,1],[[10,2,1],[10,2,1]]]],[0],[0],[0]],[22,[0],[0],[0],[3,1]],[23,[0],[0],[0]],[36,true,0.1,[0],[0],[0],[3,1]],[32,[0],[0],[0]],[24,[0],[0]],[25],[35,[0],[0],[8],[8]],[42,16,17]]],[1,"050ARX+uRMr7WkNUr0HwAm",null,null,null,1,0],[3,1,0,0,6.123233995736766e-17],[1,5,5,3.5],[1,180,0,0]],[61,"Rings",9,[[100,0,true,2,false,1.000000013418055,1.000000045812106,1.000000045812106,10,-34,[6,"62x+z87blHTLxDu6c0inzK"],[[21,null],6,0],[28,[4,1006698369]],[3,3.5],[3,3.5],[3,3.5],[0],[0],[0],[0],[0],[3,1.3],[0],[3,2],[0],[[34,0.01,[3,1]]],[31,true,[27,1,[55,[[29],[79,0.05357142857142857],[79,0.9977678571428571]],[[102,0],[30,247,0.28125],[30,255,0.38616071428571436],[30,96,0.5044642857142857],[30,0,1]]]]],[67,[0]],[26,true,[21,1,[18,[0,0.35128205128205126,1],[[68,2,0.26666666666666666,1.6095238095238094,1.6095238095238094],[68,2,0.7,0.6666666666666663,0.6666666666666663],[59,1,0.46245059288537554,1,0.46245059288537554,1]]]],[0],[0],[0]],[22,[0],[0],[0],[3,1]],[23,[0],[0],[0]],[36,true,0.1,[0],[0],[0],[3,1]],[32,[0],[0],[0]],[24,[0],[0]],[25],[35,[0],[0],[8],[8]],[108,4,1,22,23,24]]],[1,"19eKXc3vxNhq55jmS5LDE0",null,null,null,1,0],[1,1.2,0.7,1.2]]],0,[0,-1,4,0,2,1,0,1,1,0,50,4,0,51,9,0,52,2,0,53,8,0,1,1,0,-1,6,0,-2,7,0,-3,8,0,-4,2,0,-5,9,0,-6,4,0,1,2,0,-1,11,0,-2,12,0,-3,13,0,10,5,0,10,5,0,10,5,0,10,5,0,2,4,0,1,6,0,1,6,0,1,7,0,1,7,0,-1,10,0,-1,14,0,1,10,0,1,11,0,1,12,0,1,13,0,1,14,0,5,1,34],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[11,12,11,12,-1,3,7,8,-1,7,8,-1,3,7,8,-1,7,8,-1,7,8,-1,3,7,8,4],[5,37,5,37,14,4,14,22,12,12,21,38,180,38,39,15,15,23,15,15,23,14,4,14,22,181]],[[[4,"Stone",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4287136633],"emissive",8,[4,4287136633]]],11]]],0,0,[0],[0],[0]],[[[14,".bin",1602180611,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":17568,"length":3024,"count":756,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":17568,"count":366,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1,-0.5000000596046448,-0.37191569805145264],"maxPosition",8,[1,1,0.27688872814178467,0.3719162344932556]]],-1],0,0,[],[],[]],[[[19],[17,"bridge",[-2],[1,"3bOkID8IdRIpPtzTsDa0zJ",null,null,null,-1,0]],[15,"bridge",1,[[16,-3,[6,"40YPvwEtxSU59ng4FeR5fO"],[0],[9],1]],[1,"06igxcX7xQaqjOKRnzwu2v",null,null,null,1,0]]],0,[0,2,1,0,-1,2,0,1,2,0,5,1,3],[0,0],[-1,3],[182,183]],[[[4,"drop",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[6,0],[40,1]],[[[4,"wave3Material",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[6,0],[8,184]],[[[4,"Stone",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4287136633],"emissive",8,[4,4287136633]]],11]]],0,0,[0],[0],[0]],[[[4,"Brown",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":25,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4284450248],"emissive",8,[4,4284450248]]],11]]],0,0,[0],[0],[0]],[[[4,"BrownDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4282735259],"emissive",8,[4,4282735259]]],11]]],0,0,[0],[0],[0]],[[[19],[17,"watermill",[-2],[1,"28/ZOZhUBWpIZ5IHsZ/JcR",null,null,null,-1,0]],[60,"watermill",1,[-4],[[16,-3,[6,"85K1ZEscJXiZDTI4KIVHS+"],[2,3,4,5],[9],6]],[1,"6aksB1jTVd5pGqNl4lDvpP",null,null,null,1,0]],[86,"watermill_wheel",2,[[16,-5,[6,"43ytuyGvdeWpa96TGUOjsS"],[0],[9],1]],[1,"851DM6jghT954gocAwrLxt",null,null,null,1,0],[1,-0.18682861328125,0,0]]],0,[0,2,1,0,-1,2,0,1,2,0,-1,3,0,1,3,0,5,1,5],[0,0,0,0,0,0,0],[-1,3,-1,-2,-3,-4,3],[41,185,186,187,41,188,189]],[[[14,".bin",1773432547,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":52608,"length":9552,"count":2388,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":52608,"count":1096,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.2996215522289276,-0.49747902154922485,-0.49747902154922485],"maxPosition",8,[1,0.22007349133491516,0.49747902154922485,0.49747902154922485]]],-1],0,0,[],[],[]],[[[4,"White",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4293388263],"emissive",8,[4,4293388263]]],11]]],0,0,[0],[0],[0]],[[[14,".bin",3194491566,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":12960,"length":2280,"count":570,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":19128,"length":636,"count":159,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[2],"indexView":{"offset":45684,"length":3480,"count":870,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[3],"indexView":{"offset":62700,"length":3312,"count":828,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":12960,"count":270,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":15240,"length":3888,"count":81,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":19764,"length":25920,"count":540,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":49164,"length":13536,"count":282,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.5845520496368408,-0.5818215608596802,-0.7601938247680664],"maxPosition",8,[1,0.9497389793395996,1.0153011083602905,0.6601935625076294]]],-1],0,0,[],[],[]],[[{"name":"glow","rect":{"x":38,"y":38,"width":441,"height":440},"offset":{"x":2.5,"y":-2},"originalSize":{"width":512,"height":512},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-220.5,-220,0,220.5,-220,0,-220.5,220,0,220.5,220,0],"indexes":[0,1,2,2,1,3],"uv":[38,474,479,474,38,34,479,34],"nuv":[0.07421875,0.06640625,0.935546875,0.06640625,0.07421875,0.92578125,0.935546875,0.92578125],"minPos":{"x":-220.5,"y":-220,"z":0},"maxPos":{"x":220.5,"y":220,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[9],0,[0],[15],[18]],[[[38,"Tombstone"],[17,"Tombstone",[-2],[1,"69HkTm8Z1H5rvkgdZrF03c",null,null,null,-1,0]],[74,"Tombstone 01",1,[[16,-3,[6,"04bqb8EtRB8KQTvn3Bmwdp"],[0],[9],1]],[1,"daEe85Y6xH4oIxnmcJeiMH",null,null,null,1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]]],0,[0,2,1,0,-1,2,0,1,2,0,5,1,3],[0,0],[-1,3],[190,191]],[[[4,"Beige",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":25,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4286492378],"emissive",8,[4,4286492378]]],11]]],0,0,[0],[0],[0]],[[[4,"Stone",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4287136633],"emissive",8,[4,4287136633]]],11]]],0,0,[0],[0],[0]],[[[4,"Brown",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":25,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4284450248],"emissive",8,[4,4284450248]]],11]]],0,0,[0],[0],[0]],[[[4,"BrownDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4282735259],"emissive",8,[4,4282735259]]],11]]],0,0,[0],[0],[0]],[[[14,".bin",3947203243,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":18528,"length":4344,"count":1086,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":42648,"length":4848,"count":1212,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[2],"indexView":{"offset":66792,"length":3264,"count":816,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[3],"indexView":{"offset":79944,"length":1968,"count":492,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[4],"indexView":{"offset":82872,"length":192,"count":48,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[5],"indexView":{"offset":84216,"length":408,"count":102,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":18528,"count":386,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":22872,"length":19776,"count":412,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":47496,"length":19296,"count":402,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":70056,"length":9888,"count":206,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":81912,"length":960,"count":20,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":83064,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.5089786648750305,-0.0017956208903342485,-0.5089786052703857],"maxPosition",8,[1,0.508978545665741,0.7348325848579407,0.5089786648750305]]],-1],0,0,[],[],[]],[[[4,"StoneDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4284768345],"emissive",8,[4,4284768345]]],11]]],0,0,[0],[0],[0]],[[[4,"Water",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":75.64481244355295,"emissiveScale":0,"metallic":0,"specularFactor":0.4431818127632141,"transparencyFactor":0.43636369705200195},"mainColor",8,[4,4292990536],"emissive",8,[4,4292990536]]],11]]],0,0,[0],[0],[0]],[[[19],[17,"well",[-2],[1,"a6s/76YylUDath8HJKWyRJ",null,null,null,-1,0]],[15,"well",1,[[16,-3,[6,"9dYAIiaQ5eEbRb4TUIxltA"],[0,1,2,3,4,5],[9],6]],[1,"b4AMGLS5xRur6U13o74/DN",null,null,null,1,0]]],0,[0,2,1,0,-1,2,0,1,2,0,5,1,3],[0,0,0,0,0,0,0],[-1,-2,-3,-4,-5,-6,3],[192,193,194,195,196,197,198]],[[[4,"material-004",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"tintColor",8,[4,4294967295],"mainTexture",6,0]],11]]],0,0,[0,0],[6,0],[3,1]],[[[4,"Beige",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":25,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4286492378],"emissive",8,[4,4286492378]]],11]]],0,0,[0],[0],[0]],[[[4,"Stone",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4287136633],"emissive",8,[4,4287136633]]],11]]],0,0,[0],[0],[0]],[[[14,".bin",4283739474,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":56976,"length":13740,"count":3435,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":92700,"length":2928,"count":732,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[2],"indexView":{"offset":104796,"length":2232,"count":558,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[3],"indexView":{"offset":114420,"length":1104,"count":276,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[4],"indexView":{"offset":118404,"length":408,"count":102,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[5],"indexView":{"offset":119964,"length":408,"count":102,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":56976,"count":1187,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":70716,"length":21984,"count":458,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":95628,"length":9168,"count":191,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":107028,"length":7392,"count":154,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":115524,"length":2880,"count":60,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":118812,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.8586623072624207,-0.010111819952726364,-0.9042723774909973],"maxPosition",8,[1,0.7559695839881897,0.8193082809448242,0.978651225566864]]],-1],0,0,[],[],[]],[[[4,"BrownDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4282735259],"emissive",8,[4,4282735259]]],11]]],0,0,[0],[0],[0]],[[[4,"Metal",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":48.99999833106996,"emissiveScale":0,"metallic":0.20000000298023224,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4290689194],"emissive",8,[4,4290689194]]],11]]],0,0,[0],[0],[0]],[[[19],[17,"mine",[-2],[1,"91NVVIJM5ZJL8o4UPyILuR",null,null,null,-1,0]],[15,"mine",1,[[16,-3,[6,"4e20QItpBXMJ+WKBO9P7Vc"],[0,1,2,3,4,5],[9],6]],[1,"d4NVftbfBcJYjKk8f1mW+6",null,null,null,1,0]]],0,[0,2,1,0,-1,2,0,1,2,0,5,1,3],[0,0,0,0,0,0,0],[-1,-2,-3,-4,-5,-6,3],[199,200,201,202,203,204,205]],[[[4,"Black",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":25,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4281741862],"emissive",8,[4,4281741862]]],11]]],0,0,[0],[0],[0]],[[[4,"WoodDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4284244077],"emissive",8,[4,4284244077]]],11]]],0,0,[0],[0],[0]],[[{"name":"UI_UIHome_Frame","rect":{"x":0,"y":0,"width":256,"height":256},"offset":{"x":0,"y":0},"originalSize":{"width":256,"height":256},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-128,-128,0,128,-128,0,-128,128,0,128,128,0],"indexes":[0,1,2,2,1,3],"uv":[0,256,256,256,0,0,256,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-128,"y":-128,"z":0},"maxPos":{"x":128,"y":128,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[9],0,[0],[15],[206]],[[[19],[17,"detail_treeA",[-2],[1,"44gpMHLDdZBJSLZ/87jJX2",null,null,null,-1,0]],[15,"detail_treeA",1,[[16,-3,[6,"f7p5YGE/RfQoAbEXClWLyb"],[0,1],[9],2]],[1,"5aCeAEAHJShoU1iN/lEMxW",null,null,null,1,0]]],0,[0,2,1,0,-1,2,0,1,2,0,5,1,3],[0,0,0],[-1,-2,3],[207,208,209]],[[[4,"BrownDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4282735259],"emissive",8,[4,4282735259]]],11]]],0,0,[0],[0],[0]],[[[4,"GreenDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4287466280],"emissive",8,[4,4287466280]]],11]]],0,0,[0],[0],[0]],[[[14,".bin",25277781,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4272,"length":1404,"count":351,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":11436,"length":2040,"count":510,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":4272,"count":89,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":5676,"length":5760,"count":120,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.2724704444408417,-1.440661545615285e-8,-0.19510294497013092],"maxPosition",8,[1,0.3212660551071167,0.7803274989128113,0.19653400778770447]]],-1],0,0,[],[],[]],[[[4,"Stone",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4287136633],"emissive",8,[4,4287136633]]],11]]],0,0,[0],[0],[0]],[[[19],[17,"detail_rocks",[-2],[1,"5eAuWkKMRejop04tjMb5q/",null,null,null,-1,0]],[15,"detail_rocks",1,[[16,-3,[6,"d6OQFYJSRbQLwrLpBAv+iv"],[0],[9],1]],[1,"98gkRVmQJRZ7/mkXu8E1kr",null,null,null,1,0]]],0,[0,2,1,0,-1,2,0,1,2,0,5,1,3],[0,0],[-1,3],[210,211]],[[[14,".bin",510100871,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":43200,"length":13224,"count":3306,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":43200,"count":900,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.934990644454956,-0.05062481015920639,-0.82896888256073],"maxPosition",8,[1,0.9572367668151855,0.5131850838661194,0.5014674663543701]]],-1],0,0,[],[],[]],[[[4,"material-003",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"tintColor",8,[4,4294967295],"mainTexture",6,0]],11]]],0,0,[0,0],[6,0],[42,1]],[[[4,"material-005",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"tintColor",8,[4,4294967295],"mainTexture",6,0]],11]]],0,0,[0,0],[6,0],[3,1]],[[[38,"AddgridEffect"],[138,"AddgridEffect",[-2],[1,"335qPJretBVYfmbZsFenhw",null,null,null,-1,0],[3,-0.7071068,0,0,0.7071068],[1,1,1,0.1],[1,-90.00000304885037,0,0]],[15,"Rings",1,[[54,0,1,false,1000,-3,[6,"6eayv53tBNB5yEAigKuwqS"],[0],[28,[4,756673023]],[3,3.5],[0],[0],[0],[0],[0],[0],[0],[3,1],[0],[3,1],[0],[[34,0.01,[3,1]]],[31,true,[27,1,[37,[[39,[4,352321535]],[39,[4,2533359615]]]]]],[67,[0]],[26,true,[21,1,[18,[0,1],[[58,2,0.5666666666666667,-0.10317460317460281,1,-0.10317460317460281,1],[58,2,1,2,1,2,1]]]],[0],[0],[0]],[22,[0],[0],[0],[3,1]],[23,[0],[0],[0]],[36,true,0.1,[0],[0],[0],[3,1]],[32,[0],[0],[0]],[24,[0],[0]],[25],[35,[0],[0],[8],[8]],[229,4,0,1,2]]],[1,"11Fv4uzH5NY5yLgP5jjCvW",null,null,null,1,0]]],0,[0,2,1,0,-1,2,0,1,2,0,5,1,3],[0,0,0],[-1,3,7],[43,4,43]],[[[95,"material",[{}],[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}]]],0,0,[0],[0],[1]],[[[4,"Beige",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":25,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4286492378],"emissive",8,[4,4286492378]]],11]]],0,0,[0],[0],[0]],[[[4,"Stone",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4287136633],"emissive",8,[4,4287136633]]],11]]],0,0,[0],[0],[0]],[[[4,"Brown",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":25,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4284450248],"emissive",8,[4,4284450248]]],11]]],0,0,[0],[0],[0]],[[[4,"BrownDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4282735259],"emissive",8,[4,4282735259]]],11]]],0,0,[0],[0],[0]],[[[14,".bin",973248751,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":14112,"length":2112,"count":528,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":21360,"length":1440,"count":360,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[2],"indexView":{"offset":27024,"length":720,"count":180,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[3],"indexView":{"offset":112224,"length":14064,"count":3516,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[4],"indexView":{"offset":147600,"length":4752,"count":1188,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":14112,"count":294,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":16224,"length":5136,"count":107,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":22800,"length":4224,"count":88,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":27744,"length":84480,"count":1760,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":126288,"length":21312,"count":444,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.7499575614929199,-0.041470497846603394,-0.7716118097305298],"maxPosition",8,[1,0.719839334487915,0.8224505186080933,0.9028338193893433]]],-1],0,0,[],[],[]],[[[4,"White",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4293388263],"emissive",8,[4,4293388263]]],11]]],0,0,[0],[0],[0]],[[[19],[17,"market",[-2],[1,"1049DupJpQf5UnBb4YUKhX",null,null,null,-1,0]],[15,"market",1,[[16,-3,[6,"cewaqPcTNaLpqJsFUqELUk"],[0,1,2,3,4],[9],5]],[1,"59ZuZpyCtUp7tSHoQJErs1",null,null,null,1,0]]],0,[0,2,1,0,-1,2,0,1,2,0,5,1,3],[0,0,0,0,0,0],[-1,-2,-3,-4,-5,3],[212,213,214,215,216,217]],[[[160,"default-material",[{"roughness":0.8,"metallic":0.6}],[{}]]],0,0,[0],[0],[27]],[[[4,"Pink",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_ALBEDO_MAP":true},{},{}],[[[{},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[6,0],[218,19]],[[[4,"Stone",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4287136633],"emissive",8,[4,4287136633]]],11]]],0,0,[0],[0],[0]],[[[14,".bin",2392449984,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":39408,"length":5784,"count":1446,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":39408,"count":821,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.9999992251396179,-5.640098610371069e-9,-0.9128385782241821],"maxPosition",8,[1,0.5810592174530029,1.1524349451065063,0.3649417459964752]]],-1],0,0,[],[],[]],[[[19],[17,"wall_hexCornerA",[-2],[1,"1dWTsuPdVe0aFp0lKbQRVO",null,null,null,-1,0]],[15,"wall_hexCornerA",1,[[16,-3,[6,"44pW0MWsJUdb/jDW3g22K5"],[0],[9],1]],[1,"aaRDxXHT9d+7lVUT++x0aC",null,null,null,1,0]]],0,[0,2,1,0,-1,2,0,1,2,0,5,1,3],[0,0],[-1,3],[219,220]],[[[4,"PolySpriteRingGlowSoft",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[6,0],[22,1]],[[[4,"Stone",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4287136633],"emissive",8,[4,4287136633]]],11]]],0,0,[0],[0],[0]],[[[14,".bin",837769414,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":46032,"length":11820,"count":2955,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":46032,"count":959,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.8331913948059082,-4.656612873077393e-10,-0.9567052721977234],"maxPosition",8,[1,0.9545031189918518,1.2167316675186157,0.95038902759552]]],-1],0,0,[],[],[]],[[[19],[17,"mountain",[-2],[1,"83SeZfoXpYxqDSeafSTC8H",null,null,null,-1,0]],[15,"mountain",1,[[16,-3,[6,"56cTGTam1TI7a9ATz3Obhp"],[0],[9],1]],[1,"bbj1vKpHBZEpe9sKTpmR43",null,null,null,1,0]]],0,[0,2,1,0,-1,2,0,1,2,0,5,1,3],[0,0],[-1,3],[221,222]],[[[4,"Stone",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4287136633],"emissive",8,[4,4287136633]]],11]]],0,0,[0],[0],[0]],[[[4,"BrownDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4282735259],"emissive",8,[4,4282735259]]],11]]],0,0,[0],[0],[0]],[[[19],[17,"detail_hill",[-2],[1,"c6nN0Zi/FfTa0pFPzCfQDP",null,null,null,-1,0]],[15,"detail_hill",1,[[16,-3,[6,"d2I2TuMFZaDbUkDhyVmOMt"],[0,1,2,3],[9],4]],[1,"aaJIYlpxRcVJim1F1rZATA",null,null,null,1,0]]],0,[0,2,1,0,-1,2,0,1,2,0,5,1,3],[0,0,0,0,0],[-1,-2,-3,-4,3],[223,224,225,226,227]],[[[14,".bin",3938308948,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":360,"count":90,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":19704,"length":4116,"count":1029,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[2],"indexView":{"offset":67068,"length":14736,"count":3684,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[3],"indexView":{"offset":87852,"length":912,"count":228,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":1512,"length":18192,"count":379,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":23820,"length":43248,"count":901,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":81804,"length":6048,"count":126,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.9542747735977173,-0.002388477325439453,-0.81588214635849],"maxPosition",8,[1,0.8644835948944092,1.098442554473877,0.7729062438011169]]],-1],0,0,[],[],[]],[[[4,"Green",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4287478856],"emissive",8,[4,4287478856]]],11]]],0,0,[0],[0],[0]],[[[4,"GreenDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4287466280],"emissive",8,[4,4287466280]]],11]]],0,0,[0],[0],[0]],[[[4,"Stone",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4287136633],"emissive",8,[4,4287136633]]],11]]],0,0,[0],[0],[0]],[[[4,"Brown",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":25,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4284450248],"emissive",8,[4,4284450248]]],11]]],0,0,[0],[0],[0]],[[[4,"BrownDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4282735259],"emissive",8,[4,4282735259]]],11]]],0,0,[0],[0],[0]],[[[4,"Metal",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":48.99999833106996,"emissiveScale":0,"metallic":0.20000000298023224,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4290689194],"emissive",8,[4,4290689194]]],11]]],0,0,[0],[0],[0]],[[[14,".bin",3712150439,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":25584,"length":5184,"count":1296,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":47904,"length":3840,"count":960,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[2],"indexView":{"offset":54336,"length":360,"count":90,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[3],"indexView":{"offset":105768,"length":9936,"count":2484,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[4],"indexView":{"offset":121560,"length":1056,"count":264,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":25584,"count":533,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":30768,"length":17136,"count":357,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":51744,"length":2592,"count":54,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":54696,"length":51072,"count":1064,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":115704,"length":5856,"count":122,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.9165546894073486,-0.015705034136772156,-0.8066155910491943],"maxPosition",8,[1,0.9074838757514954,1.4538322687149048,0.8508687019348145]]],-1],0,0,[],[],[]],[[[19],[17,"lumbermill",[-2],[1,"f16fPRMOlZE75uC/M+GpMx",null,null,null,-1,0]],[15,"lumbermill",1,[[16,-3,[6,"83jxu+pNZSNqS2ESmX5RFl"],[0,1,2,3,4],[9],5]],[1,"01laPWpoxTX5chwI/zJ2sH",null,null,null,1,0]]],0,[0,2,1,0,-1,2,0,1,2,0,5,1,3],[0,0,0,0,0,0],[-1,-2,-3,-4,-5,3],[228,229,230,231,232,233]],[[[4,"White",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4293388263],"emissive",8,[4,4293388263]]],11]]],0,0,[0],[0],[0]],[[[4,"material-008",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainTiling_Offset",8,[2,0.99,1,0,0],"tintColor",8,[4,1593835519],"mainTexture",6,0]],11]]],0,0,[0,0],[6,0],[234,235]],[[{"name":"UI_UIHome_Semicircle","rect":{"x":22,"y":0,"width":467,"height":184},"offset":{"x":-0.5,"y":164},"originalSize":{"width":512,"height":512},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-233.5,-92,0,233.5,-92,0,-233.5,92,0,233.5,92,0],"indexes":[0,1,2,2,1,3],"uv":[22,512,489,512,22,328,489,328],"nuv":[0.04296875,0.640625,0.955078125,0.640625,0.04296875,1,0.955078125,1],"minPos":{"x":-233.5,"y":-92,"z":0},"maxPos":{"x":233.5,"y":92,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[9],0,[0],[15],[236]],[[[4,"Stone",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4287136633],"emissive",8,[4,4287136633]]],11]]],0,0,[0],[0],[0]],[[[4,"StoneDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4284768345],"emissive",8,[4,4284768345]]],11]]],0,0,[0],[0],[0]],[[[14,".bin",1007769244,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":66720,"length":9480,"count":2370,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":89832,"length":2184,"count":546,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":66720,"count":1390,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":76200,"length":13632,"count":284,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.9999998211860657,0,-0.26715904474258423],"maxPosition",8,[1,0.9999998211860657,1.152435064315796,0.2671549320220947]]],-1],0,0,[],[],[]],[[[19],[17,"wall_gate",[-2],[1,"66FDFaqbFb2LUhzGHgFhmQ",null,null,null,-1,0]],[15,"wall_gate",1,[[16,-3,[6,"aeYEqtMIla1KxIyP93jpaV"],[0,1],[9],2]],[1,"e14/KvnhlRV4rS4txldjhm",null,null,null,1,0]]],0,[0,2,1,0,-1,2,0,1,2,0,5,1,3],[0,0,0],[-1,-2,3],[237,238,239]],[[{"name":"飞书20230407-163602","rect":{"x":0,"y":0,"width":2160,"height":2340},"offset":{"x":0,"y":0},"originalSize":{"width":2160,"height":2340},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-1080,-1170,0,1080,-1170,0,-1080,1170,0,1080,1170,0],"indexes":[0,1,2,2,1,3],"uv":[0,2340,2160,2340,0,0,2160,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-1080,"y":-1170,"z":0},"maxPos":{"x":1080,"y":1170,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[9],0,[0],[15],[240]],[[[38,"ExplosionBlue"],[139,"ExplosionBlue",[-3,-4,-5],[[211,false,false,true,-2,[6,"da1Is/J0dNRYuSYA9odZAm"],[[9,null],6,0],[28,[4,4294943085]],[20,3,0.3,0.2],[0],[0],[3,1],[0],[0],[0],[0],[20,3,0.3,0.2],[0],[0],[0],[[40,[3,10]]],[48,true,3,0.1,0.1,[3,1]],[26,true,[21,1,[18,[0,1],[[59,1,-1,1,-1,1],[69,-1,1,-1,1]]]],[0],[0],[0]],[218,true,true,[3,0.015230877516916316],[3,0.015230877516916316],[3,0.015230877516916316]],[42,10,11]]],[1,"2e7VCZP99NApRb078JrDLb",null,null,null,-1,0],[1,1,0.693,-4],[1,2,2,2]],[61,"Particle-001",1,[[212,false,false,true,-6,[6,"63Um9km2tBDa9xolvJwF7j"],[[0,null],6,0],[27,4,[55,[[29]],[[102,255],[30,255,0.19866071428571427],[30,255,0.6004464285714286],[30,255,0.9910714285714286]]]],[3,5],[0],[0],[0],[0],[0],[0],[0],[3,0.15],[0],[0],[0],[[40,[3,1]]],[26,true,[21,1,[18,[0.017948717948717947,0.24615384615384617,1],[[69,-1,1,-1,1],[10,2,1],[69,-1.3265306122448979,1,-1.3265306122448979,1]]]],[0],[0],[0]],[42,1,2]]],[1,"9fhZRk9IBHWYEiljmHShDx",null,null,null,1,0],[1,0.5,0.5,0.5]],[85,"Particle-001",false,1,[[213,false,false,true,-7,[6,"5eNPV5OGhIuJTJMGN9fVWb"],[[3,null],6,0],[28,[4,4294925353]],[20,3,0.7,0.3],[0],[0],[3,1],[0],[0],[0],[0],[20,3,0.4,0.2],[0],[0],[0],[[40,[3,15]]],[48,true,3,0.02,0.02,[3,1]],[26,true,[21,1,[18,[0,0.10256410256410256,1],[[59,1,-1,1,-1,1],[68,2,0.3962962962962963,-0.22657952069716808,-0.22657952069716808],[69,-0.4415873015873016,1,-0.4415873015873016,1]]]],[0],[0],[0]],[109,1,-0.35,4,5]]],[1,"d7trJRq29GC5Zfb4G5+yaX",null,null,null,1,0],[1,0.6,0.6,0.6]],[151,"Particle-002",false,1,[-8],[1,"ffsHy4sxJBC6lOdTeApUUI",null,null,null,1,0],[1,0.6,0.6,0.6]],[214,false,false,true,4,[6,"09TTe2YvtM27fohIzjuxhx"],[[6,null],6,0],[28,[4,452961024]],[3,7],[0],[0],[0],[0],[0],[0],[0],[3,0.2],[0],[0],[0],[[40,[3,1]]],[31,true,[27,4,[55,[[29]],[[101],[30,255,0.21651785714285715],[30,255,0.5892857142857143],[30,0,1]]]]],[26,true,[21,1,[18,[0,0.06923076923076923,1],[[59,0.16296296296296298,-1,1,-1,1],[10,2,0.7925925925925926],[59,1,0.22283440465258642,1,0.22283440465258642,1]]]],[0],[0],[0]],[223,true,[3,1],[0],[8],[28,[4,16777215]],-9],[42,7,8]]],0,[0,2,1,0,1,1,0,-1,2,0,-2,3,0,-3,4,0,1,2,0,1,3,0,-1,5,0,13,5,0,5,1,9],[0,0,0,0,0,0,0,0,0,0,0,0],[-1,7,8,-1,7,8,-1,7,8,-1,7,8],[44,44,42,45,45,3,46,46,3,47,47,7]],[[[38,"StarExplosionBlue"],[90,"StarExplosionBlue",[-3,-4,-5],[[54,0,1,false,1000,-2,[6,"caF56kmatNaJ3527GOvbWs"],[9],[28,[4,4294918400]],[20,3,0.9,1.2],[0],[0],[3,1],[0],[0],[0],[0],[20,3,0.3,0.4],[0],[0],[0],[[34,0.01,[3,6]]],[31,true,[27,1,[37,[[29],[79,1]]]]],[48,true,3,3,0,[0]],[26,true,[21,1,[18,[0,1],[[10,2,1],[10,2,1]]]],[0],[0],[0]],[22,[0],[0],[0],[3,1]],[23,[0],[0],[0]],[36,true,0.08,[0],[0],[0],[3,1]],[57,true,[0],[0],[80,2,[18,[0,1],[[10,2,1],[10,2,1]]],[18,[0,1],[[10,2,1],[10,2,1]]]]],[24,[0],[0]],[25],[35,[0],[0],[8],[8]],[42,10,11]]],[1,"7988Dy/L9KXqtFQ+QIditz",null,null,null,-1,0],[1,-0.12000005,1.3000002,0.0398916],[3,0.7071068,0,0,0.7071068],[1,90.00000304885037,0,0]],[15,"StarBurstDebris",1,[[54,0,1,false,1000,-6,[6,"84YW3gpU9Bd4ye82ahmtcI"],[0],[28,[4,4294963634]],[3,0.6],[0],[0],[20,3,9,16],[0],[0],[0],[0],[20,3,0.3,0.4],[0],[0],[0],[[34,0.01,[3,32]]],[31,true,[27,1,[37,[[39,[4,16777215]],[29]]]]],[48,true,3,2.3,0,[0]],[26,true,[21,1,[18,[0,1],[[10,2,1],[10,2,1]]]],[0],[0],[0]],[22,[0],[0],[0],[3,1]],[23,[0],[0],[0]],[36,true,0.3,[0],[0],[0],[3,1]],[32,[0],[0],[0]],[24,[0],[0]],[25],[35,[0],[0],[8],[8]],[107,1,0.05,0.2,1,2]]],[1,"bdQT+plIZI/IjtqDSAlJS+",null,null,null,1,0]],[15,"StarBurst",1,[[54,0,1,false,1000,-7,[6,"e7i8mXCfRClZ/NzzP5ref/"],[3],[28,[4,4294937624]],[3,0.4],[0],[0],[20,3,3,8],[0],[0],[0],[0],[20,3,0.6,1],[3,0.12],[0],[0],[[34,0.01,[3,12]]],[31,true,[27,1,[37,[[29],[29]]]]],[81,true,3,1.8,[0]],[26,true,[21,1,[18,[0,1],[[10,2,1],[10,2,1]]]],[0],[0],[0]],[22,[0],[0],[0],[3,1]],[23,[0],[0],[0]],[36,true,0.2,[0],[0],[0],[3,1]],[57,true,[0],[0],[80,2,[18,[0,1],[[10,2,1],[10,2,1]]],[18,[0,1],[[10,2,1],[10,2,1]]]]],[24,[0],[0]],[25],[35,[0],[0],[8],[8]],[42,4,5]]],[1,"d3kmEAz8xJQZmUuWcl9rx1",null,null,null,1,0]],[61,"Glow",1,[[54,0,1,false,1000,-8,[6,"13Kc22DFZD1pxG9mZkcQq9"],[6],[8],[3,5],[0],[0],[0],[0],[0],[0],[0],[3,0.3],[0],[0],[0],[[34,0.01,[3,1]]],[31,true,[27,1,[37,[[39,[4,4294967040]],[39,[4,16728320]]]]]],[67,[0]],[26,true,[21,1,[18,[0,1],[[10,2,1],[10,2,1]]]],[0],[0],[0]],[22,[0],[0],[0],[3,1]],[23,[0],[0],[0]],[36,true,0.09,[0],[0],[0],[3,1]],[57,true,[0],[0],[80,2,[18,[0,1],[[10,2,1],[10,2,1]]],[18,[0,1],[[10,2,1],[10,2,1]]]]],[24,[0],[0]],[25],[35,[0],[0],[8],[8]],[42,7,8]]],[1,"a2zZmIMyRDGJVAQd/N6FKD",null,null,null,1,0],[1,2,2,2]]],0,[0,2,1,0,1,1,0,-1,2,0,-2,3,0,-3,4,0,1,2,0,1,3,0,1,4,0,5,1,8],[0,0,0,0,0,0,0,0,0,0,0,0],[-1,7,8,-1,7,8,-1,7,8,-1,7,8],[48,48,40,16,16,7,49,49,18,16,16,7]],[[[159,"particle-add",[{}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[6,0],[20,1]],[[[4,"Beige",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":25,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4286492378],"emissive",8,[4,4286492378]]],11]]],0,0,[0],[0],[0]],[[[4,"Stone",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4287136633],"emissive",8,[4,4287136633]]],11]]],0,0,[0],[0],[0]],[[[19],[17,"barracks",[-2],[1,"c4LJ9jiRVSPLe9zSJfp4ep",null,null,null,-1,0]],[15,"barracks",1,[[16,-3,[6,"a5mtf5fWFTiLlgXhJkujFw"],[0,1,2,3,4,5],[9],6]],[1,"16Yodp29FdTZzrTAGARaxM",null,null,null,1,0]]],0,[0,2,1,0,-1,2,0,1,2,0,5,1,3],[0,0,0,0,0,0,0],[-1,-2,-3,-4,-5,-6,3],[241,242,243,244,245,246,247]],[[[4,"Brown",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":25,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4284450248],"emissive",8,[4,4284450248]]],11]]],0,0,[0],[0],[0]],[[[4,"BrownDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4282735259],"emissive",8,[4,4282735259]]],11]]],0,0,[0],[0],[0]],[[[14,".bin",3560420115,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":9792,"length":1920,"count":480,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":41520,"length":5160,"count":1290,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[2],"indexView":{"offset":50088,"length":528,"count":132,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[3],"indexView":{"offset":93144,"length":5952,"count":1488,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[4],"indexView":{"offset":138168,"length":5280,"count":1320,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[5],"indexView":{"offset":164760,"length":4680,"count":1170,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":9792,"count":204,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":11712,"length":29808,"count":621,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":46680,"length":3408,"count":71,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":50616,"length":42528,"count":886,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":99096,"length":39072,"count":814,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":143448,"length":21312,"count":444,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.0041617155075073,-0.00722624734044075,-1.0461702346801758],"maxPosition",8,[1,0.9846583008766174,1.2912858724594116,0.5639222264289856]]],-1],0,0,[],[],[]],[[[4,"White",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4293388263],"emissive",8,[4,4293388263]]],11]]],0,0,[0],[0],[0]],[[[4,"StoneDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4284768345],"emissive",8,[4,4284768345]]],11]]],0,0,[0],[0],[0]],[[{"name":"UI_UIHome_Arrow","rect":{"x":210,"y":33,"width":92,"height":241},"offset":{"x":0,"y":102.5},"originalSize":{"width":512,"height":512},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-46,-120.5,0,46,-120.5,0,-46,120.5,0,46,120.5,0],"indexes":[0,1,2,2,1,3],"uv":[210,479,302,479,210,238,302,238],"nuv":[0.41015625,0.46484375,0.58984375,0.46484375,0.41015625,0.935546875,0.58984375,0.935546875],"minPos":{"x":-46,"y":-120.5,"z":0},"maxPos":{"x":46,"y":120.5,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[9],0,[0],[15],[248]],[[[4,"magic_orb",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[6,0],[23,1]],[[[4,"ring (additive)",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"tintColor",8,[4,4294967295],"mainTexture",6,0]],11]]],0,0,[0,0],[6,0],[39,1]],[[[4,"Beige",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":25,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4286492378],"emissive",8,[4,4286492378]]],11]]],0,0,[0],[0],[0]],[[[4,"Stone",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4287136633],"emissive",8,[4,4287136633]]],11]]],0,0,[0],[0],[0]],[[[4,"Brown",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":25,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4284450248],"emissive",8,[4,4284450248]]],11]]],0,0,[0],[0],[0]],[[[4,"BrownDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4282735259],"emissive",8,[4,4282735259]]],11]]],0,0,[0],[0],[0]],[[[4,"Red",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":25,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4284493055],"emissive",8,[4,4284493055]]],11]]],0,0,[0],[0],[0]],[[[19],[17,"archeryrange",[-2],[1,"59DC7Jl6FSGbnmh7R6CKSw",null,null,null,-1,0]],[15,"archeryrange",1,[[16,-3,[6,"07oiKlLPpdV68yL5xguvjs"],[0,1,2,3,4,5],[9],6]],[1,"deYIsUBm9cw71EZa8ETDwS",null,null,null,1,0]]],0,[0,2,1,0,-1,2,0,1,2,0,5,1,3],[0,0,0,0,0,0,0],[-1,-2,-3,-4,-5,-6,3],[249,250,251,252,253,254,255]],[[[14,".bin",3701233607,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":18048,"length":4368,"count":1092,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":53424,"length":5472,"count":1368,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[2],"indexView":{"offset":77088,"length":3384,"count":846,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[3],"indexView":{"offset":114936,"length":4632,"count":1158,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[4],"indexView":{"offset":123936,"length":1296,"count":324,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[5],"indexView":{"offset":128784,"length":864,"count":216,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":18048,"count":376,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":22416,"length":31008,"count":646,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":58896,"length":18192,"count":379,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":80472,"length":34464,"count":718,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":119568,"length":4368,"count":91,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":125232,"length":3552,"count":74,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.8393239974975586,-0.003973501734435558,-0.7870208024978638],"maxPosition",8,[1,0.963099479675293,1.534070611000061,0.7643352746963501]]],-1],0,0,[],[],[]],[[[4,"White",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":35.99999928474426,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4293388263],"emissive",8,[4,4293388263]]],11]]],0,0,[0],[0],[0]]]]
